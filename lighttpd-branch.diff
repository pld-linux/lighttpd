# Revision 2686
Index: src/mod_rewrite.c
===================================================================
--- src/mod_rewrite.c	(.../tags/lighttpd-1.4.24)
+++ src/mod_rewrite.c	(.../branches/lighttpd-1.4.x)
@@ -9,10 +9,9 @@
 #include <stdlib.h>
 #include <string.h>
 
-typedef struct {
 #ifdef HAVE_PCRE_H
+typedef struct {
 	pcre *key;
-#endif
 
 	buffer *value;
 
@@ -70,7 +69,6 @@
 }
 
 static int rewrite_rule_buffer_append(rewrite_rule_buffer *kvb, buffer *key, buffer *value, int once) {
-#ifdef HAVE_PCRE_H
 	size_t i;
 	const char *errptr;
 	int erroff;
@@ -109,18 +107,9 @@
 	kvb->used++;
 
 	return 0;
-#else
-	UNUSED(kvb);
-	UNUSED(value);
-	UNUSED(once);
-	UNUSED(key);
-
-	return -1;
-#endif
 }
 
 static void rewrite_rule_buffer_free(rewrite_rule_buffer *kvb) {
-#ifdef HAVE_PCRE_H
 	size_t i;
 
 	for (i = 0; i < kvb->size; i++) {
@@ -130,7 +119,6 @@
 	}
 
 	if (kvb->ptr) free(kvb->ptr);
-#endif
 
 	free(kvb);
 }
@@ -201,24 +189,29 @@
 							    ((data_string *)(da->value->data[j]))->key,
 							    ((data_string *)(da->value->data[j]))->value,
 							    once)) {
-#ifdef HAVE_PCRE_H
 				log_error_write(srv, __FILE__, __LINE__, "sb",
 						"pcre-compile failed for", da->value->data[j]->key);
-#else
-				log_error_write(srv, __FILE__, __LINE__, "s",
-						"pcre support is missing, please install libpcre and the headers");
-#endif
 			}
 		}
 	}
 
 	return 0;
 }
+#else
+static int parse_config_entry(server *srv, array *ca, const char *option) {
+	static int logged_message = 0;
+	if (logged_message) return 0;
+	if (NULL != array_get_element(ca, option)) {
+		logged_message = 1;
+		log_error_write(srv, __FILE__, __LINE__, "s",
+			"pcre support is missing, please install libpcre and the headers");
+	}
+	return 0;
+}
+#endif
 
 SETDEFAULTS_FUNC(mod_rewrite_set_defaults) {
-	plugin_data *p = p_d;
 	size_t i = 0;
-
 	config_values_t cv[] = {
 		{ "url.rewrite-repeat",        NULL, T_CONFIG_LOCAL, T_CONFIG_SCOPE_CONNECTION }, /* 0 */
 		{ "url.rewrite-once",          NULL, T_CONFIG_LOCAL, T_CONFIG_SCOPE_CONNECTION }, /* 1 */
@@ -243,33 +236,37 @@
 		{ NULL,                        NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
 	};
 
+#ifdef HAVE_PCRE_H
+	plugin_data *p = p_d;
+
 	if (!p) return HANDLER_ERROR;
 
 	/* 0 */
 	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+#else
+	UNUSED(p_d);
+#endif
 
 	for (i = 0; i < srv->config_context->used; i++) {
-		plugin_config *s;
 		array *ca;
+#ifdef HAVE_PCRE_H
+		plugin_config *s;
 
 		s = calloc(1, sizeof(plugin_config));
 		s->rewrite = rewrite_rule_buffer_init();
 		s->rewrite_NF = rewrite_rule_buffer_init();
-
-		cv[0].destination = s->rewrite;
-		cv[1].destination = s->rewrite;
-		cv[2].destination = s->rewrite_NF;
-		cv[3].destination = s->rewrite_NF;
-		cv[4].destination = s->rewrite;
-		cv[5].destination = s->rewrite;
-
 		p->config_storage[i] = s;
+#endif
+
 		ca = ((data_config *)srv->config_context->data[i])->value;
 
 		if (0 != config_insert_values_global(srv, ca, cv)) {
 			return HANDLER_ERROR;
 		}
 
+#ifndef HAVE_PCRE_H
+# define parse_config_entry(srv, ca, x, option, y) parse_config_entry(srv, ca, option)
+#endif
 		parse_config_entry(srv, ca, s->rewrite, "url.rewrite-once",      1);
 		parse_config_entry(srv, ca, s->rewrite, "url.rewrite-final",     1);
 		parse_config_entry(srv, ca, s->rewrite_NF, "url.rewrite-if-not-file",   1);
@@ -280,7 +277,9 @@
 
 	return HANDLER_GO_ON;
 }
+
 #ifdef HAVE_PCRE_H
+
 #define PATCH(x) \
 	p->conf.x = s->x;
 static int mod_rewrite_patch_connection(server *srv, connection *con, plugin_data *p) {
@@ -330,7 +329,7 @@
 
 	return 0;
 }
-#endif
+
 URIHANDLER_FUNC(mod_rewrite_con_reset) {
 	plugin_data *p = p_d;
 
@@ -345,7 +344,6 @@
 }
 
 static int process_rewrite_rules(server *srv, connection *con, plugin_data *p, rewrite_rule_buffer *kvb) {
-#ifdef HAVE_PCRE_H
 	size_t i;
 	handler_ctx *hctx;
 
@@ -444,19 +442,11 @@
 		}
 #undef N
 	}
-#else
-	UNUSED(srv);
-	UNUSED(con);
-	UNUSED(p);
-	UNUSED(hctx);
-	UNUSED(kvb);
-#endif
 
 	return HANDLER_GO_ON;
 }
 
 URIHANDLER_FUNC(mod_rewrite_physical) {
-#ifdef HAVE_PCRE_H
 	plugin_data *p = p_d;
 	handler_t r;
 	stat_cache_entry *sce;
@@ -480,17 +470,11 @@
 	default:
 		return r;
 	}
-#else
-	UNUSED(srv);
-	UNUSED(con);
-	UNUSED(p_d);
-#endif
 
 	return HANDLER_GO_ON;
 }
 
 URIHANDLER_FUNC(mod_rewrite_uri_handler) {
-#ifdef HAVE_PCRE_H
 	plugin_data *p = p_d;
 
 	mod_rewrite_patch_connection(srv, con, p);
@@ -498,29 +482,27 @@
 	if (!p->conf.rewrite) return HANDLER_GO_ON;
 
 	return process_rewrite_rules(srv, con, p, p->conf.rewrite);
-#else
-	UNUSED(srv);
-	UNUSED(con);
-	UNUSED(p_d);
-#endif
 
 	return HANDLER_GO_ON;
 }
+#endif
 
 int mod_rewrite_plugin_init(plugin *p);
 int mod_rewrite_plugin_init(plugin *p) {
 	p->version     = LIGHTTPD_VERSION_ID;
 	p->name        = buffer_init_string("rewrite");
 
+#ifdef HAVE_PCRE_H
 	p->init        = mod_rewrite_init;
 	/* it has to stay _raw as we are matching on uri + querystring
 	 */
 
 	p->handle_uri_raw = mod_rewrite_uri_handler;
 	p->handle_physical = mod_rewrite_physical;
-	p->set_defaults = mod_rewrite_set_defaults;
 	p->cleanup     = mod_rewrite_free;
 	p->connection_reset = mod_rewrite_con_reset;
+#endif
+	p->set_defaults = mod_rewrite_set_defaults;
 
 	p->data        = NULL;
 
Index: src/connections.c
===================================================================
--- src/connections.c	(.../tags/lighttpd-1.4.24)
+++ src/connections.c	(.../branches/lighttpd-1.4.x)
@@ -1250,8 +1250,10 @@
 
 		if (b > 0) {
 			char buf[1024];
+#if 0
 			log_error_write(srv, __FILE__, __LINE__, "sdd",
 					"CLOSE-read()", con->fd, b);
+#endif
 
 			/* */
 			read(con->fd, buf, sizeof(buf));
@@ -1621,8 +1623,10 @@
 			}
 			if (b > 0) {
 				char buf[1024];
+#if 0
 				log_error_write(srv, __FILE__, __LINE__, "sdd",
 						"CLOSE-read()", con->fd, b);
+#endif
 
 				/* */
 				read(con->fd, buf, sizeof(buf));
Index: src/mod_rrdtool.c
===================================================================
--- src/mod_rrdtool.c	(.../tags/lighttpd-1.4.24)
+++ src/mod_rrdtool.c	(.../branches/lighttpd-1.4.x)
@@ -237,11 +237,11 @@
 					"not a regular file:", s->path_rrd);
 			return HANDLER_ERROR;
 		}
-	}
 
-	/* still create DB if it's empty file */
-	if (st.st_size > 0) {
-		return HANDLER_GO_ON;
+		/* still create DB if it's empty file */
+		if (st.st_size > 0) {
+			return HANDLER_GO_ON;
+		}
 	}
 
 	/* create a new one */
Index: src/mod_magnet.c
===================================================================
--- src/mod_magnet.c	(.../tags/lighttpd-1.4.24)
+++ src/mod_magnet.c	(.../branches/lighttpd-1.4.x)
@@ -170,6 +170,7 @@
 		return lua_gettop(L);
 	} else {
 		lua_pushvalue(L, lua_upvalueindex(1));
+		lua_insert(L, 1);
 		lua_call(L, lua_gettop(L) - 1, LUA_MULTRET);
 		return lua_gettop(L);
 	}
@@ -824,9 +825,36 @@
 	return 0;
 }
 
+static int traceback (lua_State *L) {
+	if (!lua_isstring(L, 1))  /* 'message' not a string? */
+		return 1;  /* keep it intact */
+	lua_getfield(L, LUA_GLOBALSINDEX, "debug");
+	if (!lua_istable(L, -1)) {
+		lua_pop(L, 1);
+		return 1;
+	}
+	lua_getfield(L, -1, "traceback");
+	if (!lua_isfunction(L, -1)) {
+		lua_pop(L, 2);
+		return 1;
+	}
+	lua_pushvalue(L, 1);  /* pass error message */
+	lua_pushinteger(L, 2);  /* skip this function and traceback */
+	lua_call(L, 2, 1);  /* call debug.traceback */
+	return 1;
+}
+
+static int push_traceback(lua_State *L, int narg) {
+	int base = lua_gettop(L) - narg;  /* function index */
+	lua_pushcfunction(L, traceback);
+	lua_insert(L, base);
+	return base;
+}
+
 static handler_t magnet_attract(server *srv, connection *con, plugin_data *p, buffer *name) {
 	lua_State *L;
 	int lua_return_value = -1;
+	int errfunc;
 	/* get the script-context */
 
 
@@ -955,7 +983,9 @@
 
 	lua_setfenv(L, -2); /* on the stack should be a modified env (sp -= 1) */
 
-	if (lua_pcall(L, 0, 1, 0)) {
+	errfunc = push_traceback(L, 0);
+	if (lua_pcall(L, 0, 1, errfunc)) {
+		lua_remove(L, errfunc);
 		log_error_write(srv, __FILE__, __LINE__,
 			"ss",
 			"lua_pcall():",
@@ -969,6 +999,7 @@
 
 		return HANDLER_FINISHED;
 	}
+	lua_remove(L, errfunc);
 
 	/* we should have the function-copy and the return value on the stack */
 	assert(lua_gettop(L) == 2);
Index: configure.ac
===================================================================
Index: SConstruct
===================================================================
Index: NEWS
===================================================================
--- NEWS	(.../tags/lighttpd-1.4.24)
+++ NEWS	(.../branches/lighttpd-1.4.x)
@@ -3,7 +3,14 @@
 NEWS
 ====
 
-- 1.4.24 -
+- 1.4.25 -
+  * mod_magnet: fix pairs() for normal tables and strings (fixes #1307)
+  * mod_magnet: add traceback for printing lua errors
+  * mod_rewrite: fix compile error if compiled without pcre
+  * disable warning "CLOSE-read" (fixes #2091)
+  * mod_rrdtool: fix creating file if it doesn't exist (#1788)
+
+- 1.4.24 - 2009-10-25
   * Add T_CONFIG_INT for bigger integers from the config (needed for #1966)
   * Use unsigned int (and T_CONFIG_INT) for max_request_size
   * Use unsigned int for secdownload.timeout (fixes #1966)
Index: CMakeLists.txt
===================================================================
