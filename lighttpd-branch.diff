--- lighttpd-1.4.11/NEWS	2006-03-09 19:34:33.000000000 +0200
+++ lighttpd/NEWS	2006-07-11 21:23:42.928033114 +0300
@@ -3,6 +3,23 @@
 NEWS
 ====
 
+- 1.4.12 - 2006-..-..
+
+  * added handling of Content-Range to PUT requests in mod_webdav
+  * added handling of ETag and If-Modified-Since to mod_compress if 
+    cache-dir is not set
+  * added experimental LOCK support for mod_webdav 
+  * added support for X-Sendfile as addition to X-LIGHTTPD-send-file.
+    This allows compatibility with mod_xsendfile for apache
+    (http://celebnamer.celebworld.ws/stuff/mod_xsendfile/)
+  * fixed handling of If-Modified-Since if Etag is not set
+  * fixed hanging fastcgi connections
+  * fixed stalling SSL POST requests 
+  * fixed round-robin load-balancing in mod_proxy
+  * TODO: add fail-over to mod-proxy
+  * TODO: fix CACHE_HIT/MISS in mod_cml
+  * TODO: finish LOCK/UNLOCK in mod_webdav
+
 - 1.4.11 - 2006-03-09
 
   * added ability to specify which ip address spawn-fci listens on 
--- lighttpd-1.4.11/configure.in	2006-03-04 16:32:38.000000000 +0200
+++ lighttpd/configure.in	2006-07-11 21:23:42.880030107 +0300
@@ -1,7 +1,7 @@
 #                                               -*- Autoconf -*-
 # Process this file with autoconf to produce a configure script.
 AC_PREREQ(2.57)
-AC_INIT(lighttpd, 1.4.11, jan@kneschke.de)
+AC_INIT(lighttpd, 1.4.12, jan@kneschke.de)
 AC_CONFIG_SRCDIR([src/server.c])
 
 AC_CANONICAL_TARGET
@@ -66,7 +66,7 @@
 AC_TYPE_PID_T
 AC_TYPE_SIZE_T
 
-AC_CHECK_MEMBER(struct tm.tm_gmtoff,AC_DEFINE([HAVE_STRUCT_TM_GMTOFF],[1],[gmtoff in struct tm]),,[#include <time.h>])
+AC_CHECK_MEMBER(struct tm.tm_gmtoff,[AC_DEFINE([HAVE_STRUCT_TM_GMTOFF],[1],[gmtoff in struct tm])],,[#include <time.h>])
 AC_CHECK_TYPES(struct sockaddr_storage,,,[#include <sys/socket.h>])
 AC_CHECK_TYPES(socklen_t,,,[#include <sys/types.h>
 #include <sys/socket.h>])
@@ -339,6 +339,22 @@
     AC_DEFINE([HAVE_SQLITE3], [1], [libsqlite3])
     AC_DEFINE([HAVE_SQLITE3_H], [1], [sqlite3.h])
  ])
+
+ AC_MSG_CHECKING(for locks in mod_webdav)
+ AC_ARG_WITH(webdav-locks, AC_HELP_STRING([--with-webdav-locks],[locks in mod_webdav]),
+ [WITH_WEBDAV_LOCKS=$withval],[WITH_WEBDAV_LOCKS=no])
+ AC_MSG_RESULT([$WITH_WEBDAV_LOCKS])
+
+ if test "$WITH_WEBDAV_LOCKS" != "no"; then
+   AC_CHECK_LIB(uuid, uuid_unparse, [
+         AC_CHECK_HEADERS([uuid/uuid.h],[
+                 UUID_LIB=-luuid
+                 AC_DEFINE([HAVE_UUID], [1], [libuuid])
+		 AC_DEFINE([HAVE_UUID_H], [1], [uuid/uuid.h is available])
+         ])
+ ])
+
+ fi
 fi
 
 dnl Check for gdbm
@@ -381,30 +397,11 @@
 
 AC_MSG_RESULT($WITH_LUA)
 if test "$WITH_LUA" != "no"; then
- AC_PATH_PROG(LUACONFIG, lua-config)
-
- if test x"$LUACONFIG" != x; then
-   LUA_CFLAGS=`$LUACONFIG --include`
-   LUA_LIBS=`$LUACONFIG --libs --extralibs`
-   AC_DEFINE([HAVE_LUA], [1], [liblua])
-   AC_DEFINE([HAVE_LUA_H], [1], [lua.h])
- else
-   AC_CHECK_LIB(lua, lua_open, [
-     AC_CHECK_HEADERS([lua.h],[
-       LUA_LIBS="-llua -llualib"
-       AC_DEFINE([HAVE_LUA], [1], [liblua])
-       AC_DEFINE([HAVE_LUA_H], [1], [lua.h])
-     ])
-   ])
- fi
-
- if test x"$LUA_LIBS" = x; then
    # try pkgconfig
-   PKG_CHECK_MODULES(LUA, lua, [
+ PKG_CHECK_MODULES(LUA, lua >= 5.1, [
      AC_DEFINE([HAVE_LUA], [1], [liblua])
      AC_DEFINE([HAVE_LUA_H], [1], [lua.h])
    ])
- fi
 
  AC_SUBST(LUA_CFLAGS)
  AC_SUBST(LUA_LIBS)
@@ -440,7 +437,7 @@
 esac
 
 AC_CHECK_FUNCS([dup2 getcwd inet_ntoa inet_ntop memset mmap munmap strchr \
-		  strdup strerror strstr strtol sendfile  getopt socket \
+		  strdup strerror strstr strtol sendfile  getopt socket lstat \
 		  gethostbyname poll sigtimedwait epoll_ctl getrlimit chroot \
 		  getuid select signal pathconf madvise posix_fadvise posix_madvise \
 		  writev sigaction sendfile64 send_file kqueue port_create localtime_r])
@@ -538,7 +535,7 @@
 AC_OUTPUT
 
 
-do_build="mod_cgi mod_fastcgi mod_proxy mod_evhost mod_simple_vhost mod_access mod_alias mod_setenv mod_usertrack mod_auth mod_status mod_accesslog mod_rrdtool mod_secdownload mod_expire mod_compress mod_dirlisting mod_indexfiles mod_userdir mod_webdav mod_staticfile mod_scgi" 
+do_build="mod_cgi mod_fastcgi mod_proxy mod_evhost mod_simple_vhost mod_access mod_alias mod_setenv mod_usertrack mod_auth mod_status mod_accesslog mod_rrdtool mod_secdownload mod_expire mod_compress mod_dirlisting mod_indexfiles mod_userdir mod_webdav mod_staticfile mod_scgi mod_flv_streaming" 
 
 plugins="mod_rewrite mod_redirect mod_ssi mod_trigger_b4_dl"
 features="regex-conditionals"
@@ -642,6 +639,14 @@
 	disable_feature="$disable_feature $features"
 fi
 
+features="webdav-locks"
+if test "x$UUID_LIB" \!= x; then
+	enable_feature="$enable_feature $features"
+else
+	disable_feature="$disable_feature $features"
+fi
+
+
 ## output
 
 $ECHO
--- lighttpd-1.4.11/doc/authentication.txt	2006-01-12 20:34:26.000000000 +0200
+++ lighttpd/doc/authentication.txt	2006-07-11 21:23:42.708019334 +0300
@@ -7,8 +7,8 @@
 ----------------
 
 :Author: Jan Kneschke
-:Date: $Date$
-:Revision: $Revision$
+:Date: $Date$
+:Revision: $Revision$
 
 :abstract:
   The auth module provides ...
--- lighttpd-1.4.11/doc/compress.txt	2005-08-11 01:26:16.000000000 +0300
+++ lighttpd/doc/compress.txt	2006-07-11 21:23:42.680017580 +0300
@@ -22,12 +22,38 @@
 ===========
 
 Output compression reduces the network load and can improve the overall
-throughput of the webserver. 
+throughput of the webserver. All major http-clients support compression by
+announcing it in the Accept-Encoding header. This is used to negotiate the 
+most suitable compression method. We support deflate, gzip and bzip2.
 
-Only static content is supported up to now.
+deflate (RFC1950, RFC1951) and gzip (RFC1952) depend on zlib while bzip2 
+depends on libbzip2. bzip2 is only supported by lynx and some other console
+text-browsers.
 
-The server negotiates automaticly which compression method is used.
-Supported are gzip, deflate, bzip.
+Currently we limit to compression support to static files.
+
+Caching
+-------
+
+mod_compress can stored compressed files on disk to optimized the compression
+on a second request away. As soon as compress.cache-dir is set the files are
+compressed. 
+
+The names of the cache files are made of the filename, the compression method
+and the etag associated to the file.
+
+Cleaning the cache is left to the user. A cron job deleting files older than
+10 days should do fine.
+
+Limitations
+-----------
+
+The module limits the compression of files to files larger than 128 Byte and
+smaller than 128 MByte.
+
+The lower limit is set as small files tend to become larger by compressing due
+to the compression headers, the upper limit is set to work sensable with
+memory and cpu-time.
 
 Options
 =======
@@ -47,14 +73,27 @@
   Default: not set, compress the file for every request
 
 compress.filetype
-  mimetypes where might get compressed
+  mimetypes which might get compressed
   
   e.g.: ::
   
     compress.filetype           = ("text/plain", "text/html")
 
+  Keep in mind that compressed JavaScript and CSS files are broken in some
+  browsers.
+
   Default: not set
 
+compress.max-file-size 
+  maximum size of the original file to be compressed kBytes.
+
+  This is meant to protect the server against DoSing as compressing large
+  (let's say 1Gbyte) takes a lot of time and would delay the whole operation
+  of the server.
+
+  There is a hard upper limit of 128Mbyte.
+
+  Default: unlimited (== hard-limit of 128MByte)
 
 Compressing Dynamic Content
 ===========================
--- lighttpd-1.4.11/doc/configuration.txt	2006-03-09 02:10:40.000000000 +0200
+++ lighttpd/doc/configuration.txt	2006-07-11 21:23:42.696018582 +0300
@@ -7,8 +7,8 @@
 ------------
 
 :Author: Jan Kneschke
-:Date: $Date$
-:Revision: $Revision$
+:Date: $Date$
+:Revision: $Revision$
 
 :abstract:
   the layout of the configuration file
@@ -511,3 +511,10 @@
 
 debug.log-request-handling
   default: disabled 
+
+debug.log-condition-handling
+  default: disabled 
+
+debug.log-condition-cache-handling
+  for developers only
+  default: disabled 
--- lighttpd-1.4.11/doc/fastcgi.txt	2006-02-16 17:03:52.000000000 +0200
+++ lighttpd/doc/fastcgi.txt	2006-07-11 21:23:42.712019584 +0300
@@ -144,8 +144,8 @@
                 PHP can extract PATH_INFO from it (default: disabled)
   :"disable-time": time to wait before a disabled backend is checked
                 again
-  :"allow-x-send-file": controls if X-LIGHTTPD-send-file headers
-                are allowed 
+  :"allow-x-send-file": controls if X-LIGHTTPD-send-file and X-Sendfile
+                headers are allowed 
 
   If bin-path is set:
 
--- lighttpd-1.4.11/doc/lighttpd.conf	2006-03-04 14:41:12.000000000 +0200
+++ lighttpd/doc/lighttpd.conf	2006-07-11 21:23:42.736021088 +0300
@@ -176,6 +176,7 @@
 #debug.log-response-header  = "enable"
 #debug.log-request-handling = "enable"
 #debug.log-file-not-found   = "enable"
+#debug.log-condition-handling = "enable"
 
 ### only root can use these options
 #
--- lighttpd-1.4.11/doc/performance.txt	2006-02-02 13:01:08.000000000 +0200
+++ lighttpd/doc/performance.txt	2006-07-11 21:23:42.632014574 +0300
@@ -183,6 +183,8 @@
 
   server.stat-cache-engine = "fam"   # either fam, simple or disabled
 
+See http://oss.sgi.com/projects/fam/faq.html for information about FAM.
+See http://www.gnome.org/~veillard/gamin/overview.html for information about gamin.
 
 Platform-Specific Notes
 =======================
--- lighttpd-1.4.11/doc/secdownload.txt	2005-12-20 15:58:58.000000000 +0200
+++ lighttpd/doc/secdownload.txt	2006-07-11 21:23:42.640015075 +0300
@@ -118,7 +118,7 @@
   $secret = "verysecret";
   $uri_prefix = "/dl/";
   
-  # filename
+  # filename, make sure it's started with a "/" or you'll get 404 in the browser
   $f = "/secret-file.txt";
   
   # current timestamp
--- lighttpd-1.4.11/src/Makefile.am	2006-03-07 14:20:20.000000000 +0200
+++ lighttpd/src/Makefile.am	2006-07-11 21:23:40.099855979 +0300
@@ -16,14 +16,19 @@
 else
 configparser.y: lemon
 mod_ssi_exprparser.y: lemon
+http_resp_parser.y: lemon
 
 configparser.c configparser.h: configparser.y
 	rm -f configparser.h
-	$(LEMON) -q $(srcdir)/configparser.y $(srcdir)/lempar.c
+	$(LEMON) -q $(srcdir)/$< $(srcdir)/lempar.c
+
+http_resp_parser.c http_resp_parser.h: http_resp_parser.y
+	rm -f http_resp_parser.h
+	$(LEMON) -q $(srcdir)/$< $(srcdir)/lempar.c
 
 mod_ssi_exprparser.c mod_ssi_exprparser.h: mod_ssi_exprparser.y 
 	rm -f mod_ssi_exprparser.h
-	$(LEMON) -q $(srcdir)/mod_ssi_exprparser.y $(srcdir)/lempar.c
+	$(LEMON) -q $(srcdir)/$< $(srcdir)/lempar.c
 endif
 
 configfile.c: configparser.h
@@ -46,7 +51,7 @@
       network_write.c network_linux_sendfile.c \
       network_freebsd_sendfile.c network_writev.c \
       network_solaris_sendfilev.c network_openssl.c \
-      splaytree.c 
+      splaytree.c http_resp.c http_resp_parser.c 
       
 src = server.c response.c connections.c network.c \
       configfile.c configparser.c request.c proc_open.c
@@ -84,7 +89,7 @@
 mod_webdav_la_SOURCES = mod_webdav.c
 mod_webdav_la_CFLAGS = $(AM_CFLAGS) $(XML_CFLAGS) $(SQLITE_CFLAGS)
 mod_webdav_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
-mod_webdav_la_LIBADD = $(common_libadd) $(XML_LIBS) $(SQLITE_LIBS)
+mod_webdav_la_LIBADD = $(common_libadd) $(XML_LIBS) $(SQLITE_LIBS) $(UUID_LIB)
 
 lib_LTLIBRARIES += mod_cml.la
 mod_cml_la_SOURCES = mod_cml.c mod_cml_lua.c mod_cml_funcs.c
@@ -103,6 +108,11 @@
 mod_mysql_vhost_la_LIBADD = $(MYSQL_LIBS) $(common_libadd)
 mod_mysql_vhost_la_CPPFLAGS = $(MYSQL_INCLUDE)
 
+lib_LTLIBRARIES += mod_sql_vhost_core.la
+mod_sql_vhost_core_la_SOURCES = mod_sql_vhost_core.c
+mod_sql_vhost_core_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_sql_vhost_core_la_LIBADD = $(common_libadd)
+
 lib_LTLIBRARIES += mod_cgi.la
 mod_cgi_la_SOURCES = mod_cgi.c 
 mod_cgi_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
@@ -240,7 +250,7 @@
       mod_ssi.h mod_ssi_expr.h inet_ntop_cache.h \
       configparser.h mod_ssi_exprparser.h \
       sys-mmap.h sys-socket.h mod_cml.h mod_cml_funcs.h \
-      splaytree.h proc_open.h
+      splaytree.h proc_open.h http_resp.h mod_sql_vhost_core.h
 
 DEFS= @DEFS@ -DLIBRARY_DIR="\"$(libdir)\""
 
--- lighttpd-1.4.11/src/array.c	2005-11-18 13:58:32.000000000 +0200
+++ lighttpd/src/array.c	2006-07-11 21:23:39.943846207 +0300
@@ -165,7 +165,7 @@
 	int pos = 0;
 	size_t j;
 	
-	/* generate unique index if neccesary */
+	/* generate unique index if necessary */
 	if (str->key->used == 0 || str->is_index_key) {
 		buffer_copy_long(str->key, a->unique_ndx++);
 		str->is_index_key = 1;
@@ -215,7 +215,7 @@
 		pos++;
 	} 
 	
-	/* move everything on step to the right */
+	/* move everything one step to the right */
 	if (pos != ndx) {
 		memmove(a->sorted + (pos + 1), a->sorted + (pos), (ndx - pos) * sizeof(*a->sorted));
 	}
--- lighttpd-1.4.11/src/array.h	2005-09-23 21:24:18.000000000 +0300
+++ lighttpd/src/array.h	2006-07-11 21:23:39.963847460 +0300
@@ -16,7 +16,7 @@
 #define DATA_UNSET \
 	data_type_t type; \
 	buffer *key; \
-	int is_index_key; /* 1 if key is a array index (autogenerated keys) */ \
+	int is_index_key; /* 1 if key is an array index (auto-generated keys) */ \
 	struct data_unset *(*copy)(const struct data_unset *src); \
 	void (* free)(struct data_unset *p); \
 	void (* reset)(struct data_unset *p); \
--- lighttpd-1.4.11/src/base.h	2006-01-11 16:51:04.000000000 +0200
+++ lighttpd/src/base.h	2006-07-11 21:23:39.947846458 +0300
@@ -2,7 +2,6 @@
 #define _BASE_H_
 
 #include <sys/types.h>
-#include <sys/time.h>
 #include <sys/stat.h>
 
 #ifdef HAVE_CONFIG_H
@@ -26,7 +25,6 @@
 #include "sys-socket.h"
 #include "splaytree.h"
 
-
 #if defined HAVE_LIBSSL && defined HAVE_OPENSSL_SSL_H
 # define USE_OPENSSL
 # include <openssl/ssl.h> 
@@ -40,10 +38,6 @@
 # define O_BINARY 0
 #endif
 
-#ifndef O_LARGEFILE
-# define O_LARGEFILE 0
-#endif
-
 #ifndef SIZE_MAX
 # ifdef SIZE_T_MAX
 #  define SIZE_MAX SIZE_T_MAX
@@ -70,7 +64,8 @@
 
 /* solaris and NetBSD 1.3.x again */
 #if (!defined(HAVE_STDINT_H)) && (!defined(HAVE_INTTYPES_H)) && (!defined(uint32_t))
-# define uint32_t u_int32_t
+/* # define uint32_t u_int32_t */
+typedef unsigned __int32 uint32_t;
 #endif
 
 
@@ -171,7 +166,7 @@
 
 typedef struct {
 	off_t   content_length;
-	int     keep_alive;               /* used by  the subrequests in proxy, cgi and fcgi to say the subrequest was keep-alive or not */
+	int     keep_alive;               /* used by the subrequests in proxy, cgi and fcgi to say whether the subrequest was keep-alive or not */
 	
 	array  *headers;
 	
@@ -215,7 +210,7 @@
 } stat_cache_entry;
 
 typedef struct {
-	splay_tree *files; /* the nodes of the tree are stat_cache_entry's */
+	splay_tree *files; /* the nodes of the tree are stat_cache_entries */
 	
 	buffer *dir_name; /* for building the dirname from the filename */
 #ifdef HAVE_FAM_H
@@ -252,6 +247,7 @@
 	unsigned short log_request_handling;
 	unsigned short log_response_header;
 	unsigned short log_condition_handling;
+	unsigned short log_condition_cache_handling;
 	
 	
 	/* server wide */
@@ -272,13 +268,13 @@
 	/* server-wide traffic-shaper
 	 * 
 	 * each context has the counter which is inited once
-	 * a second by the global_kbytes_per_second config-var
+	 * per second by the global_kbytes_per_second config-var
 	 *
 	 * as soon as global_kbytes_per_second gets below 0
 	 * the connected conns are "offline" a little bit
 	 *
 	 * the problem:
-	 * we somehow have to loose our "we are writable" signal 
+	 * we somehow have to lose our "we are writable" signal
 	 * on the way.
 	 * 
 	 */
@@ -341,7 +337,7 @@
 	int is_readable;
 	int is_writable;
 	
-	int     keep_alive;           /* only request.c can enable it, all other just disable */
+	int     keep_alive;           /* only request.c can enable it, all others just disable */
 	
 	int file_started;
 	int file_finished;
@@ -439,6 +435,15 @@
 	size_t size;
 } buffer_plugin;
 
+typedef enum {
+    NETWORK_STATUS_UNSET,
+    NETWORK_STATUS_SUCCESS,
+    NETWORK_STATUS_FATAL_ERROR,
+    NETWORK_STATUS_CONNECTION_CLOSE,
+    NETWORK_STATUS_WAIT_FOR_EVENT,
+    NETWORK_STATUS_INTERRUPTED
+} network_status_t;
+
 typedef struct {
 	unsigned short port;
 	buffer *bindhost;
@@ -591,15 +596,17 @@
 	
 	fdevent_handler_t event_handler;
 
-	int (* network_backend_write)(struct server *srv, connection *con, int fd, chunkqueue *cq);
-	int (* network_backend_read)(struct server *srv, connection *con, int fd, chunkqueue *cq);
+	network_status_t (* network_backend_write)(struct server *srv, connection *con, int fd, chunkqueue *cq);
+	network_status_t (* network_backend_read)(struct server *srv, connection *con, int fd, chunkqueue *cq);
 #ifdef USE_OPENSSL
-	int (* network_ssl_backend_write)(struct server *srv, connection *con, SSL *ssl, chunkqueue *cq);
-	int (* network_ssl_backend_read)(struct server *srv, connection *con, SSL *ssl, chunkqueue *cq);
+	network_status_t (* network_ssl_backend_write)(struct server *srv, connection *con, SSL *ssl, chunkqueue *cq);
+	network_status_t (* network_ssl_backend_read)(struct server *srv, connection *con, SSL *ssl, chunkqueue *cq);
 #endif
 
+#ifdef HAVE_PWD_H
 	uid_t uid;
 	gid_t gid;
+#endif
 } server;
 
 
--- lighttpd-1.4.11/src/buffer.c	2006-01-13 00:00:45.000000000 +0200
+++ lighttpd/src/buffer.c	2006-07-11 21:23:40.087855227 +0300
@@ -63,7 +63,7 @@
 
 /**
  * 
- * allocate (if neccessary) enough space for 'size' bytes and 
+ * allocate (if necessary) enough space for 'size' bytes and
  * set the 'used' counter to 0
  * 
  */
@@ -79,7 +79,7 @@
 		
 		b->size = size;
 		
-		/* always allocate a multiply of BUFFER_PIECE_SIZE */
+		/* always allocate a multiple of BUFFER_PIECE_SIZE */
 		b->size += BUFFER_PIECE_SIZE - (b->size % BUFFER_PIECE_SIZE);
 		
 		b->ptr = malloc(b->size);
@@ -91,7 +91,7 @@
 
 /**
  * 
- * increase the internal buffer (if neccessary) to append another 'size' byte
+ * increase the internal buffer (if necessary) to append another 'size' byte
  * ->used isn't changed
  * 
  */
@@ -102,7 +102,7 @@
 	if (0 == b->size) {
 		b->size = size;
 		
-		/* always allocate a multiply of BUFFER_PIECE_SIZE */
+		/* always allocate a multiple of BUFFER_PIECE_SIZE */
 		b->size += BUFFER_PIECE_SIZE - (b->size % BUFFER_PIECE_SIZE);
 		
 		b->ptr = malloc(b->size);
@@ -111,7 +111,7 @@
 	} else if (b->used + size > b->size) {
 		b->size += size;
 		
-		/* always allocate a multiply of BUFFER_PIECE_SIZE */
+		/* always allocate a multiple of BUFFER_PIECE_SIZE */
 		b->size += BUFFER_PIECE_SIZE - (b->size % BUFFER_PIECE_SIZE);
 		
 		b->ptr = realloc(b->ptr, b->size);
@@ -203,7 +203,7 @@
  * append a string to the end of the buffer
  * 
  * the resulting buffer is terminated with a '\0' 
- * s is treated as a un-terminated string (a \0 is handled a normal character)
+ * s is treated as an un-terminated string (a \0 is handled as a normal character)
  * 
  * @param b a buffer
  * @param s the string
@@ -402,6 +402,75 @@
 
 
 /**
+ * init the ptr buffer
+ *
+ */
+buffer_ptr *buffer_ptr_init(buffer_ptr_free_t freer)
+{
+	buffer_ptr *l = calloc(1, sizeof(buffer_ptr));
+	l->free = freer;
+
+	return l;
+}
+
+/**
+ * free the buffer_array
+ *
+ */
+void buffer_ptr_free(buffer_ptr *l)
+{
+	if (NULL != l) {
+		buffer_ptr_clear(l);
+		free(l);
+	}
+}
+
+void buffer_ptr_clear(buffer_ptr *l)
+{
+	assert(NULL != l);
+
+	if (l->free && l->used) {
+		size_t i;
+		for (i = 0; i < l->used; i ++) {
+			l->free(l->ptr[i]);
+		}
+	}
+
+	if (l->ptr) {
+		free(l->ptr);
+		l->ptr = NULL;
+	}
+	l->used = 0;
+	l->size = 0;
+}
+
+void buffer_ptr_append(buffer_ptr* l, void *item)
+{
+	assert(NULL != l);
+	if (l->ptr == NULL) {
+		l->size = 16;
+		l->ptr = (void **)malloc(sizeof(void *) * l->size);
+	}
+	else if (l->used == l->size) {
+		l->size += 16;
+		l->ptr = realloc(l->ptr, sizeof(void *) * l->size);
+	}
+	l->ptr[l->used++] = item;
+}
+
+void *buffer_ptr_pop(buffer_ptr* l)
+{
+	assert(NULL != l && l->used > 0);
+	return l->ptr[--l->used];
+}
+
+void *buffer_ptr_top(buffer_ptr* l)
+{
+	assert(NULL != l && l->used > 0);
+	return l->ptr[l->used-1];
+}
+
+/**
  * init the buffer 
  * 
  */
@@ -507,7 +576,7 @@
 }
 
 /**
- * check if two buffer contain the same data
+ * check if two buffers contain the same data
  * 
  * HISTORY: this function was pretty much optimized, but didn't handled
  * alignment properly.
@@ -531,7 +600,7 @@
 
 /* simple-assumption:
  * 
- * most parts are equal and doing a case conversion needs time
+ * most parts are equal and doing a case conversion takes time
  * 
  */
 int buffer_caseless_compare(const char *a, size_t a_len, const char *b, size_t b_len) {
@@ -592,7 +661,7 @@
 	if (b1->used == 0 || b2->used == 0) return 0;
 	
 	/* buffers too small -> not equal */
-	if (b1->used - 1 < len || b1->used - 1 < len) return 0;
+	if (b1->used - 1 < len || b2->used - 1 < len) return 0;
 	
 	if (0 == strncmp(b1->ptr + b1->used - 1 - len, 
 			 b2->ptr + b2->used - 1 - len, len)) {
@@ -760,12 +829,12 @@
 		map = encoded_chars_hex;
 		break;
 	case ENCODING_UNSET:
-		break;
+		return buffer_append_string_len(b, s, s_len);
 	}
 
 	assert(map != NULL);
 	
-	/* count to-be-encoded-characters */
+	/* count to-be-encoded characters */
 	for (ds = (unsigned char *)s, d_len = 0, ndx = 0; ndx < s_len; ds++, ndx++) {
 		if (map[*ds]) {
 			switch(encoding) {
@@ -829,7 +898,7 @@
 }
 
 
-/* decodes url-special-chars inplace.
+/* decodes url-special chars in-place.
  * replaces non-printable characters with '_'
  */
 
@@ -855,7 +924,7 @@
 				if (low != 0xFF) {
 					high = (high << 4) | low;
 					
-					/* map control-characters out */	
+					/* map out control characters */
 					if (high < 32 || high == 127) high = '_';
 					
 					*dst = high;
@@ -891,7 +960,7 @@
  * /abc/./xyz       gets  /abc/xyz
  * /abc//xyz        gets  /abc/xyz
  *
- * NOTE: src and dest can point to the same buffer, in which case,
+ * NOTE: src and dest can point to the same buffer, in which case
  *       the operation is performed in-place.
  */
 
@@ -993,6 +1062,31 @@
 	return light_isdigit(c) || light_isalpha(c);
 }
 
+#undef BUFFER_CTYPE_FUNC
+#define BUFFER_CTYPE_FUNC(type) \
+	int buffer_is##type(buffer *b) { \
+		size_t i, len; \
+		if (b->used < 2) return 0; \
+		/* strlen */ \
+		len = b->used - 1; \
+		/* c-string only */ \
+		if (b->ptr[len] != '\0') { \
+			return 0; \
+		} \
+		/* check on the whole string */ \
+		for (i = 0; i < len; i ++) { \
+			if (!light_is##type(b->ptr[i])) { \
+				return 0; \
+			} \
+		} \
+		return 1; \
+	}
+
+BUFFER_CTYPE_FUNC(digit)
+BUFFER_CTYPE_FUNC(xdigit)
+BUFFER_CTYPE_FUNC(alpha)
+BUFFER_CTYPE_FUNC(alnum)
+
 int buffer_to_lower(buffer *b) {
 	char *c;
 	
--- lighttpd-1.4.11/src/buffer.h	2006-01-13 00:00:45.000000000 +0200
+++ lighttpd/src/buffer.h	2006-07-11 21:23:40.095855728 +0300
@@ -17,6 +17,16 @@
 	size_t size;
 } buffer;
 
+
+typedef void (*buffer_ptr_free_t)(void *p);
+
+typedef struct {
+	void **ptr;
+	size_t size;
+	size_t used;
+	buffer_ptr_free_t free;
+} buffer_ptr;
+
 typedef struct {
 	buffer **ptr;
 	
@@ -27,12 +37,19 @@
 typedef struct {
 	char *ptr;
 	
-	size_t offset; /* input-pointer */
+	size_t offset; /* input pointer */
 	
-	size_t used;   /* output-pointer */
+	size_t used;   /* output pointer */
 	size_t size;
 } read_buffer;
 
+buffer_ptr *buffer_ptr_init(buffer_ptr_free_t freer);
+void buffer_ptr_free(buffer_ptr *b);
+void buffer_ptr_clear(buffer_ptr *b);
+void buffer_ptr_append(buffer_ptr *b, void *item);
+void *buffer_ptr_pop(buffer_ptr *b);
+void *buffer_ptr_top(buffer_ptr *b);
+
 buffer_array* buffer_array_init(void);
 void buffer_array_free(buffer_array *b);
 void buffer_array_reset(buffer_array *b);
@@ -85,9 +102,9 @@
 
 typedef enum {
 	ENCODING_UNSET,
-	ENCODING_REL_URI, /* for coding a rel-uri (/with space/and%percent) nicely as part of a href */
-	ENCODING_REL_URI_PART, /* same as ENC_REL_URL plus coding / too as %2F */
-	ENCODING_HTML,    /* & becomes &amp; and so on */
+	ENCODING_REL_URI, /* for coding a rel-uri (/with space/and%percent) nicely as part of an href */
+	ENCODING_REL_URI_PART, /* same as ENC_REL_URL plus encoding "/" as "%2F" */
+	ENCODING_HTML,    /* "&" becomes "&amp;" and so on */
 	ENCODING_MINIMAL_XML, /* minimal encoding for xml */
 	ENCODING_HEX      /* encode string as hex */
 } buffer_encoding_t;
@@ -111,19 +128,21 @@
 int light_isalpha(int c);
 int light_isalnum(int c);
 
+#define BUFFER_CTYPE_FUNC(type) int buffer_is##type(buffer *b);
+BUFFER_CTYPE_FUNC(digit)
+BUFFER_CTYPE_FUNC(xdigit)
+BUFFER_CTYPE_FUNC(alpha)
+BUFFER_CTYPE_FUNC(alnum)
+
 #define BUFFER_APPEND_STRING_CONST(x, y) \
 	buffer_append_string_len(x, y, sizeof(y) - 1)
 
 #define BUFFER_COPY_STRING_CONST(x, y) \
 	buffer_copy_string_len(x, y, sizeof(y) - 1)
 
-#define BUFFER_APPEND_SLASH(x) \
-	if (x->used > 1 && x->ptr[x->used - 2] != '/') { BUFFER_APPEND_STRING_CONST(x, "/"); }
-
 #define CONST_STR_LEN(x) x, x ? sizeof(x) - 1 : 0
 #define CONST_BUF_LEN(x) x->ptr, x->used ? x->used - 1 : 0
 
-
 #define SEGFAULT() do { fprintf(stderr, "%s.%d: aborted\n", __FILE__, __LINE__); abort(); } while(0)
 #define UNUSED(x) ( (void)(x) )
 
--- lighttpd-1.4.11/src/chunk.c	2005-11-18 15:18:19.000000000 +0200
+++ lighttpd/src/chunk.c	2006-07-11 21:23:39.995849464 +0300
@@ -6,11 +6,9 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/mman.h>
 
 #include <stdlib.h>
 #include <fcntl.h>
-#include <unistd.h>
 
 #include <stdio.h>
 #include <errno.h>
@@ -18,6 +16,9 @@
 
 #include "chunk.h"
 
+#include "sys-mmap.h"
+#include "sys-files.h"
+
 chunkqueue *chunkqueue_init(void) {
 	chunkqueue *cq;
 	
@@ -99,7 +100,7 @@
 static chunk *chunkqueue_get_unused_chunk(chunkqueue *cq) {
 	chunk *c;
 	
-	/* check if we have a unused chunk */
+	/* check if we have an unused chunk */
 	if (!cq->unused) {
 		c = chunk_init();
 	} else {
@@ -278,7 +279,7 @@
 			data_string *ds = (data_string *)cq->tempdirs->data[i];
 
 			buffer_copy_string_buffer(template, ds->value);
-			BUFFER_APPEND_SLASH(template);
+			PATHNAME_APPEND_SLASH(template);
 			BUFFER_APPEND_STRING_CONST(template, "lighttpd-upload-XXXXXX");
 
 			if (-1 != (c->file.fd = mkstemp(template->ptr))) {
--- lighttpd-1.4.11/src/chunk.h	2005-11-01 09:32:21.000000000 +0200
+++ lighttpd/src/chunk.h	2006-07-11 21:23:40.015850717 +0300
@@ -19,10 +19,10 @@
 		struct { 
 			char   *start; /* the start pointer of the mmap'ed area */
 			size_t length; /* size of the mmap'ed area */
-			off_t  offset; /* start is <n> octet away from the start of the file */
+			off_t  offset; /* start is <n> octets away from the start of the file */
 		} mmap;
 
-		int is_temp; /* file is temporary and will be deleted if on cleanup */
+		int is_temp; /* file is temporary and will be deleted on cleanup */
 	} file;
 	
 	off_t  offset; /* octets sent from this chunk 
--- lighttpd-1.4.11/src/configfile-glue.c	2006-03-03 20:14:56.000000000 +0200
+++ lighttpd/src/configfile-glue.c	2006-07-11 21:23:39.879842199 +0300
@@ -1,4 +1,5 @@
 #include <string.h>
+#include <ctype.h>
 
 #include "base.h"
 #include "buffer.h"
@@ -71,6 +72,10 @@
 				data_string *ds = (data_string *)du;
 				
 				buffer_copy_string_buffer(cv[i].destination, ds->value);
+			} else if (du->type == TYPE_INTEGER) {
+				data_integer *di = (data_integer *)du;
+
+				buffer_copy_long(cv[i].destination, di->value);
 			} else {
 				log_error_write(srv, __FILE__, __LINE__, "ssss", "unexpected type for key: ", cv[i].key, "(string)", "\"...\"");
 				
@@ -88,6 +93,11 @@
 			case TYPE_STRING: {
 				data_string *ds = (data_string *)du;
 					
+				if (buffer_isdigit(ds->value)) {
+					*((unsigned short *)(cv[i].destination)) = strtol(ds->value->ptr, NULL, 10);
+					break;
+				}
+
 				log_error_write(srv, __FILE__, __LINE__, "ssb", "get a string but expected a short:", cv[i].key, ds->value);
 				
 				return -1;
@@ -230,7 +240,7 @@
 				break;
 			}
 		} else {
-			l = NULL;
+			l = srv->empty_string;
 		}
 		break;
 	}
@@ -254,6 +264,13 @@
 			char *err;
 			struct in_addr val_inp;
 			
+			if (con->conf.log_condition_handling) {
+				l = srv->empty_string;
+
+				log_error_write(srv, __FILE__, __LINE__,  "bsbsb", dc->comp_key,
+						"(", l, ") compare to", dc->string);
+			}
+
 			if (*(nm_slash+1) == '\0') {
 				log_error_write(srv, __FILE__, __LINE__, "sb", "ERROR: no number after / ", dc->string);
 					
@@ -270,7 +287,7 @@
 			
 			/* take IP convert to the native */
 			buffer_copy_string_len(srv->cond_check_buf, dc->string->ptr, nm_slash - dc->string->ptr);
-#ifdef __WIN32			
+#ifdef _WIN32
 			if (INADDR_NONE == (val_inp.s_addr = inet_addr(srv->cond_check_buf->ptr))) {
 				log_error_write(srv, __FILE__, __LINE__, "sb", "ERROR: ip addr is invalid:", srv->cond_check_buf);
 				
@@ -395,6 +412,9 @@
 	cond_cache_t *caches = con->cond_cache;
 
 	if (COND_RESULT_UNSET == caches[dc->context_ndx].result) {
+		if (con->conf.log_condition_handling) {
+			log_error_write(srv, __FILE__, __LINE__,  "sds",  "=== start of", dc->context_ndx, "condition block ===");
+		}
 		if (COND_RESULT_TRUE == (caches[dc->context_ndx].result = config_check_cond_nocache(srv, con, dc))) {
 			if (dc->next) {
 				data_config *c;
@@ -409,11 +429,11 @@
 		}
 		if (con->conf.log_condition_handling) {
 			log_error_write(srv, __FILE__, __LINE__, "dss", dc->context_ndx,
-					"(uncached) result:",
+					"result:",
 					caches[dc->context_ndx].result == COND_RESULT_TRUE ? "true" : "false");
 		}
 	} else {
-		if (con->conf.log_condition_handling) {
+		if (con->conf.log_condition_cache_handling) {
 			log_error_write(srv, __FILE__, __LINE__, "dss", dc->context_ndx,
 					"(cached) result:",
 					caches[dc->context_ndx].result == COND_RESULT_TRUE ? "true" : "false");
@@ -423,9 +443,6 @@
 }
 
 int config_check_cond(server *srv, connection *con, data_config *dc) {
-	if (con->conf.log_condition_handling) {
-		log_error_write(srv, __FILE__, __LINE__,  "s",  "=== start of condition block ===");
-	}
 	return (config_check_cond_cached(srv, con, dc) == COND_RESULT_TRUE);
 }
 
@@ -443,3 +460,85 @@
 	return 1;
 }
 
+/* return <0 on error
+ * return 0-x if matched (and replaced)
+ */
+int config_exec_pcre_keyvalue_buffer(connection *con, pcre_keyvalue_buffer *kvb, data_config *context, buffer *match_buf, buffer *result)
+{
+#ifdef HAVE_PCRE_H
+	pcre *match;
+	pcre_extra *extra;
+	const char *pattern;
+	size_t pattern_len;
+	int n;
+	size_t i;
+	pcre_keyvalue *kv;
+# define N 10
+	int ovec[N * 3];
+
+	for (i = 0; i < kvb->used; i++) {
+		kv = kvb->kv[i];
+
+		match       = kv->key;
+		extra       = kv->key_extra;
+		pattern     = kv->value->ptr;
+		pattern_len = kv->value->used - 1;
+
+		if ((n = pcre_exec(match, extra, match_buf->ptr, match_buf->used - 1, 0, 0, ovec, 3 * N)) < 0) {
+			if (n != PCRE_ERROR_NOMATCH) {
+				return n;
+			}
+		} else {
+			const char **list;
+			size_t start, end;
+			size_t k;
+
+			/* it matched */
+			pcre_get_substring_list(match_buf->ptr, ovec, n, &list);
+
+			/* search for $[0-9] */
+
+			buffer_reset(result);
+
+			start = 0; end = pattern_len;
+			for (k = 0; k < pattern_len; k++) {
+				if ((pattern[k] == '$' || pattern[k] == '%') &&
+				    isdigit((unsigned char)pattern[k + 1])) {
+					/* got one */
+
+					size_t num = pattern[k + 1] - '0';
+
+					end = k;
+
+					buffer_append_string_len(result, pattern + start, end - start);
+
+					if (pattern[k] == '$') {
+						/* n is always > 0 */
+						if (num < (size_t)n) {
+							buffer_append_string(result, list[num]);
+						}
+					} else {
+						config_append_cond_match_buffer(con, context, result, num);
+					}
+
+					k++;
+					start = k + 1;
+				}
+			}
+
+			buffer_append_string_len(result, pattern + start, pattern_len - start);
+
+			pcre_free(list);
+
+			return i;
+		}
+	}
+
+	return PCRE_ERROR_NOMATCH;
+#undef N
+#else
+	UNUSED(kvb);
+	return -2;
+#endif
+}
+
--- lighttpd-1.4.11/src/configfile.c	2006-02-15 14:26:42.000000000 +0200
+++ lighttpd/src/configfile.c	2006-07-11 21:23:39.987848963 +0300
@@ -2,7 +2,6 @@
 
 #include <stdlib.h>
 #include <fcntl.h>
-#include <unistd.h>
 #include <errno.h>
 #include <string.h>
 #include <stdio.h>
@@ -13,14 +12,17 @@
 #include "log.h"
 #include "stream.h"
 #include "plugin.h"
-#ifdef USE_LICENSE
-#include "license.h"
-#endif
-
 #include "configparser.h"
 #include "configfile.h"
 #include "proc_open.h"
 
+#include "sys-files.h"
+#include "sys-process.h"
+
+#ifndef PATH_MAX
+/* win32 */
+#define PATH_MAX 64
+#endif
 
 static int config_insert(server *srv) {
 	size_t i;
@@ -80,6 +82,7 @@
 		{ "server.network-backend",      NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },  /* 43 */
 		{ "server.upload-dirs",          NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION },   /* 44 */
 		{ "server.core-files",           NULL, T_CONFIG_BOOLEAN, T_CONFIG_SCOPE_CONNECTION }, /* 45 */
+		{ "debug.log-condition-cache-handling", NULL, T_CONFIG_BOOLEAN, T_CONFIG_SCOPE_SERVER },    /* 46 */
 		
 		{ "server.host",                 "use server.bind instead", T_CONFIG_DEPRECATED, T_CONFIG_SCOPE_UNSET },
 		{ "server.docroot",              "use server.document-root instead", T_CONFIG_DEPRECATED, T_CONFIG_SCOPE_UNSET },
@@ -165,6 +168,7 @@
 		cv[14].destination = s->document_root;
 		cv[15].destination = &(s->force_lowercase_filenames);
 		cv[16].destination = &(s->log_condition_handling);
+		cv[46].destination = &(s->log_condition_cache_handling);
 		cv[17].destination = &(s->max_keep_alive_requests);
 		cv[18].destination = s->server_name;
 		cv[19].destination = &(s->max_keep_alive_idle);
@@ -216,8 +220,8 @@
 								 
 }
 
-
-#define PATCH(x) con->conf.x = s->x
+#define PATCH(x) \
+	con->conf.x = s->x
 int config_setup_connection(server *srv, connection *con) {
 	specific_config *s = srv->config_storage[0];
 	
@@ -244,6 +248,7 @@
 	PATCH(log_response_header);
 	PATCH(log_request_handling);
 	PATCH(log_condition_handling);
+	PATCH(log_condition_cache_handling);
 	PATCH(log_file_not_found);
 	
 	PATCH(range_requests);
@@ -315,6 +320,8 @@
 				PATCH(log_response_header);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("debug.log-condition-handling"))) {
 				PATCH(log_condition_handling);
+			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("debug.log-condition-cache-handling"))) {
+				PATCH(log_condition_cache_handling);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("debug.log-file-not-found"))) {
 				PATCH(log_file_not_found);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("server.protocol-http11"))) {
@@ -699,21 +706,13 @@
 				for (i = 0; t->input[t->offset + i] && isdigit((unsigned char)t->input[t->offset + i]);  i++);
 				
 				/* was there it least a digit ? */
-				if (i && t->input[t->offset + i]) {
+				if (i) {
 					tid = TK_INTEGER;
 					
 					buffer_copy_string_len(token, t->input + t->offset, i);
 					
 					t->offset += i;
 					t->line_pos += i;
-				} else {
-					/* ERROR */
-					log_error_write(srv, __FILE__, __LINE__, "sbsdsds", 
-							"source:", t->source,
-							"line:", t->line, "pos:", t->line_pos, 
-							"unexpected EOF");
-					
-					return -1;
 				}
 			} else {
 				/* the key might consist of [-.0-9a-z] */
@@ -781,6 +780,7 @@
 	pParser = configparserAlloc( malloc );
 	lasttoken = buffer_init();
 	token = buffer_init();
+
 	while((1 == (ret = config_tokenizer(srv, t, &token_id, token))) && context->ok) {
 		buffer_copy_string_buffer(lasttoken, token);
 		configparser(pParser, token_id, token, context);
@@ -896,13 +896,12 @@
 static void context_init(server *srv, config_t *context) {
 	context->srv = srv;
 	context->ok = 1;
-	context->configs_stack = array_init();
-	context->configs_stack->is_weakref = 1;
+	context->configs_stack = buffer_ptr_init(NULL);
 	context->basedir = buffer_init();
 }
 
 static void context_free(config_t *context) {
-	array_free(context->configs_stack);
+	buffer_ptr_free(context->configs_stack);
 	buffer_free(context->basedir);
 }
 
@@ -918,13 +917,10 @@
 	context_init(srv, &context);
 	context.all_configs = srv->config_context;
 
-	pos = strrchr(fn,
-#ifdef __WIN32
-			'\\'
-#else
-			'/'
-#endif
-			);
+    /* use the current dir as basedir for all other includes
+    */
+	pos = strrchr(fn, DIR_SEPERATOR);
+
 	if (pos) {
 		buffer_copy_string_len(context.basedir, fn, pos - fn + 1);
 		fn = pos + 1;
@@ -1035,6 +1031,7 @@
 	return 0;
 }
 
+
 int config_set_defaults(server *srv) {
 	size_t i;
 	specific_config *s = srv->config_storage[0];
@@ -1077,10 +1074,11 @@
 	}  
 	
 	if (buffer_is_empty(srv->srvconf.changeroot)) {
+        pathname_unix2local(s->document_root);
 		if (-1 == stat(s->document_root->ptr, &st1)) {  
-			log_error_write(srv, __FILE__, __LINE__, "sb",  
+			log_error_write(srv, __FILE__, __LINE__, "sbs",
 					"base-docroot doesn't exist:",
-					s->document_root);  
+					s->document_root, strerror(errno));
 			return -1;
 		}
 
--- lighttpd-1.4.11/src/configfile.h	2005-08-23 17:36:12.000000000 +0300
+++ lighttpd/src/configfile.h	2006-07-11 21:23:39.995849464 +0300
@@ -9,7 +9,7 @@
 	server *srv;
 	int     ok;
 	array  *all_configs;
-	array  *configs_stack; /* to parse nested block */
+	buffer_ptr  *configs_stack; /* to parse nested block */
 	data_config *current; /* current started with { */
 	buffer *basedir;
 } config_t;
--- lighttpd-1.4.11/src/configparser.y	2006-01-26 18:46:25.000000000 +0200
+++ lighttpd/src/configparser.y	2006-07-11 21:23:40.127857732 +0300
@@ -21,33 +21,18 @@
     dc->parent = ctx->current;
     array_insert_unique(dc->parent->childs, (data_unset *)dc);
   }
-  array_insert_unique(ctx->configs_stack, (data_unset *)ctx->current);
+  buffer_ptr_append(ctx->configs_stack, (void *)ctx->current);
   ctx->current = dc;
 }
 
 static data_config *configparser_pop(config_t *ctx) {
   data_config *old = ctx->current;
-  ctx->current = (data_config *) array_pop(ctx->configs_stack);
+  ctx->current = (data_config *) buffer_ptr_pop(ctx->configs_stack);
   return old;
 }
 
 /* return a copied variable */
 static data_unset *configparser_get_variable(config_t *ctx, const buffer *key) {
-  if (strncmp(key->ptr, "env.", sizeof("env.") - 1) == 0) {
-    char *env;
-
-    if (NULL != (env = getenv(key->ptr + 4))) {
-      data_string *ds;
-      ds = data_string_init();
-      buffer_append_string(ds->value, env);
-      return (data_unset *)ds;
-    }
-
-    fprintf(stderr, "Undefined env variable: %s\n", key->ptr + 4);
-    ctx->ok = 0;
-
-    return NULL;
-  } else {
     data_unset *du;
     data_config *dc;
 
@@ -63,11 +48,8 @@
         return du->copy(du);
       }
     }
-    fprintf(stderr, "Undefined config variable: %s\n", key->ptr);
-    ctx->ok = 0;
     return NULL;
   }
-}
 
 /* op1 is to be eat/return by this function, op1->key is not cared
    op2 is left untouch, unreferenced
@@ -141,6 +123,7 @@
 %type       aelement               {data_unset *}
 %type       condline               {data_config *}
 %type       condlines              {data_config *}
+%type       global                 {data_config *}
 %type       aelements              {array *}
 %type       array                  {array *}
 %type       key                    {buffer *}
@@ -161,7 +144,12 @@
 
 varline ::= key(A) ASSIGN expression(B). {
   buffer_copy_string_buffer(B->key, A);
-  if (NULL == array_get_element(ctx->current->value, B->key->ptr)) {
+  if (strncmp(A->ptr, "env.", sizeof("env.") - 1) == 0) {
+    fprintf(stderr, "Setting env variable is not supported in conditional %d %s: %s\n",
+        ctx->current->context_ndx,
+        ctx->current->key->ptr, A->ptr);
+    ctx->ok = 0;
+  } else if (NULL == array_get_element(ctx->current->value, B->key->ptr)) {
     array_insert_unique(ctx->current->value, B);
     B = NULL;
   } else {
@@ -180,7 +168,12 @@
   array *vars = ctx->current->value;
   data_unset *du;
 
-  if (NULL != (du = array_get_element(vars, A->ptr))) {
+  if (strncmp(A->ptr, "env.", sizeof("env.") - 1) == 0) {
+    fprintf(stderr, "Appending env variable is not supported in conditional %d %s: %s\n",
+        ctx->current->context_ndx,
+        ctx->current->key->ptr, A->ptr);
+    ctx->ok = 0;
+  } else if (NULL != (du = array_get_element(vars, A->ptr))) {
     /* exists in current block */
     du = configparser_merge_data(du, B);
     if (NULL == du) {
@@ -190,6 +183,7 @@
       buffer_copy_string_buffer(du->key, A);
       array_replace(vars, du);
     }
+    B->free(B);
   } else if (NULL != (du = configparser_get_variable(ctx, A))) {
     du = configparser_merge_data(du, B);
     if (NULL == du) {
@@ -199,15 +193,13 @@
       buffer_copy_string_buffer(du->key, A);
       array_insert_unique(ctx->current->value, du);
     }
+    B->free(B);
   } else {
-    fprintf(stderr, "Undefined config variable in conditional %d %s: %s\n", 
-            ctx->current->context_ndx,
-            ctx->current->key->ptr, A->ptr);
-    ctx->ok = 0;
+    buffer_copy_string_buffer(B->key, A);
+    array_insert_unique(ctx->current->value, B);
   }
   buffer_free(A);
   A = NULL;
-  B->free(B);
   B = NULL;
 }
 
@@ -239,7 +231,24 @@
 }
 
 value(A) ::= key(B). {
-  A = configparser_get_variable(ctx, B);
+  if (strncmp(B->ptr, "env.", sizeof("env.") - 1) == 0) {
+    char *env;
+
+    if (NULL != (env = getenv(B->ptr + 4))) {
+      data_string *ds;
+      ds = data_string_init();
+      buffer_append_string(ds->value, env);
+      A = (data_unset *)ds;
+    }
+    else {
+      A = NULL;
+      fprintf(stderr, "Undefined env variable: %s\n", B->ptr + 4);
+      ctx->ok = 0;
+    }
+  } else if (NULL == (A = configparser_get_variable(ctx, B))) {
+    fprintf(stderr, "Undefined config variable: %s\n", B->ptr);
+    ctx->ok = 0;
+  }
   if (!A) {
     /* make a dummy so it won't crash */
     A = (data_unset *)data_string_init();
@@ -267,6 +276,9 @@
   ((data_array *)(A))->value = B;
   B = NULL;
 }
+array(A) ::= LPARAN RPARAN. {
+  A = array_init();
+}
 array(A) ::= LPARAN aelements(B) RPARAN. {
   A = B;
   B = NULL;
--- lighttpd-1.4.11/src/connections.c	2006-03-05 22:14:53.000000000 +0200
+++ lighttpd/src/connections.c	2006-07-11 21:23:39.955846959 +0300
@@ -2,7 +2,6 @@
 
 #include <stdlib.h>
 #include <stdio.h>
-#include <unistd.h>
 #include <errno.h>
 #include <string.h>
 #include <fcntl.h>
@@ -35,6 +34,7 @@
 #endif
 
 #include "sys-socket.h"
+#include "sys-files.h"
 
 typedef struct {
 	        PLUGIN_DATA;
@@ -111,9 +111,7 @@
 int connection_close(server *srv, connection *con) {
 #ifdef USE_OPENSSL
 	server_socket *srv_sock = con->srv_socket;
-#endif
 	
-#ifdef USE_OPENSSL
 	if (srv_sock->is_ssl) {
 		if (con->ssl) SSL_free(con->ssl);
 		con->ssl = NULL;
@@ -122,7 +120,7 @@
 	
 	fdevent_event_del(srv->ev, &(con->fde_ndx), con->fd);
 	fdevent_unregister(srv->ev, con->fd);
-#ifdef __WIN32
+#ifdef _WIN32
 	if (closesocket(con->fd)) {
 		log_error_write(srv, __FILE__, __LINE__, "sds",
 				"(warning) close:", con->fd, strerror(errno));
@@ -190,150 +188,39 @@
 }
 #endif 
 
-static int connection_handle_read(server *srv, connection *con) {
-	int len;
-	buffer *b;
-	int toread;
-#ifdef USE_OPENSSL
-	server_socket *srv_sock = con->srv_socket;
-#endif
-
-	b = chunkqueue_get_append_buffer(con->read_queue);
-	buffer_prepare_copy(b, 4096);
-
-#ifdef USE_OPENSSL
-	if (srv_sock->is_ssl) {
-		len = SSL_read(con->ssl, b->ptr, b->size - 1);
-	} else {
-		if (ioctl(con->fd, FIONREAD, &toread)) {
-			log_error_write(srv, __FILE__, __LINE__, "sd", 
-					"unexpected end-of-file:",
-					con->fd);
-			return -1;
-		}
-		buffer_prepare_copy(b, toread);
-
-		len = read(con->fd, b->ptr, b->size - 1);
-	}
-#elif defined(__WIN32)
-	len = recv(con->fd, b->ptr, b->size - 1, 0);
-#else
-	if (ioctl(con->fd, FIONREAD, &toread)) {
-		log_error_write(srv, __FILE__, __LINE__, "sd", 
-				"unexpected end-of-file:",
-				con->fd);
-		return -1;
-	}
-	buffer_prepare_copy(b, toread);
-
-	len = read(con->fd, b->ptr, b->size - 1);
-#endif
-	
-	if (len < 0) {
-		con->is_readable = 0;
-		
-#ifdef USE_OPENSSL
-		if (srv_sock->is_ssl) {
-			int r, ssl_err;
-			
-			switch ((r = SSL_get_error(con->ssl, len))) {
-			case SSL_ERROR_WANT_READ:
-				return 0;
-			case SSL_ERROR_SYSCALL:
-				/**
-				 * man SSL_get_error()
-				 * 
-				 * SSL_ERROR_SYSCALL
-				 *   Some I/O error occurred.  The OpenSSL error queue may contain more 
-				 *   information on the error.  If the error queue is empty (i.e.
-				 *   ERR_get_error() returns 0), ret can be used to find out more about 
-				 *   the error: If ret == 0, an EOF was observed that violates the
-				 *   protocol.  If ret == -1, the underlying BIO reported an I/O error 
-				 *   (for socket I/O on Unix systems, consult errno for details).
-				 *
-				 */
-				while((ssl_err = ERR_get_error())) {
-					/* get all errors from the error-queue */
-					log_error_write(srv, __FILE__, __LINE__, "sds", "SSL:", 
-							r, ERR_error_string(ssl_err, NULL));
-				}
-
-				switch(errno) {
-				default:
-					log_error_write(srv, __FILE__, __LINE__, "sddds", "SSL:", 
-							len, r, errno,
-							strerror(errno));
-					break;
-				}
-				
-				break;
-			case SSL_ERROR_ZERO_RETURN:
-				/* clean shutdown on the remote side */
+static network_status_t connection_handle_read(server *srv, connection *con) {
+	off_t oldlen, newlen;
 				
-				if (r == 0) {
-					/* FIXME: later */
-				}
+    oldlen = chunkqueue_length(con->read_queue);
 				
-				/* fall thourgh */
-			default:
-				while((ssl_err = ERR_get_error())) {
-					/* get all errors from the error-queue */
-					log_error_write(srv, __FILE__, __LINE__, "sds", "SSL:", 
-							r, ERR_error_string(ssl_err, NULL));
-				}
+    switch(network_read_chunkqueue(srv, con, con->read_queue)) {
+    case NETWORK_STATUS_SUCCESS:
 				break;
-			}
-		} else {
-			if (errno == EAGAIN) return 0;
-			if (errno == EINTR) {
-				/* we have been interrupted before we could read */
-				con->is_readable = 1;
-				return 0;
-			}
-		
-			if (errno != ECONNRESET) {
-				/* expected for keep-alive */
-				log_error_write(srv, __FILE__, __LINE__, "ssd", "connection closed - read failed: ", strerror(errno), errno);
-			}
-		}
-#else
-		if (errno == EAGAIN) return 0;
-		if (errno == EINTR) {
-			/* we have been interrupted before we could read */
-			con->is_readable = 1;
-			return 0;
-		}
-		
-		if (errno != ECONNRESET) {
-			/* expected for keep-alive */
-			log_error_write(srv, __FILE__, __LINE__, "ssd", "connection closed - read failed: ", strerror(errno), errno);
-		}
-#endif
-		connection_set_state(srv, con, CON_STATE_ERROR);
-		
-		return -1;
-	} else if (len == 0) {
+    case NETWORK_STATUS_WAIT_FOR_EVENT:
 		con->is_readable = 0;
-		/* the other end close the connection -> KEEP-ALIVE */
-
+        return NETWORK_STATUS_WAIT_FOR_EVENT;
+    case NETWORK_STATUS_INTERRUPTED:
+        con->is_readable = 1;
+        return NETWORK_STATUS_WAIT_FOR_EVENT;
+    case NETWORK_STATUS_CONNECTION_CLOSE:
 		/* pipelining */
-
-		return -2;
-	} else if ((size_t)len < b->size - 1) {
-		/* we got less then expected, wait for the next fd-event */
-		
 		con->is_readable = 0;
+        return NETWORK_STATUS_CONNECTION_CLOSE;
+    case NETWORK_STATUS_FATAL_ERROR:
+        con->is_readable = 0;
+
+        connection_set_state(srv, con, CON_STATE_ERROR);
+        return NETWORK_STATUS_FATAL_ERROR;
+    default:
+        SEGFAULT();
+        break;
 	}
 	
-	b->used = len;
-	b->ptr[b->used++] = '\0';
+    newlen = chunkqueue_length(con->read_queue);
 	
-	con->bytes_read += len;
-#if 0
-	dump_packet(b->ptr, len);
-#endif
+	con->bytes_read += (newlen - oldlen);
 	
-	return 0;
+	return NETWORK_STATUS_SUCCESS;
 }
 
 static int connection_handle_write_prepare(server *srv, connection *con) {
@@ -343,6 +230,7 @@
 		case HTTP_METHOD_GET:
 		case HTTP_METHOD_POST:
 		case HTTP_METHOD_HEAD:
+			/* webdav */
 		case HTTP_METHOD_PUT:
 		case HTTP_METHOD_MKCOL:
 		case HTTP_METHOD_DELETE:
@@ -350,6 +238,8 @@
 		case HTTP_METHOD_MOVE:
 		case HTTP_METHOD_PROPFIND:
 		case HTTP_METHOD_PROPPATCH:
+		case HTTP_METHOD_LOCK:
+		case HTTP_METHOD_UNLOCK:
 			break;
 		case HTTP_METHOD_OPTIONS:
 			/*
@@ -392,6 +282,8 @@
 	case 403:
 	case 404:
 	case 408:
+	case 409:
+	case 410:
 	case 411:
 	case 416:
 	case 423:
@@ -399,6 +291,7 @@
 	case 501:
 	case 503:
 	case 505: 
+	case 509:
 		if (con->mode != DIRECT) break;
 		
 		con->file_finished = 0;
@@ -528,34 +421,37 @@
 
 static int connection_handle_write(server *srv, connection *con) {
 	switch(network_write_chunkqueue(srv, con, con->write_queue)) {
-	case 0:
+	case NETWORK_STATUS_SUCCESS:
 		if (con->file_finished) {
 			connection_set_state(srv, con, CON_STATE_RESPONSE_END);
 			joblist_append(srv, con);
 		}
 		break;
-	case -1: /* error on our side */
+	case NETWORK_STATUS_FATAL_ERROR: /* error on our side */
 		log_error_write(srv, __FILE__, __LINE__, "sd",
 				"connection closed: write failed on fd", con->fd);
 		connection_set_state(srv, con, CON_STATE_ERROR);
 		joblist_append(srv, con);
 		break;
-	case -2: /* remote close */
+	case NETWORK_STATUS_CONNECTION_CLOSE: /* remote close */
 		connection_set_state(srv, con, CON_STATE_ERROR);
 		joblist_append(srv, con);
 		break;
-	case 1:
+	case NETWORK_STATUS_WAIT_FOR_EVENT:
 		con->is_writable = 0;
 		
 		/* not finished yet -> WRITE */
 		break;
+	case NETWORK_STATUS_INTERRUPTED:
+		con->is_writable = 1;
+		break;
+	case NETWORK_STATUS_UNSET:
+		break;
 	}
 	
 	return 0;
 }
 
-
-
 connection *connection_init(server *srv) {
 	connection *con;
 	
@@ -845,17 +741,20 @@
 		con->read_idle_ts = srv->cur_ts;
 	
 		switch(connection_handle_read(srv, con)) {
-		case -1:
+		case NETWORK_STATUS_FATAL_ERROR:
 			return -1;
-		case -2:
+		case NETWORK_STATUS_CONNECTION_CLOSE:
 			/* remote side closed the connection
 			 * if we still have content, handle it, if not leave here */
 
 			if (cq->first == cq->last &&
-			    cq->first->mem->used == 0) {
+                (NULL == cq->first ||
+			    cq->first->mem->used == 0)) {
 
 				/* conn-closed, leave here */
 				connection_set_state(srv, con, CON_STATE_ERROR);
+
+                return 0;
 			}
 		default:
 			break;
@@ -925,6 +824,7 @@
 				
 				/* the buffer has been read up to the terminator */
 				c->offset += h_term - b.ptr + 4;
+
 			} else {
 				/* not found, copy everything */
 				buffer_copy_string_len(con->request.request, c->mem->ptr + c->offset, c->mem->used - c->offset - 1);
@@ -1177,6 +1077,13 @@
 	if (con->state == CON_STATE_READ ||
 	    con->state == CON_STATE_READ_POST) {
 		connection_handle_read_state(srv, con);
+		/**
+		 * if SSL_read() is not readin in the full packet we won't get
+		 * a fdevent as the low-level has already fetched everything.
+		 *
+		 * we have to call the state-engine to read the rest of the packet
+		 */
+		if (con->is_readable) joblist_append(srv, con);
 	}
 	
 	if (con->state == CON_STATE_WRITE &&
@@ -1233,9 +1140,13 @@
 	cnt_len = sizeof(cnt_addr);
 
 	if (-1 == (cnt = accept(srv_socket->fd, (struct sockaddr *) &cnt_addr, &cnt_len))) {
+#ifdef _WIN32
+        errno = WSAGetLastError();
+#endif
 		if ((errno != EAGAIN) &&
+            (errno != EWOULDBLOCK) &&
 		    (errno != EINTR)) {
-			log_error_write(srv, __FILE__, __LINE__, "ssd", "accept failed:", strerror(errno), errno);
+			log_error_write(srv, __FILE__, __LINE__, "ssd", "accept failed:", strerror(errno), srv_socket->fd);
 		}
 		return NULL;
 	} else {
@@ -1251,7 +1162,6 @@
 		srv->con_opened++;
 		
 		con = connections_get_new_connection(srv);
-		
 		con->fd = cnt;
 		con->fde_ndx = -1;
 #if 0		
@@ -1268,6 +1178,7 @@
 		
 		if (-1 == (fdevent_fcntl_set(srv->ev, con->fd))) {
 			log_error_write(srv, __FILE__, __LINE__, "ss", "fcntl failed: ", strerror(errno));
+			connection_close(srv, con);
 			return NULL;
 		}
 #ifdef USE_OPENSSL
@@ -1276,7 +1187,7 @@
 			if (NULL == (con->ssl = SSL_new(srv_socket->ssl_ctx))) {
 				log_error_write(srv, __FILE__, __LINE__, "ss", "SSL:", 
 						ERR_error_string(ERR_get_error(), NULL));
-				
+				connection_close(srv, con);
 				return NULL;
 			}
 			
@@ -1286,6 +1197,7 @@
 			if (1 != (SSL_set_fd(con->ssl, cnt))) {
 				log_error_write(srv, __FILE__, __LINE__, "ss", "SSL:", 
 						ERR_error_string(ERR_get_error(), NULL));
+				connection_close(srv, con);
 				return NULL;
 			}
 		}
--- lighttpd-1.4.11/src/crc32.h	2005-09-30 20:18:59.000000000 +0300
+++ lighttpd/src/crc32.h	2006-07-11 21:23:40.131857983 +0300
@@ -6,6 +6,7 @@
 #endif
 
 #include <sys/types.h>
+#include <stdlib.h>
 
 #if defined HAVE_STDINT_H
 #include <stdint.h>
@@ -13,6 +14,10 @@
 #include <inttypes.h>
 #endif
 
+#ifdef _WIN32
+#define uint32_t unsigned __int32
+#endif
+
 uint32_t generate_crc32c(char *string, size_t length);
 
 #endif
--- lighttpd-1.4.11/src/etag.h	2005-08-11 01:26:40.000000000 +0300
+++ lighttpd/src/etag.h	2006-07-11 21:23:40.027851469 +0300
@@ -3,7 +3,6 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <unistd.h>
 
 #include "buffer.h"
 
--- lighttpd-1.4.11/src/fdevent.c	2005-11-15 10:51:05.000000000 +0200
+++ lighttpd/src/fdevent.c	2006-07-11 21:23:40.287867754 +0300
@@ -2,7 +2,6 @@
 
 #include "settings.h"
 
-#include <unistd.h>
 #include <stdlib.h>
 #include <string.h>
 #include <errno.h>
@@ -12,6 +11,8 @@
 #include "fdevent.h"
 #include "buffer.h"
 
+#include "sys-socket.h"
+
 fdevents *fdevent_init(size_t maxfds, fdevent_handler_t type) {
 	fdevents *ev;
 	
@@ -181,6 +182,9 @@
 }
 
 int fdevent_fcntl_set(fdevents *ev, int fd) {
+#ifdef _WIN32
+    int i = 1;
+#endif
 #ifdef FD_CLOEXEC
 	/* close fd on exec (cgi) */
 	fcntl(fd, F_SETFD, FD_CLOEXEC);
@@ -188,6 +192,8 @@
 	if ((ev) && (ev->fcntl_set)) return ev->fcntl_set(ev, fd);
 #ifdef O_NONBLOCK	
 	return fcntl(fd, F_SETFL, O_NONBLOCK | O_RDWR);
+#elif defined _WIN32
+    return ioctlsocket(fd, FIONBIO, &i);
 #else
 	return 0;
 #endif
--- lighttpd-1.4.11/src/fdevent.h	2005-09-27 11:26:33.000000000 +0300
+++ lighttpd/src/fdevent.h	2006-07-11 21:23:39.883842449 +0300
@@ -31,9 +31,11 @@
 #  include <signal.h>
 # endif
 #endif
-
+#ifdef _WIN32
+# define HAVE_SELECT
+#endif
 #if defined HAVE_SELECT
-# ifdef __WIN32
+# ifdef _WIN32
 #  include <winsock2.h>
 # endif
 # define USE_SELECT
--- lighttpd-1.4.11/src/fdevent_freebsd_kqueue.c	2005-09-01 10:46:24.000000000 +0300
+++ lighttpd/src/fdevent_freebsd_kqueue.c	2006-07-11 21:23:39.987848963 +0300
@@ -1,6 +1,5 @@
 #include <sys/types.h>
 
-#include <unistd.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
--- lighttpd-1.4.11/src/fdevent_linux_rtsig.c	2005-11-21 19:56:11.000000000 +0200
+++ lighttpd/src/fdevent_linux_rtsig.c	2006-07-11 21:23:40.179860989 +0300
@@ -1,6 +1,5 @@
 #include <sys/types.h>
 
-#include <unistd.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -14,6 +13,7 @@
 #include "fdevent.h"
 #include "settings.h"
 #include "buffer.h"
+#include "sys-process.h"
 
 #ifdef USE_LINUX_SIGIO
 static void fdevent_linux_rtsig_free(fdevents *ev) {
--- lighttpd-1.4.11/src/fdevent_linux_sysepoll.c	2005-09-30 20:29:27.000000000 +0300
+++ lighttpd/src/fdevent_linux_sysepoll.c	2006-07-11 21:23:40.223863745 +0300
@@ -1,6 +1,5 @@
 #include <sys/types.h>
 
-#include <unistd.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -12,6 +11,8 @@
 #include "settings.h"
 #include "buffer.h"
 
+#include "sys-files.h"
+
 #ifdef USE_LINUX_EPOLL
 static void fdevent_linux_sysepoll_free(fdevents *ev) {
 	close(ev->epoll_fd);
--- lighttpd-1.4.11/src/fdevent_poll.c	2005-11-18 13:59:16.000000000 +0200
+++ lighttpd/src/fdevent_poll.c	2006-07-11 21:23:40.207862743 +0300
@@ -1,6 +1,5 @@
 #include <sys/types.h>
 
-#include <unistd.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
--- lighttpd-1.4.11/src/fdevent_select.c	2005-08-31 11:12:46.000000000 +0300
+++ lighttpd/src/fdevent_select.c	2006-07-11 21:23:40.211862994 +0300
@@ -1,18 +1,19 @@
-#include <sys/time.h>
 #include <sys/types.h>
 
-#include <unistd.h>
 #include <stdlib.h>
 #include <string.h>
 #include <errno.h>
 #include <signal.h>
 #include <fcntl.h>
 #include <assert.h>
+#include <stdio.h>
 
 #include "fdevent.h"
 #include "settings.h"
 #include "buffer.h"
 
+#include "sys-socket.h"
+
 #ifdef USE_SELECT
 
 static int fdevent_select_reset(fdevents *ev) {
@@ -38,7 +39,9 @@
 	UNUSED(fde_ndx);
 
 	/* we should be protected by max-fds, but you never know */
+#ifndef _WIN32
 	assert(fd < FD_SETSIZE);
+#endif
 
 	if (events & FDEVENT_IN) {
 		FD_SET(fd, &(ev->select_set_read));
--- lighttpd-1.4.11/src/fdevent_solaris_devpoll.c	2005-09-01 10:45:26.000000000 +0300
+++ lighttpd/src/fdevent_solaris_devpoll.c	2006-07-11 21:23:40.015850717 +0300
@@ -1,6 +1,5 @@
 #include <sys/types.h>
 
-#include <unistd.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
--- lighttpd-1.4.11/src/http-header-glue.c	2006-02-08 15:31:36.000000000 +0200
+++ lighttpd/src/http-header-glue.c	2006-07-11 21:23:40.187861491 +0300
@@ -261,13 +261,22 @@
 						con->http_status = 304;
 						return HANDLER_FINISHED;
 					} else {
+#ifdef HAVE_STRPTIME
 						char buf[sizeof("Sat, 23 Jul 2005 21:20:01 GMT")];
-
-						/* convert to timestamp */
-						if (used_len < sizeof(buf)) {
 							time_t t_header, t_file;
 							struct tm tm;
 							
+						/* check if we can safely copy the string */
+						if (used_len >= sizeof(buf)) {
+							log_error_write(srv, __FILE__, __LINE__, "ssdd",
+									"DEBUG: Last-Modified check failed as the received timestamp was too long:",
+									con->request.http_if_modified_since, used_len, sizeof(buf) - 1);
+
+							con->http_status = 412;
+							return HANDLER_FINISHED;
+						}
+
+
 							strncpy(buf, con->request.http_if_modified_since, used_len);
 							buf[used_len] = '\0';
 							
@@ -277,18 +286,13 @@
 							strptime(mtime->ptr, "%a, %d %b %Y %H:%M:%S GMT", &tm);
 							t_file = mktime(&tm);
 
-							if (t_file > t_header) {
-								con->http_status = 304;
-								return HANDLER_FINISHED;
-							}
-						} else {
-							log_error_write(srv, __FILE__, __LINE__, "ssdd", 
-									"DEBUG: Last-Modified check failed as the received timestamp was too long:", 
-									con->request.http_if_modified_since, used_len, sizeof(buf) - 1);
+						if (t_file > t_header) return HANDLER_GO_ON;
 							
-							con->http_status = 412;
+						con->http_status = 304;
 							return HANDLER_FINISHED;
-						}
+#else
+                        return HANDLER_GO_ON;
+#endif
 					}
 				} else {
 					con->http_status = 304;
@@ -312,6 +316,31 @@
 		if (0 == strncmp(con->request.http_if_modified_since, mtime->ptr, used_len)) {
 			con->http_status = 304;
 			return HANDLER_FINISHED;
+		} else {
+#ifdef HAVE_STRPTIME
+			char buf[sizeof("Sat, 23 Jul 2005 21:20:01 GMT")];
+			time_t t_header, t_file;
+			struct tm tm;
+
+			/* convert to timestamp */
+			if (used_len >= sizeof(buf)) return HANDLER_GO_ON;
+
+			strncpy(buf, con->request.http_if_modified_since, used_len);
+			buf[used_len] = '\0';
+
+			strptime(buf, "%a, %d %b %Y %H:%M:%S GMT", &tm);
+			t_header = mktime(&tm);
+
+			strptime(mtime->ptr, "%a, %d %b %Y %H:%M:%S GMT", &tm);
+			t_file = mktime(&tm);
+
+			if (t_file > t_header) return HANDLER_GO_ON;
+
+			con->http_status = 304;
+			return HANDLER_FINISHED;
+#else
+            return HANDLER_GO_ON;
+#endif
 		}
 	}
 
--- lighttpd-1.4.11/src/http_auth.c	2006-02-01 13:02:52.000000000 +0200
+++ lighttpd/src/http_auth.c	2006-07-11 21:23:40.115856981 +0300
@@ -22,7 +22,6 @@
 #include <string.h>
 #include <time.h>
 #include <errno.h>
-#include <unistd.h>
 #include <ctype.h>
 
 #include "server.h"
@@ -31,23 +30,14 @@
 #include "http_auth_digest.h"
 #include "stream.h"
 
+#include "sys-strings.h"
+
 #ifdef USE_OPENSSL
 # include <openssl/md5.h>
 #else
 # include "md5.h"
 #endif
 
-
-#ifdef USE_PAM
-#include <security/pam_appl.h>
-#include <security/pam_misc.h>
-
-static struct pam_conv conv = {
-	misc_conv,
-		NULL
-};
-#endif
-
 handler_t auth_ldap_init(server *srv, mod_auth_plugin_config *s);
 
 static const char base64_pad = '=';
@@ -509,33 +499,6 @@
 		if (0 == strcmp(password->ptr, pw)) {
 			return 0;
 		}
-	} else if (p->conf.auth_backend == AUTH_BACKEND_PAM) { 
-#ifdef USE_PAM
-		pam_handle_t *pamh=NULL;
-		int retval;
-		
-		retval = pam_start("lighttpd", username->ptr, &conv, &pamh);
-		
-		if (retval == PAM_SUCCESS)
-			retval = pam_authenticate(pamh, 0);    /* is user really user? */
-		
-		if (retval == PAM_SUCCESS)
-			retval = pam_acct_mgmt(pamh, 0);       /* permitted access? */
-		
-		/* This is where we have been authorized or not. */
-		
-		if (pam_end(pamh,retval) != PAM_SUCCESS) {     /* close Linux-PAM */
-			pamh = NULL;
-			log_error_write(srv, __FILE__, __LINE__, "s", "failed to release authenticator");
-		}
-		
-		if (retval == PAM_SUCCESS) {
-			log_error_write(srv, __FILE__, __LINE__, "s", "Authenticated");
-			return 0;
-		} else {
-			log_error_write(srv, __FILE__, __LINE__, "s", "Not Authenticated");
-		}
-#endif
 	} else if (p->conf.auth_backend == AUTH_BACKEND_LDAP) { 
 #ifdef USE_LDAP
 		LDAP *ldap;
--- lighttpd-1.4.11/src/http_auth.h	2005-08-14 17:12:31.000000000 +0300
+++ lighttpd/src/http_auth.h	2006-07-11 21:23:40.119857231 +0300
@@ -9,9 +9,13 @@
 # include <ldap.h>
 #endif
 
-typedef enum { AUTH_BACKEND_UNSET, AUTH_BACKEND_PLAIN, 
-		AUTH_BACKEND_LDAP, AUTH_BACKEND_HTPASSWD, 
-		AUTH_BACKEND_HTDIGEST, AUTH_BACKEND_PAM } auth_backend_t;
+typedef enum {
+	AUTH_BACKEND_UNSET,
+	AUTH_BACKEND_PLAIN,
+	AUTH_BACKEND_LDAP,
+	AUTH_BACKEND_HTPASSWD,
+	AUTH_BACKEND_HTDIGEST
+} auth_backend_t;
 
 typedef struct {
 	/* auth */
--- lighttpd-1.4.11/src/http_chunk.c	2005-08-11 01:26:50.000000000 +0300
+++ lighttpd/src/http_chunk.c	2006-07-11 21:23:40.251865499 +0300
@@ -9,7 +9,6 @@
 
 #include <stdlib.h>
 #include <fcntl.h>
-#include <unistd.h>
 
 #include <stdio.h>
 #include <errno.h>
--- lighttpd-1.4.11/src/keyvalue.c	2006-03-02 16:08:06.000000000 +0200
+++ lighttpd/src/keyvalue.c	2006-07-11 21:23:40.027851469 +0300
@@ -87,6 +87,7 @@
 	{ 504, "Gateway Timeout" },
 	{ 505, "HTTP Version Not Supported" },
 	{ 507, "Insufficient Storage" }, /* WebDAV */
+	{ 509, "Bandwidth Limit exceeded" },
 	
 	{ -1, NULL }
 };
--- lighttpd-1.4.11/src/log.c	2005-11-07 15:01:35.000000000 +0200
+++ lighttpd/src/log.c	2006-07-11 21:23:40.275867002 +0300
@@ -5,7 +5,6 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <time.h>
-#include <unistd.h>
 #include <string.h>
 #include <stdlib.h>
 
@@ -16,6 +15,10 @@
 #include "config.h"
 #endif
 
+#ifdef _WIN32
+#undef HAVE_SYSLOG_H
+#endif
+
 #ifdef HAVE_SYSLOG_H
 #include <syslog.h>
 #endif
@@ -23,6 +26,8 @@
 #include "log.h"
 #include "array.h"
 
+#include "sys-files.h"
+
 #ifdef HAVE_VALGRIND_VALGRIND_H
 #include <valgrind/valgrind.h>
 #endif
@@ -246,9 +251,11 @@
 		BUFFER_APPEND_STRING_CONST(srv->errorlog_buf, "\n");
 		write(STDERR_FILENO, srv->errorlog_buf->ptr, srv->errorlog_buf->used - 1);
 		break;
+#ifdef HAVE_SYSLOG_H
 	case ERRORLOG_SYSLOG:
 		syslog(LOG_ERR, "%s", srv->errorlog_buf->ptr);
 		break;
+#endif
 	}
 	
 	return 0;
--- lighttpd-1.4.11/src/md5.h	2005-11-17 16:20:40.000000000 +0200
+++ lighttpd/src/md5.h	2006-07-11 21:23:40.155859486 +0300
@@ -30,9 +30,15 @@
 # include <inttypes.h>
 #endif
 
+#ifdef _WIN32
+#define UINT4 unsigned __int32
+#define UINT2 unsigned __int16
+#define POINTER unsigned char *
+#else
 #define UINT4 uint32_t
 #define UINT2 uint16_t
 #define POINTER unsigned char *
+#endif
 
 /* MD5 context. */
 typedef struct {
--- lighttpd-1.4.11/src/mod_access.c	2006-01-14 19:44:54.000000000 +0200
+++ lighttpd/src/mod_access.c	2006-07-11 21:23:40.219863495 +0300
@@ -8,6 +8,8 @@
 
 #include "plugin.h"
 
+#include "sys-strings.h"
+
 typedef struct {
 	array *access_deny;
 } plugin_config;
@@ -81,13 +83,11 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_access_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 
-	PATCH(access_deny);
+	PATCH_OPTION(access_deny);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -102,14 +102,13 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("url.access-deny"))) {
-				PATCH(access_deny);
+				PATCH_OPTION(access_deny);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 URIHANDLER_FUNC(mod_access_uri_handler) {
 	plugin_data *p = p_d;
--- lighttpd-1.4.11/src/mod_accesslog.c	2006-01-31 14:01:43.000000000 +0200
+++ lighttpd/src/mod_accesslog.c	2006-07-11 21:23:40.219863495 +0300
@@ -6,8 +6,7 @@
 #include <ctype.h>
 #include <stdlib.h>
 #include <string.h>
-#include <fcntl.h>
-#include <unistd.h>
+#include <fcntl.h> /* only the defines on windows */
 #include <errno.h>
 #include <time.h>
 
@@ -22,6 +21,7 @@
 #include "inet_ntop_cache.h"
 
 #include "sys-socket.h"
+#include "sys-files.h"
 
 #ifdef HAVE_SYSLOG_H
 # include <syslog.h>
@@ -517,8 +517,9 @@
 			
 			return HANDLER_ERROR;
 		}
+#ifndef _WIN32
 		fcntl(s->log_access_fd, F_SETFD, FD_CLOEXEC);
-	
+#endif
 	}
 	
 	return HANDLER_GO_ON;
@@ -567,20 +568,18 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_accesslog_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(access_logfile);
-	PATCH(format);
-	PATCH(log_access_fd);
-	PATCH(last_generated_accesslog_ts_ptr);
-	PATCH(access_logbuffer);
-	PATCH(ts_accesslog_str);
-	PATCH(parsed_format);
-	PATCH(use_syslog);
+	PATCH_OPTION(access_logfile);
+	PATCH_OPTION(format);
+	PATCH_OPTION(log_access_fd);
+	PATCH_OPTION(last_generated_accesslog_ts_ptr);
+	PATCH_OPTION(access_logbuffer);
+	PATCH_OPTION(ts_accesslog_str);
+	PATCH_OPTION(parsed_format);
+	PATCH_OPTION(use_syslog);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -595,23 +594,22 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("accesslog.filename"))) {
-				PATCH(access_logfile);
-				PATCH(log_access_fd);
-				PATCH(last_generated_accesslog_ts_ptr);
-				PATCH(access_logbuffer);
-				PATCH(ts_accesslog_str);
+				PATCH_OPTION(access_logfile);
+				PATCH_OPTION(log_access_fd);
+				PATCH_OPTION(last_generated_accesslog_ts_ptr);
+				PATCH_OPTION(access_logbuffer);
+				PATCH_OPTION(ts_accesslog_str);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("accesslog.format"))) {
-				PATCH(format);
-				PATCH(parsed_format);
+				PATCH_OPTION(format);
+				PATCH_OPTION(parsed_format);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("accesslog.use-syslog"))) {
-				PATCH(use_syslog);
+				PATCH_OPTION(use_syslog);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 REQUESTDONE_FUNC(log_access_write) {
 	plugin_data *p = p_d;
--- lighttpd-1.4.11/src/mod_alias.c	2006-03-01 23:18:51.000000000 +0200
+++ lighttpd/src/mod_alias.c	2006-07-11 21:23:39.979848462 +0300
@@ -8,6 +8,7 @@
 #include "buffer.h"
 
 #include "plugin.h"
+#include "sys-strings.h"
 
 /* plugin config for all request/connections */
 typedef struct {
@@ -114,13 +115,11 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_alias_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(alias);
+	PATCH_OPTION(alias);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -135,14 +134,13 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("alias.url"))) {
-				PATCH(alias);
+				PATCH_OPTION(alias);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 PHYSICALPATH_FUNC(mod_alias_physical_handler) {
 	plugin_data *p = p_d;
--- lighttpd-1.4.11/src/mod_auth.c	2006-02-15 20:01:31.000000000 +0200
+++ lighttpd/src/mod_auth.c	2006-07-11 21:23:40.171860488 +0300
@@ -5,13 +5,15 @@
 #include <string.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <unistd.h>
 
 #include "plugin.h"
 #include "http_auth.h"
 #include "log.h"
 #include "response.h"
 
+#include "sys-strings.h"
+#include "sys-files.h"
+
 handler_t auth_ldap_init(server *srv, mod_auth_plugin_config *s);
 
 
@@ -93,30 +95,28 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_auth_patch_connection(server *srv, connection *con, mod_auth_plugin_data *p) {
 	size_t i, j;
 	mod_auth_plugin_config *s = p->config_storage[0];
 
-	PATCH(auth_backend);
-	PATCH(auth_plain_groupfile);
-	PATCH(auth_plain_userfile);
-	PATCH(auth_htdigest_userfile);
-	PATCH(auth_htpasswd_userfile);
-	PATCH(auth_require);
-	PATCH(auth_debug);
-	PATCH(auth_ldap_hostname);
-	PATCH(auth_ldap_basedn);
-	PATCH(auth_ldap_binddn);
-	PATCH(auth_ldap_bindpw);
-	PATCH(auth_ldap_filter);
-	PATCH(auth_ldap_cafile);
-	PATCH(auth_ldap_starttls);
+	PATCH_OPTION(auth_backend);
+	PATCH_OPTION(auth_plain_groupfile);
+	PATCH_OPTION(auth_plain_userfile);
+	PATCH_OPTION(auth_htdigest_userfile);
+	PATCH_OPTION(auth_htpasswd_userfile);
+	PATCH_OPTION(auth_require);
+	PATCH_OPTION(auth_debug);
+	PATCH_OPTION(auth_ldap_hostname);
+	PATCH_OPTION(auth_ldap_basedn);
+	PATCH_OPTION(auth_ldap_binddn);
+	PATCH_OPTION(auth_ldap_bindpw);
+	PATCH_OPTION(auth_ldap_filter);
+	PATCH_OPTION(auth_ldap_cafile);
+	PATCH_OPTION(auth_ldap_starttls);
 #ifdef USE_LDAP
-	PATCH(ldap);
-	PATCH(ldap_filter_pre);
-	PATCH(ldap_filter_post);
+	PATCH_OPTION(ldap);
+	PATCH_OPTION(ldap_filter_pre);
+	PATCH_OPTION(ldap_filter_post);
 #endif
 	
 	/* skip the first, the global context */
@@ -132,41 +132,40 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("auth.backend"))) {
-				PATCH(auth_backend);
+				PATCH_OPTION(auth_backend);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("auth.backend.plain.groupfile"))) {
-				PATCH(auth_plain_groupfile);
+				PATCH_OPTION(auth_plain_groupfile);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("auth.backend.plain.userfile"))) {
-				PATCH(auth_plain_userfile);
+				PATCH_OPTION(auth_plain_userfile);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("auth.backend.htdigest.userfile"))) {
-				PATCH(auth_htdigest_userfile);
+				PATCH_OPTION(auth_htdigest_userfile);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("auth.backend.htpasswd.userfile"))) {
-				PATCH(auth_htpasswd_userfile);
+				PATCH_OPTION(auth_htpasswd_userfile);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("auth.require"))) {
-				PATCH(auth_require);
+				PATCH_OPTION(auth_require);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("auth.debug"))) {
-				PATCH(auth_debug);
+				PATCH_OPTION(auth_debug);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("auth.backend.ldap.hostname"))) {
-				PATCH(auth_ldap_hostname);
+				PATCH_OPTION(auth_ldap_hostname);
 #ifdef USE_LDAP
-				PATCH(ldap);
-				PATCH(ldap_filter_pre);
-				PATCH(ldap_filter_post);
+				PATCH_OPTION(ldap);
+				PATCH_OPTION(ldap_filter_pre);
+				PATCH_OPTION(ldap_filter_post);
 #endif
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("auth.backend.ldap.base-dn"))) {
-				PATCH(auth_ldap_basedn);
+				PATCH_OPTION(auth_ldap_basedn);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("auth.backend.ldap.filter"))) {
-				PATCH(auth_ldap_filter);
+				PATCH_OPTION(auth_ldap_filter);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("auth.backend.ldap.ca-file"))) {
-				PATCH(auth_ldap_cafile);
+				PATCH_OPTION(auth_ldap_cafile);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("auth.backend.ldap.starttls"))) {
-				PATCH(auth_ldap_starttls);
+				PATCH_OPTION(auth_ldap_starttls);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 static handler_t mod_auth_uri_handler(server *srv, connection *con, void *p_d) {
 	size_t k;
--- lighttpd-1.4.11/src/mod_cgi.c	2006-02-22 15:15:10.000000000 +0200
+++ lighttpd/src/mod_cgi.c	2006-07-11 21:23:39.887842700 +0300
@@ -1,21 +1,8 @@
 #include <sys/types.h>
-#ifdef __WIN32
-#include <winsock2.h>
-#else
-#include <sys/socket.h>
-#include <sys/wait.h>
-#include <sys/mman.h>
-
-#include <netinet/in.h>
-
-#include <arpa/inet.h>
-#endif
 
-#include <unistd.h>
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
-#include <fdevent.h>
 #include <signal.h>
 #include <ctype.h>
 #include <assert.h>
@@ -29,9 +16,16 @@
 #include "connections.h"
 #include "joblist.h"
 #include "http_chunk.h"
+#include "fdevent.h"
 
 #include "plugin.h"
 
+#include "sys-files.h"
+#include "sys-mmap.h"
+#include "sys-socket.h"
+#include "sys-strings.h"
+#include "sys-process.h"
+
 #ifdef HAVE_SYS_FILIO_H
 # include <sys/filio.h>
 #endif
@@ -45,6 +39,7 @@
 	size_t used;
 } char_array;
 
+#define pid_t int
 typedef struct {
 	pid_t *ptr;
 	size_t used;
@@ -478,7 +473,7 @@
 	
 	if (con->mode != p->id) return HANDLER_GO_ON;
 
-#ifndef __WIN32
+#ifndef _WIN32
 	
 	/* the connection to the browser went away, but we still have a connection
 	 * to the CGI script 
@@ -509,6 +504,7 @@
 	/* if waitpid hasn't been called by response.c yet, do it here */
 	if (pid) {
 		/* check if the CGI-script is already gone */
+#ifndef _WIN32
 		switch(waitpid(pid, &status, WNOHANG)) {
 		case 0:
 			/* not finished yet */
@@ -558,7 +554,7 @@
 		
 	
 		kill(pid, SIGTERM);
-		
+#endif
 		/* cgi-script is still alive, queue the PID for removal */
 		cgi_pid_add(srv, p, pid);
 	}
@@ -695,7 +691,7 @@
 	int from_cgi_fds[2];
 	struct stat st;
 	
-#ifndef __WIN32	
+#ifndef _WIN32
 	
 	if (cgi_handler->used > 1) {
 		/* stat the exec file */
@@ -811,6 +807,9 @@
 		cgi_env_add(&env, CONST_STR_LEN("REDIRECT_STATUS"), CONST_STR_LEN("200"));
 		if (!buffer_is_empty(con->uri.query)) {
 			cgi_env_add(&env, CONST_STR_LEN("QUERY_STRING"), CONST_BUF_LEN(con->uri.query));
+		} else {
+			/* set a empty QUERY_STRING */
+			cgi_env_add(&env, CONST_STR_LEN("QUERY_STRING"), CONST_STR_LEN(""));
 		}
 		if (!buffer_is_empty(con->request.orig_uri)) {
 			cgi_env_add(&env, CONST_STR_LEN("REQUEST_URI"), CONST_BUF_LEN(con->request.orig_uri));
@@ -1101,13 +1100,11 @@
 #endif
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_cgi_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(cgi);
+	PATCH_OPTION(cgi);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -1122,14 +1119,13 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("cgi.assign"))) {
-				PATCH(cgi);
+				PATCH_OPTION(cgi);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 URIHANDLER_FUNC(cgi_is_handled) {
 	size_t k, s_len;
@@ -1168,7 +1164,7 @@
 	plugin_data *p = p_d;
 	size_t ndx;
 	/* the trigger handle only cares about lonely PID which we have to wait for */
-#ifndef __WIN32
+#ifndef _WIN32
 
 	for (ndx = 0; ndx < p->cgi_pid.used; ndx++) {
 		int status;
@@ -1218,7 +1214,7 @@
 	log_error_write(srv, __FILE__, __LINE__, "sdd", "subrequest, pid =", hctx, hctx->pid);
 #endif	
 	if (hctx->pid == 0) return HANDLER_FINISHED;
-#ifndef __WIN32	
+#ifndef _WIN32
 	switch(waitpid(hctx->pid, &status, WNOHANG)) {
 	case 0:
 		/* we only have for events here if we don't have the header yet,
--- lighttpd-1.4.11/src/mod_cml.c	2006-01-30 13:51:48.000000000 +0200
+++ lighttpd/src/mod_cml.c	2006-07-11 21:23:39.931845456 +0300
@@ -4,7 +4,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <errno.h>
-#include <unistd.h>
 #include <stdio.h>
 
 #include "buffer.h"
@@ -135,18 +134,16 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_cml_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(ext);
+	PATCH_OPTION(ext);
 #if defined(HAVE_MEMCACHE_H)
-	PATCH(mc);
+	PATCH_OPTION(mc);
 #endif
-	PATCH(mc_namespace);
-	PATCH(power_magnet);
+	PATCH_OPTION(mc_namespace);
+	PATCH_OPTION(power_magnet);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -161,22 +158,21 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("cml.extension"))) {
-				PATCH(ext);
+				PATCH_OPTION(ext);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("cml.memcache-hosts"))) {
 #if defined(HAVE_MEMCACHE_H)
-				PATCH(mc);
+				PATCH_OPTION(mc);
 #endif
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("cml.memcache-namespace"))) {
-				PATCH(mc_namespace);
+				PATCH_OPTION(mc_namespace);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("cml.power-magnet"))) {
-				PATCH(power_magnet);
+				PATCH_OPTION(power_magnet);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 int cache_call_lua(server *srv, connection *con, plugin_data *p, buffer *cml_file) {
 	buffer *b;
--- lighttpd-1.4.11/src/mod_cml_funcs.c	2005-11-17 16:15:08.000000000 +0200
+++ lighttpd/src/mod_cml_funcs.c	2006-07-11 21:23:40.083854976 +0300
@@ -4,8 +4,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <errno.h>
-#include <unistd.h>
-#include <dirent.h>
+
 #include <stdio.h>
 
 #include "buffer.h"
@@ -13,6 +12,7 @@
 #include "log.h"
 #include "plugin.h"
 #include "response.h"
+#include "sys-files.h"
 
 #include "mod_cml.h"
 #include "mod_cml_funcs.h"
@@ -92,7 +92,7 @@
 	
 	return 1;
 }
-
+#ifndef _WIN32
 int f_dir_files_iter(lua_State *L) {
 	DIR *d;
 	struct dirent *de;
@@ -136,7 +136,7 @@
 	
 	return 1;
 }
-
+#endif
 int f_file_isreg(lua_State *L) {
 	struct stat st;
 	int n = lua_gettop(L);
--- lighttpd-1.4.11/src/mod_cml_lua.c	2006-01-30 13:56:40.000000000 +0200
+++ lighttpd/src/mod_cml_lua.c	2006-07-11 21:23:40.179860989 +0300
@@ -31,6 +31,7 @@
 
 #include <lua.h>
 #include <lualib.h>
+#include <lauxlib.h>
 
 typedef struct {
 	stream st;
@@ -220,13 +221,8 @@
 	stream_open(&rm.st, fn);
 	
 	/* push the lua file to the interpreter and see what happends */
-	L = lua_open();
-	
-	luaopen_base(L);
-	luaopen_table(L);
-	luaopen_string(L);
-	luaopen_math(L);
-	luaopen_io(L);
+	L = luaL_newstate();
+	luaL_openlibs(L);
 	
 	/* register functions */
 	lua_register(L, "md5", f_crypto_md5);
--- lighttpd-1.4.11/src/mod_compress.c	2005-11-18 13:49:14.000000000 +0200
+++ lighttpd/src/mod_compress.c	2006-07-11 21:23:40.139858484 +0300
@@ -2,7 +2,6 @@
 #include <sys/stat.h>
 
 #include <fcntl.h>
-#include <unistd.h>
 #include <ctype.h>
 #include <stdlib.h>
 #include <string.h>
@@ -14,6 +13,7 @@
 #include "buffer.h"
 #include "response.h"
 #include "stat_cache.h"
+#include "http_chunk.h"
 
 #include "plugin.h"
 
@@ -33,6 +33,7 @@
 #endif
 
 #include "sys-mmap.h"
+#include "sys-files.h"
 
 /* request: accept-encoding */
 #define HTTP_ACCEPT_ENCODING_IDENTITY BV(0)
@@ -102,6 +103,28 @@
 	return HANDLER_GO_ON;
 }
 
+void mkdir_recursive(const char *dir) {
+
+	char dir_copy[256];
+	char *p = dir_copy;
+
+	if (!dir || !dir[0])
+		return;
+
+	strncpy(dir_copy, dir, sizeof(dir_copy) / sizeof(dir_copy[0]));
+
+	while ((p = strchr(p + 1, '/')) != NULL) {
+
+		*p = '\0';
+		if ((mkdir(dir_copy, 0700) != 0) && (errno != EEXIST))
+			return;
+
+		*p++ = '/';
+	}
+
+	mkdir(dir, 0700);
+}
+
 SETDEFAULTS_FUNC(mod_compress_setdefaults) {
 	plugin_data *p = p_d;
 	size_t i = 0;
@@ -136,13 +159,21 @@
 		if (!buffer_is_empty(s->compress_cache_dir)) {
 			struct stat st;
 			if (0 != stat(s->compress_cache_dir->ptr, &st)) {
-				log_error_write(srv, __FILE__, __LINE__, "sbs", "can't stat compress.cache-dir", 
+
+				log_error_write(srv, __FILE__, __LINE__, "sbs", "can't stat compress.cache-dir, attempting to create",
+						s->compress_cache_dir, strerror(errno));
+				mkdir_recursive(s->compress_cache_dir->ptr);
+
+				if (0 != stat(s->compress_cache_dir->ptr, &st)) {
+
+					log_error_write(srv, __FILE__, __LINE__, "sbs", "can't stat compress.cache-dir, create failed",
 						s->compress_cache_dir, strerror(errno));
 				
 				return HANDLER_ERROR;
 			}
 		}
 	}
+	}
 	
 	return HANDLER_GO_ON;
 	
@@ -326,6 +357,9 @@
 	void *start;
 	const char *filename = fn->ptr;
 	ssize_t r;
+	stat_cache_entry *compressed_sce = NULL;
+
+	if (buffer_is_empty(p->conf.compress_cache_dir)) return -1;
 	
 	/* overflow */
 	if ((off_t)(sce->st.st_size * 1.1) < sce->st.st_size) return -1;
@@ -339,7 +373,7 @@
 	
 	buffer_reset(p->ofn);
 	buffer_copy_string_buffer(p->ofn, p->conf.compress_cache_dir);
-	BUFFER_APPEND_SLASH(p->ofn);
+	PATHNAME_APPEND_SLASH(p->ofn);
 	
 	if (0 == strncmp(con->physical.path->ptr, con->physical.doc_root->ptr, con->physical.doc_root->used-1)) {
 		size_t offset = p->ofn->used - 1;
@@ -384,26 +418,33 @@
 	
 	buffer_append_string_buffer(p->ofn, sce->etag);
 	
+
+	if (HANDLER_ERROR != stat_cache_get_entry(srv, con, p->ofn, &compressed_sce)) {
+		/* file exists */
+
+		http_chunk_append_file(srv, con, p->ofn, 0, compressed_sce->st.st_size);
+		con->file_finished = 1;
+
+		return 0;
+	}
+
 	if (-1 == (ofd = open(p->ofn->ptr, O_WRONLY | O_CREAT | O_EXCL | O_BINARY, 0600))) {
 		if (errno == EEXIST) {
 			/* cache-entry exists */
-#if 0
-			log_error_write(srv, __FILE__, __LINE__, "bs", p->ofn, "compress-cache hit");
-#endif
-			buffer_copy_string_buffer(con->physical.path, p->ofn);
 			
-			return 0;
 		}
 		
-		log_error_write(srv, __FILE__, __LINE__, "sbss", "creating cachefile", p->ofn, "failed", strerror(errno));
+		log_error_write(srv, __FILE__, __LINE__, "sbss",
+				"creating cachefile", p->ofn,
+				"failed", strerror(errno));
 		
 		return -1;
 	}
-#if 0
-	log_error_write(srv, __FILE__, __LINE__, "bs", p->ofn, "compress-cache miss");
-#endif	
+
 	if (-1 == (ifd = open(filename, O_RDONLY | O_BINARY))) {
-		log_error_write(srv, __FILE__, __LINE__, "sbss", "opening plain-file", fn, "failed", strerror(errno));
+		log_error_write(srv, __FILE__, __LINE__, "sbss",
+				"opening plain-file", fn,
+				"failed", strerror(errno));
 		
 		close(ofd);
 		
@@ -412,7 +453,9 @@
 	
 	
 	if (MAP_FAILED == (start = mmap(NULL, sce->st.st_size, PROT_READ, MAP_SHARED, ifd, 0))) {
-		log_error_write(srv, __FILE__, __LINE__, "sbss", "mmaping", fn, "failed", strerror(errno));
+		log_error_write(srv, __FILE__, __LINE__, "sbss",
+				"mmaping", fn,
+				"failed", strerror(errno));
 		
 		close(ofd);
 		close(ifd);
@@ -455,7 +498,8 @@
 	
 	if (ret != 0) return -1;
 	
-	buffer_copy_string_buffer(con->physical.path, p->ofn);
+	http_chunk_append_file(srv, con, p->ofn, 0, r);
+	con->file_finished = 1;
 	
 	return 0;
 }
@@ -476,18 +520,19 @@
 	
 	if (sce->st.st_size > 128 * 1024 * 1024) return -1;
 	
-	
 	if (-1 == (ifd = open(fn->ptr, O_RDONLY | O_BINARY))) {
 		log_error_write(srv, __FILE__, __LINE__, "sbss", "opening plain-file", fn, "failed", strerror(errno));
 		
 		return -1;
 	}
 	
+	start = mmap(NULL, sce->st.st_size, PROT_READ, MAP_SHARED, ifd, 0);
 	
-	if (MAP_FAILED == (start = mmap(NULL, sce->st.st_size, PROT_READ, MAP_SHARED, ifd, 0))) {
+	close(ifd);
+
+	if (MAP_FAILED == start) {
 		log_error_write(srv, __FILE__, __LINE__, "sbss", "mmaping", fn, "failed", strerror(errno));
 		
-		close(ifd);
 		return -1;
 	}
 	
@@ -511,7 +556,6 @@
 	}
 		
 	munmap(start, sce->st.st_size);
-	close(ifd);
 	
 	if (ret != 0) return -1;
 	
@@ -527,16 +571,13 @@
 	return 0;
 }
 
-
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_compress_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 
-	PATCH(compress_cache_dir);
-	PATCH(compress);
-	PATCH(compress_max_filesize);
+	PATCH_OPTION(compress_cache_dir);
+	PATCH_OPTION(compress);
+	PATCH_OPTION(compress_max_filesize);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -551,18 +592,17 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("compress.cache-dir"))) {
-				PATCH(compress_cache_dir);
+				PATCH_OPTION(compress_cache_dir);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("compress.filetype"))) {
-				PATCH(compress);
+				PATCH_OPTION(compress);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("compress.max-filesize"))) {
-				PATCH(compress_max_filesize);
+				PATCH_OPTION(compress_max_filesize);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 PHYSICALPATH_FUNC(mod_compress_physical) {
 	plugin_data *p = p_d;
@@ -589,6 +629,9 @@
 	/* don't compress files that are too large as we need to much time to handle them */
 	if (max_fsize && (sce->st.st_size >> 10) > max_fsize) return HANDLER_GO_ON;
 		
+	/* compressing the file might lead to larger files instead */
+	if (sce->st.st_size < 128) return HANDLER_GO_ON;
+
 	/* check if mimetype is in compress-config */
 	for (m = 0; m < p->conf.compress->used; m++) {
 		data_string *compress_ds = (data_string *)p->conf.compress->data[m];
@@ -638,6 +681,19 @@
 					
 					const char *compression_name = NULL;
 					int compression_type = 0;
+					buffer *mtime;
+
+					mtime = strftime_cache_get(srv, sce->st.st_mtime);
+					etag_mutate(con->physical.etag, sce->etag);
+
+					response_header_overwrite(srv, con, CONST_STR_LEN("Last-Modified"), CONST_BUF_LEN(mtime));
+					response_header_overwrite(srv, con, CONST_STR_LEN("ETag"), CONST_BUF_LEN(con->physical.etag));
+
+					/* perhaps we don't even have to compress the file as the browser still has the
+					 * current version */
+					if (HANDLER_FINISHED == http_response_handle_cachable(srv, con, mtime)) {
+						return HANDLER_FINISHED;
+					}
 					
 					/* select best matching encoding */
 					if (matched_encodings & HTTP_ACCEPT_ENCODING_BZIP2) {
@@ -651,29 +707,19 @@
 						compression_name = dflt_deflate;
 					}
 					
-					/* deflate it */
-					if (p->conf.compress_cache_dir->used) {
+					/* deflate it to file (cached) or to memory */
 						if (0 == deflate_file_to_file(srv, con, p,
-									      con->physical.path, sce, compression_type)) {
-							buffer *mtime;
-							
-							response_header_overwrite(srv, con, CONST_STR_LEN("Content-Encoding"), compression_name, strlen(compression_name));
-							
-							mtime = strftime_cache_get(srv, sce->st.st_mtime);
-							response_header_overwrite(srv, con, CONST_STR_LEN("Last-Modified"), CONST_BUF_LEN(mtime));
-
-							etag_mutate(con->physical.etag, sce->etag);
-							response_header_overwrite(srv, con, CONST_STR_LEN("ETag"), CONST_BUF_LEN(con->physical.etag));
-
-							response_header_overwrite(srv, con, CONST_STR_LEN("Content-Type"), CONST_BUF_LEN(sce->content_type));
-
-							return HANDLER_GO_ON;
-						}
-					} else if (0 == deflate_file_to_buffer(srv, con, p,
+							con->physical.path, sce, compression_type) ||
+					    0 == deflate_file_to_buffer(srv, con, p,
 									       con->physical.path, sce, compression_type)) {
 							
-						response_header_overwrite(srv, con, CONST_STR_LEN("Content-Encoding"), compression_name, strlen(compression_name));
-						response_header_overwrite(srv, con, CONST_STR_LEN("Content-Type"), CONST_BUF_LEN(sce->content_type));
+						response_header_overwrite(srv, con,
+								CONST_STR_LEN("Content-Encoding"),
+								compression_name, strlen(compression_name));
+
+						response_header_overwrite(srv, con,
+								CONST_STR_LEN("Content-Type"),
+								CONST_BUF_LEN(sce->content_type));
 						
 						return HANDLER_FINISHED;
 					}
--- lighttpd-1.4.11/src/mod_dirlisting.c	2006-01-13 00:00:45.000000000 +0200
+++ lighttpd/src/mod_dirlisting.c	2006-07-11 21:23:40.247865249 +0300
@@ -1,11 +1,9 @@
 #include <ctype.h>
 #include <stdlib.h>
 #include <string.h>
-#include <dirent.h>
 #include <assert.h>
 #include <errno.h>
 #include <stdio.h>
-#include <unistd.h>
 #include <time.h>
 
 #include "base.h"
@@ -31,6 +29,9 @@
 #include <attr/attributes.h>
 #endif
 
+#include "sys-files.h"
+#include "sys-strings.h"
+
 /* plugin config for all request/connections */
 
 typedef struct {
@@ -292,21 +293,19 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_dirlisting_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 
-	PATCH(dir_listing);
-	PATCH(external_css);
-	PATCH(hide_dot_files);
-	PATCH(encoding);
-	PATCH(show_readme);
-	PATCH(hide_readme_file);
-	PATCH(show_header);
-	PATCH(hide_header_file);
-	PATCH(excludes);
+	PATCH_OPTION(dir_listing);
+	PATCH_OPTION(external_css);
+	PATCH_OPTION(hide_dot_files);
+	PATCH_OPTION(encoding);
+	PATCH_OPTION(show_readme);
+	PATCH_OPTION(hide_readme_file);
+	PATCH_OPTION(show_header);
+	PATCH_OPTION(hide_header_file);
+	PATCH_OPTION(excludes);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -322,30 +321,29 @@
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("dir-listing.activate")) ||
 			    buffer_is_equal_string(du->key, CONST_STR_LEN("server.dir-listing"))) {
-				PATCH(dir_listing);
+				PATCH_OPTION(dir_listing);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("dir-listing.hide-dotfiles"))) {
-				PATCH(hide_dot_files);
+				PATCH_OPTION(hide_dot_files);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("dir-listing.external-css"))) {
-				PATCH(external_css);
+				PATCH_OPTION(external_css);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("dir-listing.encoding"))) {
-				PATCH(encoding);
+				PATCH_OPTION(encoding);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("dir-listing.show-readme"))) {
-				PATCH(show_readme);
+				PATCH_OPTION(show_readme);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("dir-listing.hide-readme-file"))) {
-				PATCH(hide_readme_file);
+				PATCH_OPTION(hide_readme_file);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("dir-listing.show-header"))) {
-				PATCH(show_header);
+				PATCH_OPTION(show_header);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("dir-listing.hide-header-file"))) {
-				PATCH(hide_header_file);
+				PATCH_OPTION(hide_header_file);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("dir-listing.excludes"))) {
-				PATCH(excludes);
+				PATCH_OPTION(excludes);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 typedef struct {
 	size_t  namelen;
@@ -494,7 +492,7 @@
 		/* if we have a HEADER file, display it in <pre class="header"></pre> */
 		
 		buffer_copy_string_buffer(p->tmp_buf, con->physical.path);
-		BUFFER_APPEND_SLASH(p->tmp_buf);
+		PATHNAME_APPEND_SLASH(p->tmp_buf);
 		BUFFER_APPEND_STRING_CONST(p->tmp_buf, "HEADER.txt");
 		
 		if (-1 != stream_open(&s, p->tmp_buf)) {
@@ -543,7 +541,7 @@
 		/* if we have a README file, display it in <pre class="readme"></pre> */
 		
 		buffer_copy_string_buffer(p->tmp_buf,  con->physical.path);
-		BUFFER_APPEND_SLASH(p->tmp_buf);
+		PATHNAME_APPEND_SLASH(p->tmp_buf);
 		BUFFER_APPEND_STRING_CONST(p->tmp_buf, "README.txt");
 		
 		if (-1 != stream_open(&s, p->tmp_buf)) {
@@ -606,7 +604,7 @@
 		name_max = 256; /* stupid default */
 #endif
 	}
-#elif defined __WIN32
+#elif defined _WIN32
 	name_max = FILENAME_MAX;
 #else
 	name_max = NAME_MAX;
@@ -615,6 +613,11 @@
 	path = malloc(dir->used + name_max);
 	assert(path);
 	strcpy(path, dir->ptr);
+#ifdef _WIN32
+    /* append \*.* to the path and keep the \ as part of the pathname */
+    strcat(path, "\\*.*");
+    i++;
+#endif
 	path_file = path + i;
 
 	if (NULL == (dp = opendir(path))) {
@@ -693,8 +696,10 @@
 		if (i > (size_t)name_max) continue;
 		
 		memcpy(path_file, dent->d_name, i + 1);
-		if (stat(path, &st) != 0)
+		if (stat(path, &st) != 0) {
+            fprintf(stderr, "%s.%d: %s, %s\r\n", __FILE__, __LINE__, path, strerror(errno));
 			continue;
+        }
 
 		list = &files;
 		if (S_ISDIR(st.st_mode))
--- lighttpd-1.4.11/src/mod_evasive.c	2006-01-04 15:24:51.000000000 +0200
+++ lighttpd/src/mod_evasive.c	2006-07-11 21:23:40.187861491 +0300
@@ -96,13 +96,11 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_evasive_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 
-	PATCH(max_conns);
+	PATCH_OPTION(max_conns);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -117,14 +115,13 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("evasive.max-conns-per-ip"))) {
-				PATCH(max_conns);
+				PATCH_OPTION(max_conns);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 URIHANDLER_FUNC(mod_evasive_uri_handler) {
 	plugin_data *p = p_d;
--- lighttpd-1.4.11/src/mod_evhost.c	2005-08-17 10:42:03.000000000 +0300
+++ lighttpd/src/mod_evhost.c	2006-07-11 21:23:39.991849214 +0300
@@ -7,6 +7,8 @@
 #include "response.h"
 #include "stat_cache.h"
 
+#include "sys-files.h"
+
 typedef struct {
 	/* unparsed pieces */
 	buffer *path_pieces_raw;
@@ -221,14 +223,12 @@
 	return 0;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_evhost_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(path_pieces);
-	PATCH(len);
+	PATCH_OPTION(path_pieces);
+	PATCH_OPTION(len);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -243,16 +243,14 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("evhost.path-pattern"))) {
-				PATCH(path_pieces);
-				PATCH(len);
+				PATCH_OPTION(path_pieces);
+				PATCH_OPTION(len);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
-
 
 static handler_t mod_evhost_uri_handler(server *srv, connection *con, void *p_d) {
 	plugin_data *p = p_d;
@@ -299,7 +297,7 @@
 		}
 	}
 	
-	BUFFER_APPEND_SLASH(p->tmp_buf);
+	PATHNAME_APPEND_SLASH(p->tmp_buf);
 	
 	array_free(parsed_host);
 	
--- lighttpd-1.4.11/src/mod_expire.c	2005-11-03 09:52:13.000000000 +0200
+++ lighttpd/src/mod_expire.c	2006-07-11 21:23:40.103856229 +0300
@@ -245,13 +245,11 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_expire_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(expire_url);
+	PATCH_OPTION(expire_url);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -266,14 +264,13 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("expire.url"))) {
-				PATCH(expire_url);
+				PATCH_OPTION(expire_url);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 URIHANDLER_FUNC(mod_expire_path_handler) {
 	plugin_data *p = p_d;
--- lighttpd-1.4.11/src/mod_fastcgi.c	2006-03-09 13:18:39.000000000 +0200
+++ lighttpd/src/mod_fastcgi.c	2006-07-11 21:23:40.207862743 +0300
@@ -1,5 +1,4 @@
 #include <sys/types.h>
-#include <unistd.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <string.h>
@@ -24,7 +23,7 @@
 #include "inet_ntop_cache.h"
 #include "stat_cache.h"
 
-#include <fastcgi.h>
+#include "fastcgi.h"
 #include <stdio.h>
 
 #ifdef HAVE_SYS_FILIO_H
@@ -32,7 +31,11 @@
 #endif
 
 #include "sys-socket.h"
+#include "sys-files.h"
+#include "sys-strings.h"
+#include "sys-process.h"
 
+#include "http_resp.h"
 
 #ifndef UNIX_PATH_MAX
 # define UNIX_PATH_MAX 108
@@ -45,7 +48,6 @@
 #include <sys/wait.h>
 #endif
 
-
 /*
  * 
  * TODO:
@@ -310,10 +312,11 @@
 	buffer *fcgi_env;
 	
 	buffer *path;
-	buffer *parse_response;
 
 	buffer *statuskey;
 	
+	http_resp *resp;
+
 	plugin_config **config_storage;
 	
 	plugin_config conf; /* this is only used as long as no handler_ctx is setup */
@@ -339,11 +342,10 @@
 	
 	int      reconnects; /* number of reconnect attempts */
 	
-	chunkqueue *rb; /* read queue */
+	chunkqueue *rb; /* the raw fcgi read-queue */
+	chunkqueue *http_rb; /* the decoded read-queue for http-parsing */
 	chunkqueue *wb; /* write queue */
 	
-	buffer   *response_header;
-	
 	size_t    request_id;
 	int       fd;        /* fd to the fastcgi process */
 	int       fde_ndx;   /* index into the fd-event buffer */
@@ -451,8 +453,6 @@
 	
 	hctx->fde_ndx = -1;
 	
-	hctx->response_header = buffer_init();
-	
 	hctx->request_id = 0;
 	hctx->state = FCGI_STATE_INIT;
 	hctx->proc = NULL;
@@ -463,6 +463,7 @@
 	hctx->send_content_body = 1;
 
 	hctx->rb = chunkqueue_init();
+	hctx->http_rb = chunkqueue_init();
 	hctx->wb = chunkqueue_init();
 	
 	return hctx;
@@ -474,9 +475,8 @@
 		hctx->host = NULL;
 	}
 	
-	buffer_free(hctx->response_header);
-
 	chunkqueue_free(hctx->rb);
+	chunkqueue_free(hctx->http_rb);
 	chunkqueue_free(hctx->wb);
 
 	free(hctx);
@@ -639,7 +639,8 @@
 	p->fcgi_env = buffer_init();
 	
 	p->path = buffer_init();
-	p->parse_response = buffer_init();
+
+	p->resp = http_response_init();
 
 	p->statuskey = buffer_init();
 	
@@ -657,9 +658,10 @@
 	
 	buffer_free(p->fcgi_env);
 	buffer_free(p->path);
-	buffer_free(p->parse_response);
 	buffer_free(p->statuskey);
 	
+	http_response_free(p->resp);
+
 	if (p->config_storage) {
 		size_t i, j, n;
 		for (i = 0; i < srv->config_context->used; i++) {
@@ -825,12 +827,8 @@
 		fcgi_addr_un.sun_family = AF_UNIX;
 		strcpy(fcgi_addr_un.sun_path, proc->unixsocket->ptr);
 		
-#ifdef SUN_LEN
 		servlen = SUN_LEN(&fcgi_addr_un);
-#else
-		/* stevens says: */
-		servlen = proc->unixsocket->used + sizeof(fcgi_addr_un.sun_family);
-#endif
+
 		socket_type = AF_UNIX;
 		fcgi_addr = (struct sockaddr *) &fcgi_addr_un;
 
@@ -933,7 +931,7 @@
 			return -1;
 		}
 		
-#ifdef HAVE_FORK	
+#ifndef _WIN32
 		switch ((child = fork())) {
 		case 0: {
 			size_t i = 0;
@@ -1677,12 +1675,9 @@
 		/* use the unix domain socket */
 		fcgi_addr_un.sun_family = AF_UNIX;
 		strcpy(fcgi_addr_un.sun_path, proc->unixsocket->ptr);
-#ifdef SUN_LEN
+
 		servlen = SUN_LEN(&fcgi_addr_un);
-#else
-		/* stevens says: */
-		servlen = proc->unixsocket->used + sizeof(fcgi_addr_un.sun_family);
-#endif
+
 		fcgi_addr = (struct sockaddr *) &fcgi_addr_un;
 	
 		if (buffer_is_empty(proc->connection_name)) {
@@ -1695,6 +1690,7 @@
 #endif
 	} else {
 		fcgi_addr_in.sin_family = AF_INET;
+
 		if (0 == inet_aton(host->host->ptr, &(fcgi_addr_in.sin_addr))) {
 			log_error_write(srv, __FILE__, __LINE__, "sbs", 
 					"converting IP-adress failed for", host->host, 
@@ -1702,6 +1698,7 @@
 			
 			return -1;
 		}
+
 		fcgi_addr_in.sin_port = htons(proc->port);
 		servlen = sizeof(fcgi_addr_in);
 		
@@ -2186,105 +2183,6 @@
 	return 0;
 }
 
-static int fcgi_response_parse(server *srv, connection *con, plugin_data *p, buffer *in) {
-	char *s, *ns;
-	
-	handler_ctx *hctx = con->plugin_ctx[p->id];
-	fcgi_extension_host *host= hctx->host;
-	
-	UNUSED(srv);
-
-	buffer_copy_string_buffer(p->parse_response, in);
-	
-	/* search for \n */
-	for (s = p->parse_response->ptr; NULL != (ns = strchr(s, '\n')); s = ns + 1) {
-		char *key, *value;
-		int key_len;
-		data_string *ds;
-		
-		/* a good day. Someone has read the specs and is sending a \r\n to us */
-		
-		if (ns > p->parse_response->ptr &&
-		    *(ns-1) == '\r') {
-			*(ns-1) = '\0';
-		}
-		
-		ns[0] = '\0';
-		
-		key = s;
-		if (NULL == (value = strchr(s, ':'))) {
-			/* we expect: "<key>: <value>\n" */
-			continue;
-		}
-		
-		key_len = value - key;
-		
-		value++;
-		/* strip WS */
-		while (*value == ' ' || *value == '\t') value++;
-		
-		if (host->mode != FCGI_AUTHORIZER ||
-		    !(con->http_status == 0 ||
-		      con->http_status == 200)) {
-			/* authorizers shouldn't affect the response headers sent back to the client */
-			
-			/* don't forward Status: */
-			if (0 != strncasecmp(key, "Status", key_len)) {
-				if (NULL == (ds = (data_string *)array_get_unused_element(con->response.headers, TYPE_STRING))) {
-					ds = data_response_init();
-				}
-				buffer_copy_string_len(ds->key, key, key_len);
-				buffer_copy_string(ds->value, value);
-				
-				array_insert_unique(con->response.headers, (data_unset *)ds);
-			}
-		}
-		
-		switch(key_len) {
-		case 4:
-			if (0 == strncasecmp(key, "Date", key_len)) {
-				con->parsed_response |= HTTP_DATE;
-			}
-			break;
-		case 6:
-			if (0 == strncasecmp(key, "Status", key_len)) {
-				con->http_status = strtol(value, NULL, 10);
-				con->parsed_response |= HTTP_STATUS;
-			}
-			break;
-		case 8:
-			if (0 == strncasecmp(key, "Location", key_len)) {
-				con->parsed_response |= HTTP_LOCATION;
-			}
-			break;
-		case 10:
-			if (0 == strncasecmp(key, "Connection", key_len)) {
-				con->response.keep_alive = (0 == strcasecmp(value, "Keep-Alive")) ? 1 : 0;
-				con->parsed_response |= HTTP_CONNECTION;
-			}
-			break;
-		case 14:
-			if (0 == strncasecmp(key, "Content-Length", key_len)) {
-				con->response.content_length = strtol(value, NULL, 10);
-				con->parsed_response |= HTTP_CONTENT_LENGTH;
-				
-				if (con->response.content_length < 0) con->response.content_length = 0;
-			}
-			break;
-		default:
-			break;
-		}
-	}
-	
-	/* CGI/1.1 rev 03 - 7.2.1.2 */
-	if ((con->parsed_response & HTTP_LOCATION) &&
-	    !(con->parsed_response & HTTP_STATUS)) {
-		con->http_status = 302;
-	}
-	
-	return 0;
-}
-
 typedef struct {
 	buffer  *b; 
 	size_t   len;
@@ -2386,52 +2284,24 @@
 
 static int fcgi_demux_response(server *srv, handler_ctx *hctx) {
 	int fin = 0;
-	int toread;
-	ssize_t r;
 	
 	plugin_data *p    = hctx->plugin_data;
 	connection *con   = hctx->remote_conn;
-	int fcgi_fd       = hctx->fd;
 	fcgi_extension_host *host= hctx->host;
 	fcgi_proc *proc   = hctx->proc;
 	
-	/* 
-	 * check how much we have to read 
-	 */
-	if (ioctl(hctx->fd, FIONREAD, &toread)) {
-		log_error_write(srv, __FILE__, __LINE__, "sd", 
-				"unexpected end-of-file (perhaps the fastcgi process died):",
-				fcgi_fd);
-		return -1;
-	}
-	
-	/* init read-buffer */
-	
-	if (toread > 0) {
-		buffer *b;
-
-		b = chunkqueue_get_append_buffer(hctx->rb);
-		buffer_prepare_copy(b, toread + 1);
-
-		/* append to read-buffer */
-		if (-1 == (r = read(hctx->fd, b->ptr, toread))) {
-			log_error_write(srv, __FILE__, __LINE__, "sds", 
-					"unexpected end-of-file (perhaps the fastcgi process died):",
-					fcgi_fd, strerror(errno));
-			return -1;
-		}
-		
-		/* this should be catched by the b > 0 above */
-		assert(r);
-
-		b->used = r + 1; /* one extra for the fake \0 */
-		b->ptr[b->used - 1] = '\0';
-	} else {
+	switch(srv->network_backend_read(srv, con, hctx->fd, hctx->rb)) {
+	case NETWORK_STATUS_WAIT_FOR_EVENT:
+		/* we are only triggered when there is a event */
 		log_error_write(srv, __FILE__, __LINE__, "ssdsb", 
 				"unexpected end-of-file (perhaps the fastcgi process died):",
 				"pid:", proc->pid,
 				"socket:", proc->connection_name);
-		
+		return -1;
+	case NETWORK_STATUS_SUCCESS:
+		break;
+	default:
+		log_error_write(srv, __FILE__, __LINE__, "s", "fastcgi-read failed");
 		return -1;
 	}
 
@@ -2454,80 +2324,123 @@
 
 			/* is the header already finished */
 			if (0 == con->file_started) {
-				char *c;
-				size_t blen;
-				data_string *ds;
-					
-				/* search for header terminator 
-				 * 
-				 * if we start with \r\n check if last packet terminated with \r\n
-				 * if we start with \n check if last packet terminated with \n
-				 * search for \r\n\r\n
-				 * search for \n\n
-				 */
-
-				if (hctx->response_header->used == 0) {
-					buffer_copy_string_buffer(hctx->response_header, packet.b);
-				} else {
-					buffer_append_string_buffer(hctx->response_header, packet.b);
-				}
+				int have_content_length = 0;
+				int need_more = 0;
+				size_t i;
 
-				if (NULL != (c = buffer_search_string_len(hctx->response_header, CONST_STR_LEN("\r\n\r\n")))) {
-					blen = hctx->response_header->used - (c - hctx->response_header->ptr) - 4;
-					hctx->response_header->used = (c - hctx->response_header->ptr) + 3;
-					c += 4; /* point the the start of the response */
-				} else if (NULL != (c = buffer_search_string_len(hctx->response_header, CONST_STR_LEN("\n\n")))) {
-					blen = hctx->response_header->used - (c - hctx->response_header->ptr) - 2;
-					hctx->response_header->used = c - hctx->response_header->ptr + 2;
-					c += 2; /* point the the start of the response */
-				} else {
-					/* no luck, no header found */
+				/* append the current packet to the chunk queue */
+				chunkqueue_append_buffer(hctx->http_rb, packet.b);
+				http_response_reset(p->resp);
+
+				switch(http_response_parse_cq(hctx->http_rb, p->resp)) {
+				case PARSE_ERROR:
+					/* parsing the response header failed */
+
+					con->http_status = 502; /* Bad Gateway */
+
+					return 1;
+				case PARSE_NEED_MORE:
+					need_more = 1;
+					break; /* leave the loop */
+				case PARSE_SUCCESS:
 					break;
+				default:
+					/* should not happen */
+					SEGFAULT();
 				}
 
-				/* parse the response header */
-				fcgi_response_parse(srv, con, p, hctx->response_header);
+				if (need_more) break;
 
-				con->file_started = 1;
+				chunkqueue_remove_finished_chunks(hctx->http_rb);
 
-				if (host->mode == FCGI_AUTHORIZER &&
-				    (con->http_status == 0 ||
-				     con->http_status == 200)) {
+				con->http_status = p->resp->status;
+
+				/* handle the header fields */
+				if (host->mode == FCGI_AUTHORIZER) {
+					/* auth mode is a bit different */
+
+    					if (con->http_status == 0 ||
+					    con->http_status == 200) {
 					/* a authorizer with approved the static request, ignore the content here */
 					hctx->send_content_body = 0;
 				}
+				}
 
-				if (host->allow_xsendfile &&
-				    NULL != (ds = (data_string *) array_get_element(con->response.headers, "X-LIGHTTPD-send-file"))) {
-					stat_cache_entry *sce;
+				/* copy the http-headers */
+				for (i = 0; i < p->resp->headers->used; i++) {
+					const char *ign[] = { "Status", NULL };
+					size_t j;
+					data_string *ds;
 
-					if (HANDLER_ERROR != stat_cache_get_entry(srv, con, ds->value, &sce)) {
-						/* found */
+					data_string *header = (data_string *)p->resp->headers->data[i];
+
+					/* ignore all headers in AUTHORIZER mode */
+					if (host->mode == FCGI_AUTHORIZER) continue;
+
+					/* some headers are ignored by default */
+					for (j = 0; ign[j]; j++) {
+						if (0 == strcasecmp(ign[j], header->key->ptr)) break;
+					}
+					if (ign[j]) continue;
+
+					if (0 == buffer_caseless_compare(CONST_BUF_LEN(header->key), CONST_STR_LEN("Location"))) {
+						/* CGI/1.1 rev 03 - 7.2.1.2 */
+						con->http_status = 302;
+					} else if (0 == buffer_caseless_compare(CONST_BUF_LEN(header->key), CONST_STR_LEN("Content-Length"))) {
+						have_content_length = 1;
+					} else if (0 == buffer_caseless_compare(CONST_BUF_LEN(header->key), CONST_STR_LEN("X-Sendfile")) || 
+						   0 == buffer_caseless_compare(CONST_BUF_LEN(header->key), CONST_STR_LEN("X-LIGHTTPD-send-file"))) {
 
-						http_chunk_append_file(srv, con, ds->value, 0, sce->st.st_size);
+						stat_cache_entry *sce;
+						
+						if (host->allow_xsendfile &&
+						    HANDLER_ERROR != stat_cache_get_entry(srv, con, header->value, &sce)) {
+							http_chunk_append_file(srv, con, header->value, 0, sce->st.st_size);
 						hctx->send_content_body = 0; /* ignore the content */
+					
 						joblist_append(srv, con);
 					}
+
+						continue; /* ignore header */
 				}
 
+					if (NULL == (ds = (data_string *)array_get_unused_element(con->response.headers, TYPE_STRING))) {
+						ds = data_response_init();
+					}
+					buffer_copy_string_buffer(ds->key, header->key);
+					buffer_copy_string_buffer(ds->value, header->value);
 						
-				if (hctx->send_content_body && blen > 1) {						
-					/* enable chunked-transfer-encoding */
+					array_insert_unique(con->response.headers, (data_unset *)ds);
+				}
+
+				/* header is complete ... go on with the body */
+
+				con->file_started = 1;
+
+				if (hctx->send_content_body) {
+					chunk *c = hctx->http_rb->first;
+
+					/* if we don't have a content-length enable chunked encoding 
+					 * if possible
+					 * 
+					 * TODO: move this to a later stage in the filter-queue
+					 *  */
 					if (con->request.http_version == HTTP_VERSION_1_1 &&
-					    !(con->parsed_response & HTTP_CONTENT_LENGTH)) {
+					    !have_content_length) {
 						con->response.transfer_encoding = HTTP_TRANSFER_ENCODING_CHUNKED;
 					}
 
-					http_chunk_append_mem(srv, con, c, blen);
+					/* copy the rest of the data */
+					for (c = hctx->http_rb->first; c; c = c->next) {
+						if (c->mem->used > 1) {
+							http_chunk_append_mem(srv, con, c->mem->ptr + c->offset, c->mem->used - c->offset);
+							c->offset = c->mem->used - 1;
+						}
+					}
+					chunkqueue_remove_finished_chunks(hctx->http_rb);
 					joblist_append(srv, con);
 				}
 			} else if (hctx->send_content_body && packet.b->used > 1) {
-				if (con->request.http_version == HTTP_VERSION_1_1 &&
-				    !(con->parsed_response & HTTP_CONTENT_LENGTH)) {
-					/* enable chunked-transfer-encoding */
-					con->response.transfer_encoding = HTTP_TRANSFER_ENCODING_CHUNKED;
-				}
-
 				http_chunk_append_mem(srv, con, packet.b->ptr, packet.b->used);
 				joblist_append(srv, con);
 			}
@@ -2606,7 +2519,7 @@
 			if (!proc->is_local) break;
 
 			/* the child should not terminate at all */
-			
+#ifndef _WIN32
 			switch(waitpid(proc->pid, &status, WNOHANG)) {
 			case 0:
 				/* child is still alive */
@@ -2633,7 +2546,7 @@
 				proc->state = PROC_STATE_DIED;
 				break;
 			}
-
+#endif
 			/* fall through if we have a dead proc now */
 			if (proc->state != PROC_STATE_DIED) break;
 
@@ -2934,10 +2847,11 @@
 				 */ 
 				if (hctx->wb->bytes_out == 0 &&
 				    hctx->reconnects < 5) {
+#ifndef _WIN32
 					usleep(10000); /* take away the load of the webserver 
 							* to let the php a chance to restart 
 							*/
-					
+#endif
 					fcgi_reconnect(srv, hctx);
 				
 					return HANDLER_WAIT_FOR_FD;
@@ -2949,7 +2863,7 @@
 				 * 
 				 */
 				
-				log_error_write(srv, __FILE__, __LINE__, "ssdsd", 
+				log_error_write(srv, __FILE__, __LINE__, "ssosd",
 						"[REPORT ME] connection was dropped after accept(). reconnect() denied:",
 						"write-offset:", hctx->wb->bytes_out,
 						"reconnect attempts:", hctx->reconnects);
@@ -3155,7 +3069,7 @@
 				int status;
 				
 				/* only fetch the zombie if it is not already done */
-				
+#ifndef _WIN32
 				switch(waitpid(proc->pid, &status, WNOHANG)) {
 				case 0:
 					/* child is still alive */
@@ -3195,6 +3109,7 @@
 					
 					break;
 				}
+#endif
 			}
 
 			if (con->file_started == 0) {
@@ -3307,15 +3222,14 @@
 	
 	return HANDLER_FINISHED;
 }
-#define PATCH(x) \
-	p->conf.x = s->x;
+
 static int fcgi_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(exts);
-	PATCH(debug);
-	PATCH(ext_mapping);
+	PATCH_OPTION(exts);
+	PATCH_OPTION(debug);
+	PATCH_OPTION(ext_mapping);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -3330,19 +3244,17 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("fastcgi.server"))) {
-				PATCH(exts);
+				PATCH_OPTION(exts);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("fastcgi.debug"))) {
-				PATCH(debug);
+				PATCH_OPTION(debug);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("fastcgi.map-extensions"))) {
-				PATCH(ext_mapping);
+				PATCH_OPTION(ext_mapping);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
-
 
 static handler_t fcgi_check_extension(server *srv, connection *con, void *p_d, int uri_path_handler) {
 	plugin_data *p = p_d;
@@ -3610,10 +3522,33 @@
 	 * 
 	 * currently we wait for the TCP timeout which is on Linux 180 seconds
 	 * 
-	 * 
-	 * 
 	 */
 
+	for (i = 0; i < srv->conns->used; i++) {
+		connection *con = srv->conns->ptr[i];
+		handler_ctx *hctx = con->plugin_ctx[p->id];
+
+		/* if a connection is ours and is in handle-req for more than max-request-time
+		 * kill the connection */
+
+		if (con->mode != p->id) continue;
+		if (con->state != CON_STATE_HANDLE_REQUEST) continue;
+		if (srv->cur_ts < con->request_start + 60) continue;
+
+		/* the request is waiting for a FCGI_STDOUT since 60 seconds */
+
+		/* kill the connection */
+
+		log_error_write(srv, __FILE__, __LINE__, "s", "fastcgi backend didn't responded after 60 seconds");
+
+		fcgi_connection_close(srv, hctx);
+
+		con->mode = DIRECT;
+		con->http_status = 500;
+
+		joblist_append(srv, con);
+	}
+
 	/* check all childs if they are still up */
 
 	for (i = 0; i < srv->config_context->used; i++) {
@@ -3737,7 +3672,7 @@
 					int status;
 					
 					if (proc->pid == 0) continue;
-					
+#ifndef _WIN32
 					switch (waitpid(proc->pid, &status, WNOHANG)) {
 					case 0:
 						/* child still running after timeout, good */
@@ -3781,6 +3716,7 @@
 						proc->state = PROC_STATE_UNSET;
 						host->max_id--;
 					}
+#endif
 				}
 			}
 		}
--- lighttpd-1.4.11/src/mod_flv_streaming.c	2006-03-07 14:06:26.000000000 +0200
+++ lighttpd/src/mod_flv_streaming.c	2006-07-11 21:23:40.043852471 +0300
@@ -108,13 +108,11 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_flv_streaming_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(extensions);
+	PATCH_OPTION(extensions);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -129,16 +127,15 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("flv-streaming.extensions"))) {
-				PATCH(extensions);
+				PATCH_OPTION(extensions);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
-static int split_get_params(server *srv, connection *con, array *get_params, buffer *qrystr) {
+static int split_get_params(array *get_params, buffer *qrystr) {
 	size_t is_key = 1;
 	size_t i;
 	char *key = NULL, *val = NULL;
@@ -167,7 +164,7 @@
 				/* terminate the value */
 				qrystr->ptr[i] = '\0';
 
-				if (NULL == (ds = (data_string *)array_get_unused_element(con->request.headers, TYPE_STRING))) {
+				if (NULL == (ds = (data_string *)array_get_unused_element(get_params, TYPE_STRING))) {
 					ds = data_string_init();
 				}
 				buffer_copy_string_len(ds->key, key, strlen(key));
@@ -217,7 +214,7 @@
 
 			array_reset(p->get_params);
 			buffer_copy_string_buffer(p->query_str, con->uri.query);
-			split_get_params(srv, con, p->get_params, p->query_str);
+			split_get_params(p->get_params, p->query_str);
 
 			if (NULL == (get_param = (data_string *)array_get_element(p->get_params, "start"))) {
 				return HANDLER_GO_ON;
--- lighttpd-1.4.11/src/mod_indexfile.c	2005-09-30 01:08:53.000000000 +0300
+++ lighttpd/src/mod_indexfile.c	2006-07-11 21:23:40.191861741 +0300
@@ -103,13 +103,11 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_indexfile_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(indexfiles);
+	PATCH_OPTION(indexfiles);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -124,16 +122,15 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("server.indexfiles"))) {
-				PATCH(indexfiles);
+				PATCH_OPTION(indexfiles);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("index-file.names"))) {
-				PATCH(indexfiles);
+				PATCH_OPTION(indexfiles);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 URIHANDLER_FUNC(mod_indexfile_subrequest) {
 	plugin_data *p = p_d;
--- lighttpd-1.4.11/src/mod_mysql_vhost.c	2006-01-14 20:35:10.000000000 +0200
+++ lighttpd/src/mod_mysql_vhost.c	2006-07-11 21:23:40.031851719 +0300
@@ -1,13 +1,18 @@
-#include <unistd.h>
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <strings.h>
+#include <string.h>
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
+#ifdef HAVE_MYSQL_H 
+# ifdef HAVE_LIBMYSQL
+#  define HAVE_MYSQL
+# endif
+#endif
+
 #ifdef HAVE_MYSQL
 #include <mysql.h>
 #endif
@@ -16,36 +21,21 @@
 #include "log.h"
 
 #include "stat_cache.h"
-#ifdef DEBUG_MOD_MYSQL_VHOST
-#define DEBUG
-#endif
+#include "sys-files.h"
 
-/*
- * Plugin for lighttpd to use MySQL 
- *   for domain to directory lookups,
- *   i.e virtual hosts (vhosts).
- *   
- * Optionally sets fcgi_offset and fcgi_arg 
- *   in preparation for fcgi.c to handle 
- *   per-user fcgi chroot jails.
- *
- * /ada@riksnet.se 2004-12-06
- */
+#include "mod_sql_vhost_core.h"
 
 #ifdef HAVE_MYSQL
-typedef struct {
-	MYSQL 	*mysql;
 	
-	buffer  *mydb;
-	buffer  *myuser;
-	buffer  *mypass;
-	buffer  *mysock;
+#define CORE_PLUGIN "mod_sql_vhost_core"
 	
-	buffer  *hostname;
-	unsigned short port;
+typedef struct {
+	MYSQL 	*mysql;
 	
 	buffer  *mysql_pre;
 	buffer  *mysql_post;
+
+	mod_sql_vhost_core_plugin_config *core;
 } plugin_config;
 
 /* global plugin data */
@@ -59,13 +49,7 @@
 	plugin_config conf; 
 } plugin_data;
 
-/* per connection plugin data */
-typedef struct {
-	buffer	*server_name;
-	buffer	*document_root;
-	buffer	*fcgi_arg;
-	unsigned fcgi_offset;
-} plugin_connection_data;
+SQLVHOST_BACKEND_GETVHOST(mod_mysql_vhost_get_vhost); 
 
 /* init the plugin data */
 INIT_FUNC(mod_mysql_vhost_init) {
@@ -84,10 +68,6 @@
 
 	UNUSED(srv);
 	
-#ifdef DEBUG
-	log_error_write(srv, __FILE__, __LINE__, "ss", 
-		"mod_mysql_vhost_cleanup", p ? "yes" : "NO");
-#endif
 	if (!p) return HANDLER_GO_ON;
 	
 	if (p->config_storage) {
@@ -99,10 +79,6 @@
 			
 			mysql_close(s->mysql);
 			
-			buffer_free(s->mydb);
-			buffer_free(s->myuser);
-			buffer_free(s->mypass);
-			buffer_free(s->mysock);
 			buffer_free(s->mysql_pre);
 			buffer_free(s->mysql_post);
 			
@@ -117,109 +93,50 @@
 	return HANDLER_GO_ON;
 }
 
-/* handle the plugin per connection data */
-static void* mod_mysql_vhost_connection_data(server *srv, connection *con, void *p_d)
-{
-	plugin_data *p = p_d;
-	plugin_connection_data *c = con->plugin_ctx[p->id];
-
-	UNUSED(srv);
-
-#ifdef DEBUG
-        log_error_write(srv, __FILE__, __LINE__, "ss", 
-		"mod_mysql_connection_data", c ? "old" : "NEW");
-#endif
-
-	if (c) return c;
-	c = calloc(1, sizeof(*c));
-
-	c->server_name = buffer_init();
-	c->document_root = buffer_init();
-	c->fcgi_arg = buffer_init();
-	c->fcgi_offset = 0;
-
-	return con->plugin_ctx[p->id] = c;
-}
-
-/* destroy the plugin per connection data */
-CONNECTION_FUNC(mod_mysql_vhost_handle_connection_close) {
-	plugin_data *p = p_d;
-	plugin_connection_data *c = con->plugin_ctx[p->id];
-
-	UNUSED(srv);
-
-#ifdef DEBUG
-	log_error_write(srv, __FILE__, __LINE__, "ss", 
-		"mod_mysql_vhost_handle_connection_close", c ? "yes" : "NO");
-#endif
-	
-	if (!c) return HANDLER_GO_ON;
-
-	buffer_free(c->server_name);
-	buffer_free(c->document_root);
-	buffer_free(c->fcgi_arg);
-	c->fcgi_offset = 0;
-
-	free(c);
-
-	con->plugin_ctx[p->id] = NULL;
-	return HANDLER_GO_ON;
-}
-
 /* set configuration values */
 SERVER_FUNC(mod_mysql_vhost_set_defaults) {
 	plugin_data *p = p_d;
+	mod_sql_vhost_core_plugin_data *core_config;
 
-	char *qmark;
 	size_t i = 0;
 
-	config_values_t cv[] = {
-		{ "mysql-vhost.db",	NULL, T_CONFIG_STRING, 	T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.user",	NULL, T_CONFIG_STRING, 	T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.pass",	NULL, T_CONFIG_STRING, 	T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.sock",	NULL, T_CONFIG_STRING, 	T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.sql",	NULL, T_CONFIG_STRING, 	T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.hostname", NULL, T_CONFIG_STRING,T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.port",   NULL, T_CONFIG_SHORT,   T_CONFIG_SCOPE_SERVER },
-                { NULL,			NULL, T_CONFIG_UNSET,	T_CONFIG_SCOPE_UNSET }
-        };
-	
+	/* our very own plugin storage, one entry for each conditional
+	 * 
+	 * srv->config_context->used is the number of conditionals
+	 * */
 	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
 	
+	/* get the config of the core-plugin */
+	core_config = plugin_get_config(srv, CORE_PLUGIN);
+
+
+	/* walk through all conditionals and check for assignments */
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
 		buffer *sel;
+		char *qmark;
 		
-		
+		/* get the config from the core plugin for this conditional-context */
 		s = calloc(1, sizeof(plugin_config));
-		s->mydb = buffer_init();
-		s->myuser = buffer_init();
-		s->mypass = buffer_init();
-		s->mysock = buffer_init();
-		s->hostname = buffer_init();
-		s->port   = 0;               /* default port for mysql */
-		sel = buffer_init();
+
+		s->core = core_config->config_storage[i];
+		
 		s->mysql = NULL;
 		
 		s->mysql_pre = buffer_init();
 		s->mysql_post = buffer_init();
 		
-		cv[0].destination = s->mydb;
-		cv[1].destination = s->myuser;
-		cv[2].destination = s->mypass;
-		cv[3].destination = s->mysock;
-		cv[4].destination = sel;
-		cv[5].destination = s->hostname;
-		cv[6].destination = &(s->port);
-		
 		p->config_storage[i] = s;
 		
-        	if (config_insert_values_global(srv, 
-			((data_config *)srv->config_context->data[i])->value,
-			cv)) return HANDLER_ERROR;
+		/* check if we are the plugin for this backend */
+		if (!buffer_is_equal_string(s->core->backend, CONST_STR_LEN("mysql"))) continue;
 		
-		s->mysql_pre = buffer_init();
-		s->mysql_post = buffer_init();
+		/* attach us to the core-plugin */
+		s->core->backend_data = p;
+		s->core->get_vhost = mod_mysql_vhost_get_vhost;
+
+		sel = buffer_init();
+		buffer_copy_string_buffer(sel, s->core->select_vhost);
 		
 		if (sel->used && (qmark = index(sel->ptr, '?'))) {
 			*qmark = '\0';
@@ -241,8 +158,8 @@
 		 */
 		
 		/* all have to be set */
-		if (!(buffer_is_empty(s->myuser) ||
-		      buffer_is_empty(s->mydb))) {
+		if (!(buffer_is_empty(s->core->user) ||
+		      buffer_is_empty(s->core->db))) {
 
 			int fd;
 		
@@ -251,10 +168,10 @@
 				
 				return HANDLER_ERROR;
 			}
-#define FOO(x) (s->x->used ? s->x->ptr : NULL)
+#define FOO(x) (s->core->x->used ? s->core->x->ptr : NULL)
 			
-			if (!mysql_real_connect(s->mysql, FOO(hostname), FOO(myuser), FOO(mypass), 
-						FOO(mydb), s->port, FOO(mysock), 0)) {
+			if (!mysql_real_connect(s->mysql, FOO(hostname), FOO(user), FOO(pass),
+						FOO(db), s->core->port, FOO(sock), 0)) {
 				log_error_write(srv, __FILE__, __LINE__, "s", mysql_error(s->mysql));
 				
 				return HANDLER_ERROR;
@@ -275,17 +192,13 @@
         return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_mysql_vhost_patch_connection(server *srv, connection *con, plugin_data *p) {
-	size_t i, j;
+	size_t i;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(mysql_pre);
-	PATCH(mysql_post);
-#ifdef HAVE_MYSQL
-	PATCH(mysql);
-#endif
+	PATCH_OPTION(mysql_pre);
+	PATCH_OPTION(mysql_post);
+	PATCH_OPTION(mysql);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -295,31 +208,21 @@
 		/* condition didn't match */
 		if (!config_check_cond(srv, con, dc)) continue;
 		
-		/* merge config */
-		for (j = 0; j < dc->value->used; j++) {
-			data_unset *du = dc->value->data[j];
-			
-			if (buffer_is_equal_string(du->key, CONST_STR_LEN("mysql-vhost.sql"))) {
-				PATCH(mysql_pre);
-				PATCH(mysql_post);
-			}
-		}
-		
 		if (s->mysql) {
-			PATCH(mysql);
+			PATCH_OPTION(mysql);
+			PATCH_OPTION(mysql_pre);
+			PATCH_OPTION(mysql_post);
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
-
-/* handle document root request */
-CONNECTION_FUNC(mod_mysql_vhost_handle_docroot) {
+/**
+ * get the vhost info from the database 
+ */
+SQLVHOST_BACKEND_GETVHOST(mod_mysql_vhost_get_vhost) {
 	plugin_data *p = p_d;
-	plugin_connection_data *c;
-	stat_cache_entry *sce;
 
 	unsigned  cols;
 	MYSQL_ROW row;
@@ -332,13 +235,6 @@
 
 	if (!p->conf.mysql) return HANDLER_GO_ON;
 
-	/* sets up connection data if not done yet */
-	c = mod_mysql_vhost_connection_data(srv, con, p_d);
-
-	/* check if cached this connection */
-	if (c->server_name->used && /* con->uri.authority->used && */
-            buffer_is_equal(c->server_name, con->uri.authority)) goto GO_ON;
-
 	/* build and run SQL query */
 	buffer_copy_string_buffer(p->tmp_buf, p->conf.mysql_pre);
 	if (p->conf.mysql_post->used) {
@@ -347,76 +243,42 @@
 	}
    	if (mysql_query(p->conf.mysql, p->tmp_buf->ptr)) {
 		log_error_write(srv, __FILE__, __LINE__, "s", mysql_error(p->conf.mysql));
-		goto ERR500;
+
+		mysql_free_result(result);
+		return HANDLER_GO_ON;
 	}
 	result = mysql_store_result(p->conf.mysql);
 	cols = mysql_num_fields(result);
 	row = mysql_fetch_row(result);
+
 	if (!row || cols < 1) {
 		/* no such virtual host */
 		mysql_free_result(result);
 		return HANDLER_GO_ON;
 	}
 
-	/* sanity check that really is a directory */
-	buffer_copy_string(p->tmp_buf, row[0]);
-	BUFFER_APPEND_SLASH(p->tmp_buf);
-
-	if (HANDLER_ERROR == stat_cache_get_entry(srv, con, p->tmp_buf, &sce)) {
-		log_error_write(srv, __FILE__, __LINE__, "sb", strerror(errno), p->tmp_buf);
-		goto ERR500;
-	}
-        if (!S_ISDIR(sce->st.st_mode)) {
-		log_error_write(srv, __FILE__, __LINE__, "sb", "Not a directory", p->tmp_buf);
-		goto ERR500;
-	}
-
-	/* cache the data */
-	buffer_copy_string_buffer(c->server_name, con->uri.authority);
-	buffer_copy_string_buffer(c->document_root, p->tmp_buf);
+	buffer_copy_string(docroot, row[0]);
 
-	/* fcgi_offset and fcgi_arg are optional */
-	if (cols > 1 && row[1]) {
-		c->fcgi_offset = atoi(row[1]);
-		
-		if (cols > 2 && row[2]) {
-			buffer_copy_string(c->fcgi_arg, row[2]);
-		} else {
-			c->fcgi_arg->used = 0;
-		}
-	} else {
-		c->fcgi_offset = c->fcgi_arg->used = 0;
-	}
 	mysql_free_result(result);
 
-	/* fix virtual server and docroot */
-GO_ON:	buffer_copy_string_buffer(con->server_name, c->server_name);
-	buffer_copy_string_buffer(con->physical.doc_root, c->document_root);
-
-#ifdef DEBUG
-	log_error_write(srv, __FILE__, __LINE__, "sbbdb", 
-		result ? "NOT CACHED" : "cached", 
-		con->server_name, con->physical.doc_root,
-		c->fcgi_offset, c->fcgi_arg);
-#endif
 	return HANDLER_GO_ON;	
-
-ERR500:	if (result) mysql_free_result(result);
-	con->http_status = 500; /* Internal Error */
-	return HANDLER_FINISHED;
 }
 
 /* this function is called at dlopen() time and inits the callbacks */
 int mod_mysql_vhost_plugin_init(plugin *p) {
+	data_string *ds;
+	
 	p->version     = LIGHTTPD_VERSION_ID;
 	p->name        			= buffer_init_string("mysql_vhost");
 
 	p->init        			= mod_mysql_vhost_init;
 	p->cleanup     			= mod_mysql_vhost_cleanup;
-	p->handle_request_done	 	= mod_mysql_vhost_handle_connection_close;
 
 	p->set_defaults			= mod_mysql_vhost_set_defaults;
-	p->handle_docroot  		= mod_mysql_vhost_handle_docroot;
+	
+	ds = data_string_init();
+	buffer_copy_string(ds->value, CORE_PLUGIN);
+	array_insert_unique(p->required_plugins, (data_unset *)ds);
 	
 	return 0;
 }
--- lighttpd-1.4.11/src/mod_proxy.c	2006-01-31 13:01:22.000000000 +0200
+++ lighttpd/src/mod_proxy.c	2006-07-11 21:23:40.099855979 +0300
@@ -1,6 +1,5 @@
 #include <sys/types.h>
 
-#include <unistd.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <string.h>
@@ -23,6 +22,9 @@
 
 #include "inet_ntop_cache.h"
 #include "crc32.h"
+#include "network.h"
+
+#include "http_resp.h"
 
 #include <stdio.h>
 
@@ -31,6 +33,8 @@
 #endif
 
 #include "sys-socket.h"
+#include "sys-files.h"
+#include "sys-strings.h"
 
 #define data_proxy data_fastcgi
 #define data_proxy_init data_fastcgi_init
@@ -66,6 +70,8 @@
 	int debug;
 
 	proxy_balance_t balance;
+
+	array *last_used_backends; /* "extension" : last_used_backend */
 } plugin_config;
 
 typedef struct {
@@ -74,6 +80,8 @@
 	buffer *parse_response;
 	buffer *balance_buf;
 	
+	array *ignore_headers;
+
 	plugin_config **config_storage;
 	
 	plugin_config conf;
@@ -84,7 +92,8 @@
 	PROXY_STATE_CONNECT, 
 	PROXY_STATE_PREPARE_WRITE, 
 	PROXY_STATE_WRITE, 
-	PROXY_STATE_READ, 
+    PROXY_STATE_RESPONSE_HEADER,
+    PROXY_STATE_RESPONSE_CONTENT,
 	PROXY_STATE_ERROR 
 } proxy_connection_state_t;
 
@@ -100,6 +109,7 @@
 	buffer *response_header;
 
 	chunkqueue *wb;
+    chunkqueue *rb;
 	
 	int fd; /* fd to the proxy process */
 	int fde_ndx; /* index into the fd-event buffer */
@@ -127,6 +137,7 @@
 	hctx->response_header = buffer_init();
 
 	hctx->wb = chunkqueue_init();
+    hctx->rb = chunkqueue_init();
 
 	hctx->fd = -1;
 	hctx->fde_ndx = -1;
@@ -138,17 +149,38 @@
 	buffer_free(hctx->response);
 	buffer_free(hctx->response_header);
 	chunkqueue_free(hctx->wb);
+    chunkqueue_free(hctx->rb);
 	
 	free(hctx);
 }
 
 INIT_FUNC(mod_proxy_init) {
 	plugin_data *p;
+	size_t i;
+
+	char *hop2hop_headers[] = {
+		"Connection",
+		"Keep-Alive",
+		"Host",
+		NULL
+	};
 	
 	p = calloc(1, sizeof(*p));
 	
 	p->parse_response = buffer_init();
 	p->balance_buf = buffer_init();
+	p->ignore_headers = array_init();
+
+	for (i = 0; hop2hop_headers[i]; i++) {
+		data_string *ds;
+
+	    	if (NULL == (ds = (data_string *)array_get_unused_element(p->ignore_headers, TYPE_STRING))) {
+			ds = data_string_init();
+		}
+
+		buffer_copy_string(ds->value, hop2hop_headers[i]);
+		array_insert_unique(p->ignore_headers, (data_unset *)ds);
+	}
 	
 	return p;
 }
@@ -168,8 +200,8 @@
 			plugin_config *s = p->config_storage[i];
 			
 			if (s) {
-			
 				array_free(s->extensions);
+				array_free(s->last_used_backends);
 			
 				free(s);
 			}
@@ -177,6 +209,8 @@
 		free(p->config_storage);
 	}
 	
+	free(p->ignore_headers);
+
 	free(p);
 	
 	return HANDLER_GO_ON;
@@ -202,6 +236,7 @@
 		
 		s = malloc(sizeof(plugin_config));
 		s->extensions    = array_init();
+		s->last_used_backends = array_init();
 		s->debug         = 0;
 		
 		cv[0].destination = s->extensions;
@@ -372,14 +407,22 @@
 	proxy_addr = (struct sockaddr *) &proxy_addr_in;
 	
 	if (-1 == connect(proxy_fd, proxy_addr, servlen)) {
-		if (errno == EINPROGRESS || errno == EALREADY) {
+#ifdef _WIN32
+        errno = WSAGetLastError();
+#endif
+        switch(errno) {
+#ifdef _WIN32
+        case WSAEWOULDBLOCK:
+#endif
+        case EINPROGRESS:
+        case EALREADY:
 			if (p->conf.debug) {
 				log_error_write(srv, __FILE__, __LINE__, "sd", 
 						"connect delayed:", proxy_fd);
 			}
 			
 			return 1;
-		} else {
+		default:
 			
 			log_error_write(srv, __FILE__, __LINE__, "sdsd", 
 					"connect failed:", proxy_fd, strerror(errno), errno);
@@ -387,6 +430,7 @@
 			return -1;
 		}
 	}
+    fprintf(stderr, "%s.%d: connected fd = %d\r\n", __FILE__, __LINE__, proxy_fd);
 	if (p->conf.debug) {
 		log_error_write(srv, __FILE__, __LINE__, "sd", 
 				"connect succeeded: ", proxy_fd);
@@ -424,6 +468,7 @@
 	size_t i;
 	
 	connection *con   = hctx->remote_conn;
+	plugin_data *p    = hctx->plugin_data;
 	buffer *b;
 	
 	/* build header */
@@ -453,7 +498,9 @@
 		ds = (data_string *)con->request.headers->data[i];
 		
 		if (ds->value->used && ds->key->used) {
-			if (buffer_is_equal_string(ds->key, CONST_STR_LEN("Connection"))) continue;
+
+			/* don't copy hop-to-hop headers */
+			if (array_get_element(p->ignore_headers, ds->key->ptr)) continue;
 			
 			buffer_append_string_buffer(b, ds->key);
 			BUFFER_APPEND_STRING_CONST(b, ": ");
@@ -531,199 +578,101 @@
 }
 
 
-static int proxy_response_parse(server *srv, connection *con, plugin_data *p, buffer *in) {
-	char *s, *ns;
-	int http_response_status = -1;
-	
-	UNUSED(srv);
-
-	/* \r\n -> \0\0 */
-	
-	buffer_copy_string_buffer(p->parse_response, in);
-	
-	for (s = p->parse_response->ptr; NULL != (ns = strstr(s, "\r\n")); s = ns + 2) {
-		char *key, *value;
-		int key_len;
-		data_string *ds;
-		int copy_header;
-		
-		ns[0] = '\0';
-		ns[1] = '\0';
-
-		if (-1 == http_response_status) {
-			/* The first line of a Response message is the Status-Line */
-
-			for (key=s; *key && *key != ' '; key++);
+static void chunkqueue_print(chunkqueue *cq) {
+    chunk *c;
 
-			if (*key) {
-				http_response_status = (int) strtol(key, NULL, 10);
-				if (http_response_status <= 0) http_response_status = 502;
-			} else {
-				http_response_status = 502;
+    for (c = cq->first; c; c = c->next) {
+        fprintf(stderr, "%s", c->mem->ptr + c->offset);
 			}
-
-			con->http_status = http_response_status;
-			con->parsed_response |= HTTP_STATUS;
-			continue;
+    fprintf(stderr, "\r\n");
 		}
 		
-		if (NULL == (value = strchr(s, ':'))) {
-			/* now we expect: "<key>: <value>\n" */
-
-			continue;
-		}
-
-		key = s;
-		key_len = value - key;
-		
-		value++;
-		/* strip WS */
-		while (*value == ' ' || *value == '\t') value++;
-		
-		copy_header = 1;
+static int proxy_demux_response(server *srv, handler_ctx *hctx) {
+	plugin_data *p    = hctx->plugin_data;
+	connection *con   = hctx->remote_conn;
+	int proxy_fd       = hctx->fd;
+    chunkqueue *next_queue = NULL;
+    chunk *c = NULL;
 		
-		switch(key_len) {
-		case 4:
-			if (0 == strncasecmp(key, "Date", key_len)) {
-				con->parsed_response |= HTTP_DATE;
-			}
-			break;
-		case 8:
-			if (0 == strncasecmp(key, "Location", key_len)) {
-				con->parsed_response |= HTTP_LOCATION;
-			}
-			break;
-		case 10:
-			if (0 == strncasecmp(key, "Connection", key_len)) {
-				copy_header = 0;
-			}
+    switch(srv->network_backend_read(srv, con, proxy_fd, hctx->rb)) {
+    case NETWORK_STATUS_SUCCESS:
+        /* we got content */
 			break;
-		case 14:
-			if (0 == strncasecmp(key, "Content-Length", key_len)) {
-				con->response.content_length = strtol(value, NULL, 10);
-				con->parsed_response |= HTTP_CONTENT_LENGTH;
-			}
-			break;
-		default:
-			break;
-		}
+    case NETWORK_STATUS_CONNECTION_CLOSE:
+        /* we are done, get out of here */
+		con->file_finished = 1;
 
-		if (copy_header) {
-			if (NULL == (ds = (data_string *)array_get_unused_element(con->response.headers, TYPE_STRING))) {
-				ds = data_response_init();
-			}
-			buffer_copy_string_len(ds->key, key, key_len);
-			buffer_copy_string(ds->value, value);
+        /* close the chunk-queue with a empty chunk */
+		http_chunk_append_mem(srv, con, NULL, 0);
+		joblist_append(srv, con);
 			
-			array_insert_unique(con->response.headers, (data_unset *)ds);
-		}
+        return 1;
+    default:
+        /* oops */
+        return -1;
 	}
 	
-	return 0;
-}
+    /* looks like we got some content
+    *
+    * split off the header from the incoming stream
+    */
 
+    if (hctx->state == PROXY_STATE_RESPONSE_HEADER) {
+        http_resp *resp = http_response_init();
 
-static int proxy_demux_response(server *srv, handler_ctx *hctx) {
-	int fin = 0;
-	int b;
-	ssize_t r;
+        /* the response header is not fully received yet,
+        *
+        * extract the http-response header from the rb-cq
+        */
+        fprintf(stderr, "%s.%d: network-read\r\n", __FILE__, __LINE__);
+        chunkqueue_print(hctx->rb);
 	
-	plugin_data *p    = hctx->plugin_data;
-	connection *con   = hctx->remote_conn;
-	int proxy_fd       = hctx->fd;
+        switch (http_response_parse_cq(hctx->rb, resp)) {
+        case PARSE_ERROR:
+            /* parsing failed */
 	
-	/* check how much we have to read */
-	if (ioctl(hctx->fd, FIONREAD, &b)) {
-		log_error_write(srv, __FILE__, __LINE__, "sd", 
-				"ioctl failed: ",
-				proxy_fd);
-		return -1;
-	}
+            con->http_status = 502; /* Bad Gateway */
+            return 1;
+        case PARSE_NEED_MORE:
+            return 0;
+        case PARSE_SUCCESS:
+            con->http_status = resp->status;
 
+            fprintf(stderr, "%s.%d: parsing done\r\n", __FILE__, __LINE__);
+            chunkqueue_print(hctx->rb);
 
-	if (p->conf.debug) {
-		log_error_write(srv, __FILE__, __LINE__, "sd",
-			       "proxy - have to read:", b);
-	}
+            con->file_started = 1;
 
-	if (b > 0) {
-		if (hctx->response->used == 0) {
-			/* avoid too small buffer */
-			buffer_prepare_append(hctx->response, b + 1);
-			hctx->response->used = 1;
-		} else {
-			buffer_prepare_append(hctx->response, hctx->response->used + b);
+            hctx->state = PROXY_STATE_RESPONSE_CONTENT;
+            break;
 		}
-		
-		if (-1 == (r = read(hctx->fd, hctx->response->ptr + hctx->response->used - 1, b))) {
-			log_error_write(srv, __FILE__, __LINE__, "sds", 
-					"unexpected end-of-file (perhaps the proxy process died):",
-					proxy_fd, strerror(errno));
-			return -1;
 		}
 		
-		/* this should be catched by the b > 0 above */
-		assert(r);
+    /* FIXME: pass the response-header to the other plugins to
+    * setup the filter-queue
+    *
+    * - use next-queue instead of con->write_queue
+    */
 		
-		hctx->response->used += r;
-		hctx->response->ptr[hctx->response->used - 1] = '\0';
+    next_queue = con->write_queue;
 
-#if 0
-		log_error_write(srv, __FILE__, __LINE__, "sdsbs", 
-				"demux: Response buffer len", hctx->response->used, ":", hctx->response, ":");
-#endif
+    assert(hctx->state == PROXY_STATE_RESPONSE_CONTENT);
 
-		if (0 == con->got_response) {
-			con->got_response = 1;
-			buffer_prepare_copy(hctx->response_header, 128);
-		}
-				
-		if (0 == con->file_started) {
-			char *c;
-				
-			/* search for the \r\n\r\n in the string */
-			if (NULL != (c = buffer_search_string_len(hctx->response, "\r\n\r\n", 4))) {
-				size_t hlen = c - hctx->response->ptr + 4;
-				size_t blen = hctx->response->used - hlen - 1;
-				/* found */
-				
-				buffer_append_string_len(hctx->response_header, hctx->response->ptr, c - hctx->response->ptr + 4);
-#if 0
-				log_error_write(srv, __FILE__, __LINE__, "sb", "Header:", hctx->response_header);
-#endif
-				/* parse the response header */
-				proxy_response_parse(srv, con, p, hctx->response_header);
+    /* FIXME: if we have a content-length or chunked-encoding
+    * handle it.
+    *
+    * for now we wait for EOF on the socket */
 					
-				/* enable chunked-transfer-encoding */
-				if (con->request.http_version == HTTP_VERSION_1_1 &&
-				    !(con->parsed_response & HTTP_CONTENT_LENGTH)) {
-					con->response.transfer_encoding = HTTP_TRANSFER_ENCODING_CHUNKED;
-				}
+    /* copy the content to the next cq */
+    for (c = hctx->rb->first; c; c = c->next) {
+        http_chunk_append_mem(srv, con, c->mem->ptr + c->offset, c->mem->used - c->offset);
 					
-				con->file_started = 1;
-				if (blen) {
-					http_chunk_append_mem(srv, con, c + 4, blen + 1);
-					joblist_append(srv, con);
+        c->offset = c->mem->used - 1;
 				}
-				hctx->response->used = 0;
-			}
-		} else {
-			http_chunk_append_mem(srv, con, hctx->response->ptr, hctx->response->used);
-			joblist_append(srv, con);
-			hctx->response->used = 0;
-		}
-		
-	} else {
-		/* reading from upstream done */
-		con->file_finished = 1;
-		
-		http_chunk_append_mem(srv, con, NULL, 0);
-		joblist_append(srv, con);
 		
-		fin = 1;
-	}
+    chunkqueue_remove_finished_chunks(hctx->rb);
 	
-	return fin;
+	return 0;
 }
 
 
@@ -803,6 +752,7 @@
 			if (p->conf.debug) {
 				log_error_write(srv, __FILE__, __LINE__,  "s", "proxy - connect - delayed success"); 
 			}
+            fprintf(stderr, "%s.%d: connected fd = %d\r\n", __FILE__, __LINE__, hctx->fd);
 		}
 		
 		proxy_set_state(srv, hctx, PROXY_STATE_PREPARE_WRITE);
@@ -818,21 +768,20 @@
 
 		chunkqueue_remove_finished_chunks(hctx->wb);
 
-		if (-1 == ret) {
-			if (errno != EAGAIN &&
-			    errno != EINTR) {
+		switch(ret) {
+        case NETWORK_STATUS_FATAL_ERROR:
 				log_error_write(srv, __FILE__, __LINE__, "ssd", "write failed:", strerror(errno), errno);
 				
 				return HANDLER_ERROR;
-			} else {
+        case NETWORK_STATUS_WAIT_FOR_EVENT:
+
 				fdevent_event_add(srv->ev, &(hctx->fde_ndx), hctx->fd, FDEVENT_OUT);
 
 				return HANDLER_WAIT_FOR_EVENT;
 			}
-		}
 
 		if (hctx->wb->bytes_out == hctx->wb->bytes_in) {
-			proxy_set_state(srv, hctx, PROXY_STATE_READ);
+			proxy_set_state(srv, hctx, PROXY_STATE_RESPONSE_HEADER);
 
 			fdevent_event_del(srv->ev, &(hctx->fde_ndx), hctx->fd);
 			fdevent_event_add(srv->ev, &(hctx->fde_ndx), hctx->fd, FDEVENT_IN);
@@ -843,8 +792,9 @@
 		}
 		
 		return HANDLER_WAIT_FOR_EVENT;
-	case PROXY_STATE_READ:
+	case PROXY_STATE_RESPONSE_HEADER:
 		/* waiting for a response */
+
 		return HANDLER_WAIT_FOR_EVENT;
 	default:
 		log_error_write(srv, __FILE__, __LINE__, "s", "(debug) unknown state");
@@ -854,15 +804,14 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_proxy_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(extensions);
-	PATCH(debug);
-	PATCH(balance);
+	PATCH_OPTION(extensions);
+	PATCH_OPTION(debug);
+	PATCH_OPTION(balance);
+	PATCH_OPTION(last_used_backends);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -877,18 +826,18 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("proxy.server"))) {
-				PATCH(extensions);
+				PATCH_OPTION(extensions);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("proxy.debug"))) {
-				PATCH(debug);
+				PATCH_OPTION(debug);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("proxy.balance"))) {
-				PATCH(balance);
+				PATCH_OPTION(balance);
+				PATCH_OPTION(last_used_backends);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 SUBREQUEST_FUNC(mod_proxy_handle_subrequest) {
 	plugin_data *p = p_d;
@@ -954,7 +903,8 @@
 	
 	
 	if ((revents & FDEVENT_IN) &&
-	    hctx->state == PROXY_STATE_READ) {
+        (hctx->state == PROXY_STATE_RESPONSE_HEADER ||
+         hctx->state == PROXY_STATE_RESPONSE_CONTENT)) {
 
 		if (p->conf.debug) {
 			log_error_write(srv, __FILE__, __LINE__, "sd", 
@@ -1058,6 +1008,11 @@
 	buffer *fn;
 	data_array *extension = NULL;
 	size_t path_info_offset;
+	data_integer *last_used_backend;
+	data_proxy *host = NULL;
+	handler_ctx *hctx = NULL;
+
+	array *backends = NULL;
 	
 	/* Possibly, we processed already this request */
 	if (con->file_started == 1) return HANDLER_GO_ON;
@@ -1111,6 +1066,8 @@
 		return HANDLER_GO_ON;
 	}
 
+	backends = extension->value;
+
 	if (p->conf.debug) {	
 		log_error_write(srv, __FILE__, __LINE__,  "s", "proxy - ext found");
 	}
@@ -1121,33 +1078,33 @@
 
 		if (p->conf.debug) {
 			log_error_write(srv, __FILE__, __LINE__,  "sd", 
-					"proxy - used hash balancing, hosts:", extension->value->used);
+					"proxy - used hash balancing, hosts:", backends->used);
 		}
 
-		for (k = 0, ndx = -1, last_max = ULONG_MAX; k < extension->value->used; k++) {
-			data_proxy *host = (data_proxy *)extension->value->data[k];
+		for (k = 0, ndx = -1, last_max = ULONG_MAX; k < backends->used; k++) {
 			unsigned long cur_max;
 
-			if (host->is_disabled) continue;
+			data_proxy *cur = (data_proxy *)backends->data[k];
+
+			if (cur->is_disabled) continue;
 			
 			cur_max = generate_crc32c(CONST_BUF_LEN(con->uri.path)) +
-				generate_crc32c(CONST_BUF_LEN(host->host)) + /* we can cache this */
+				generate_crc32c(CONST_BUF_LEN(cur->host)) + /* we can cache this */
 				generate_crc32c(CONST_BUF_LEN(con->uri.authority));
 			
 			if (p->conf.debug) {
 				log_error_write(srv, __FILE__, __LINE__,  "sbbbd", 
 						"proxy - election:",
 						con->uri.path,
-						host->host,
+						cur->host,
 						con->uri.authority,
 						cur_max);
 			}
 
-			if ((last_max == ULONG_MAX) || /* first round */
-		   	    (cur_max > last_max)) {
+			if (host == NULL || (cur_max > last_max)) {
 				last_max = cur_max;
 
-				ndx = k;
+				host = cur;
 			}
 		}
 
@@ -1159,15 +1116,16 @@
 					"proxy - used fair balancing");
 		}
 
-		for (k = 0, ndx = -1, max_usage = INT_MAX; k < extension->value->used; k++) {
-			data_proxy *host = (data_proxy *)extension->value->data[k];
+		/* try to find the host with the lowest load */
+		for (k = 0, max_usage = 0; k < backends->used; k++) {
+			data_proxy *cur = (data_proxy *)backends->data[k];
 		
-			if (host->is_disabled) continue;
+			if (cur->is_disabled) continue;
 
-			if (host->usage < max_usage) {
-				max_usage = host->usage;
+			if (NULL == host || cur->usage < max_usage) {
+				max_usage = cur->usage;
 			
-				ndx = k;
+				host = cur;
 			}
 		}
 
@@ -1180,30 +1138,50 @@
 		}
 
 		/* just to be sure */
-		assert(extension->value->used < INT_MAX);
+		assert(backends->used < INT_MAX);
+
+		/* send each request to another host:
+		 *
+		 * e.g.:
+		 *
+		 * if we have three hosts it is
+		 *
+		 * 1 .. 2 .. 3 .. 1 .. 2 .. 3
+		 *
+		 **/
+
+		/* walk through the list */
+		last_used_backend = (data_integer *)array_get_element(p->conf.last_used_backends, extension->key->ptr);
 		
-		for (k = 0, ndx = -1, max_usage = INT_MAX; k < extension->value->used; k++) {
-			data_proxy *host = (data_proxy *)extension->value->data[k];
+		if (NULL == last_used_backend) {
+			last_used_backend = data_integer_init();
 		
-			if (host->is_disabled) continue;
+			buffer_copy_string_buffer(last_used_backend->key, extension->key);
+			last_used_backend->value = 0;
 
-			/* first usable ndx */
-			if (max_usage == INT_MAX) {
-				max_usage = k;
+			array_insert_unique(p->conf.last_used_backends, (data_unset *)last_used_backend);
 			}
 
-			/* get next ndx */
-			if ((int)k > host->last_used_ndx) {
-				ndx = k;
-				host->last_used_ndx = k;
+		/* scan all but the last host to see if they are up
+		 * take the first running host */
+		for (k = last_used_backend->value + 1; (int)(k % backends->used) != last_used_backend->value; k++) {
+			data_proxy *cur = (data_proxy *)backends->data[k % backends->used];
+
+			if (cur->is_disabled) continue;
+
+			host = cur;
+
+			last_used_backend->value = k;
 
 				break;
 			}
-		}
 		
-		/* didn't found a higher id, wrap to the start */
-		if (ndx != -1 && max_usage != INT_MAX) {
-			ndx = max_usage;
+		if (NULL == host) {
+			/* we found nothing better, fallback to the last used backend
+			 * and check if it is still up */
+			host = (data_proxy *)backends->data[last_used_backend->value];
+
+			if (host->is_disabled) host = NULL;
 		}
 
 		break;
@@ -1211,17 +1189,18 @@
 		break;
 	}
 	
-	/* found a server */
-	if (ndx != -1) {
-		data_proxy *host = (data_proxy *)extension->value->data[ndx];
+	/* we havn't found a host */
+	if (NULL == host) {
+		con->http_status = 500;
 		
-		/* 
-		 * if check-local is disabled, use the uri.path handler 
-		 * 
-		 */
+		log_error_write(srv, __FILE__, __LINE__,  "sb",
+				"no proxy-handler found for:",
+				fn);
+
+		return HANDLER_FINISHED;
+	}
 		
 		/* init handler-context */
-		handler_ctx *hctx;
 		hctx = handler_ctx_init();
 				
 		hctx->path_info_offset = path_info_offset;
@@ -1233,6 +1212,7 @@
 		
 		host->usage++;
 		
+	/* we handle this request */
 		con->mode = p->id;
 		
 		if (p->conf.debug) {
@@ -1242,17 +1222,6 @@
 		}
 
 		return HANDLER_GO_ON;
-	} else {
-		/* no handler found */
-		con->http_status = 500;
-		
-		log_error_write(srv, __FILE__, __LINE__,  "sb", 
-				"no proxy-handler found for:", 
-				fn);
-		
-		return HANDLER_FINISHED;
-	}
-	return HANDLER_GO_ON;
 }
 
 static handler_t mod_proxy_connection_close_callback(server *srv, connection *con, void *p_d) {
--- lighttpd-1.4.11/src/mod_redirect.c	2006-02-08 15:38:06.000000000 +0200
+++ lighttpd/src/mod_redirect.c	2006-07-11 21:23:40.111856730 +0300
@@ -166,7 +166,7 @@
 static handler_t mod_redirect_uri_handler(server *srv, connection *con, void *p_data) {
 #ifdef HAVE_PCRE_H
 	plugin_data *p = p_data;
-	size_t i;
+	int i;
 
 	/* 
 	 * REWRITE URL
@@ -178,70 +178,9 @@
 	mod_redirect_patch_connection(srv, con, p);
 	
 	buffer_copy_string_buffer(p->match_buf, con->request.uri);
+	i = config_exec_pcre_keyvalue_buffer(con, p->conf.redirect, p->conf.context, p->match_buf, p->location);
 	
-	for (i = 0; i < p->conf.redirect->used; i++) {
-		pcre *match;
-		pcre_extra *extra;
-		const char *pattern;
-		size_t pattern_len;
-		int n;
-		pcre_keyvalue *kv = p->conf.redirect->kv[i];
-# define N 10
-		int ovec[N * 3];
-		
-		match       = kv->key;
-		extra       = kv->key_extra;
-		pattern     = kv->value->ptr;
-		pattern_len = kv->value->used - 1;
-		
-		if ((n = pcre_exec(match, extra, p->match_buf->ptr, p->match_buf->used - 1, 0, 0, ovec, 3 * N)) < 0) {
-			if (n != PCRE_ERROR_NOMATCH) {
-				log_error_write(srv, __FILE__, __LINE__, "sd",
-						"execution error while matching: ", n);
-				return HANDLER_ERROR;
-			}
-		} else {
-			const char **list;
-			size_t start, end;
-			size_t k;
-			
-			/* it matched */
-			pcre_get_substring_list(p->match_buf->ptr, ovec, n, &list);
-			
-			/* search for $[0-9] */
-			
-			buffer_reset(p->location);
-			
-			start = 0; end = pattern_len;
-			for (k = 0; k < pattern_len; k++) {
-				if ((pattern[k] == '$' || pattern[k] == '%') &&
-				    isdigit((unsigned char)pattern[k + 1])) {
-					/* got one */
-					
-					size_t num = pattern[k + 1] - '0';
-					
-					end = k;
-					
-					buffer_append_string_len(p->location, pattern + start, end - start);
-					
-					if (pattern[k] == '$') {
-						/* n is always > 0 */
-						if (num < (size_t)n) {
-							buffer_append_string(p->location, list[num]);
-						}
-					} else {
-						config_append_cond_match_buffer(con, p->conf.context, p->location, num);
-					}
-					
-					k++;
-					start = k + 1;
-				} 
-			}
-			
-			buffer_append_string_len(p->location, pattern + start, pattern_len - start);
-			
-			pcre_free(list);
-			
+	if (i >= 0) {
 			response_header_insert(srv, con, CONST_STR_LEN("Location"), CONST_BUF_LEN(p->location));
 			
 			con->http_status = 301;
@@ -249,6 +188,9 @@
 			
 			return HANDLER_FINISHED;
 		}
+	else if (i != PCRE_ERROR_NOMATCH) {
+		log_error_write(srv, __FILE__, __LINE__, "s",
+				"execution error while matching", i);
 	}
 #undef N
 		
--- lighttpd-1.4.11/src/mod_rewrite.c	2005-09-29 20:59:10.000000000 +0300
+++ lighttpd/src/mod_rewrite.c	2006-07-11 21:23:39.947846458 +0300
@@ -13,24 +13,8 @@
 #endif
 
 typedef struct {
-#ifdef HAVE_PCRE_H
-	pcre *key;
-#endif
-	
-	buffer *value;
-	
-	int once;
-} rewrite_rule;
-
-typedef struct {
-	rewrite_rule **ptr;
-	
-	size_t used;
-	size_t size;
-} rewrite_rule_buffer;
-
-typedef struct {
-	rewrite_rule_buffer *rewrite;
+	pcre_keyvalue_buffer *rewrite;
+	buffer *once;
 	data_config *context; /* to which apply me */
 } plugin_config;
 
@@ -63,80 +47,6 @@
 	free(hctx);
 }
 
-rewrite_rule_buffer *rewrite_rule_buffer_init(void) {
-	rewrite_rule_buffer *kvb;
-	
-	kvb = calloc(1, sizeof(*kvb));
-	
-	return kvb;
-}
-
-int rewrite_rule_buffer_append(rewrite_rule_buffer *kvb, buffer *key, buffer *value, int once) {
-#ifdef HAVE_PCRE_H
-	size_t i;
-	const char *errptr;
-	int erroff;
-	
-	if (!key) return -1;
-
-	if (kvb->size == 0) {
-		kvb->size = 4;
-		kvb->used = 0;
-		
-		kvb->ptr = malloc(kvb->size * sizeof(*kvb->ptr));
-		
-		for(i = 0; i < kvb->size; i++) {
-			kvb->ptr[i] = calloc(1, sizeof(**kvb->ptr));
-		}
-	} else if (kvb->used == kvb->size) {
-		kvb->size += 4;
-		
-		kvb->ptr = realloc(kvb->ptr, kvb->size * sizeof(*kvb->ptr));
-		
-		for(i = kvb->used; i < kvb->size; i++) {
-			kvb->ptr[i] = calloc(1, sizeof(**kvb->ptr));
-		}
-	}
-	
-	if (NULL == (kvb->ptr[kvb->used]->key = pcre_compile(key->ptr,
-							    0, &errptr, &erroff, NULL))) {
-		
-		return -1;
-	}
-	
-	kvb->ptr[kvb->used]->value = buffer_init();
-	buffer_copy_string_buffer(kvb->ptr[kvb->used]->value, value);
-	kvb->ptr[kvb->used]->once = once;
-	
-	kvb->used++;
-	
-	return 0;
-#else
-	UNUSED(kvb);
-	UNUSED(value);
-	UNUSED(once);
-	UNUSED(key);
-
-	return -1;
-#endif
-}
-
-void rewrite_rule_buffer_free(rewrite_rule_buffer *kvb) {
-#ifdef HAVE_PCRE_H
-	size_t i;
-
-	for (i = 0; i < kvb->size; i++) {
-		if (kvb->ptr[i]->key) pcre_free(kvb->ptr[i]->key);
-		if (kvb->ptr[i]->value) buffer_free(kvb->ptr[i]->value);
-		free(kvb->ptr[i]);
-	}
-	
-	if (kvb->ptr) free(kvb->ptr);
-#endif
-	
-	free(kvb);
-}
-
 
 INIT_FUNC(mod_rewrite_init) {
 	plugin_data *p;
@@ -160,7 +70,8 @@
 		size_t i;
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
-			rewrite_rule_buffer_free(s->rewrite);
+			pcre_keyvalue_buffer_free(s->rewrite);
+			buffer_free(s->once);
 			
 			free(s);
 		}
@@ -198,10 +109,9 @@
 				return HANDLER_ERROR;
 			}
 			
-			if (0 != rewrite_rule_buffer_append(s->rewrite, 
-							    ((data_string *)(da->value->data[j]))->key,
-							    ((data_string *)(da->value->data[j]))->value,
-							    once)) {
+			if (0 != pcre_keyvalue_buffer_append(s->rewrite,
+							    ((data_string *)(da->value->data[j]))->key->ptr,
+							    ((data_string *)(da->value->data[j]))->value->ptr)) {
 #ifdef HAVE_PCRE_H
 				log_error_write(srv, __FILE__, __LINE__, "sb", 
 						"pcre-compile failed for", da->value->data[j]->key);
@@ -210,6 +120,12 @@
 						"pcre support is missing, please install libpcre and the headers");
 #endif
 			}
+
+			if (once) {
+				buffer_append_string_len(s->once, CONST_STR_LEN("1"));
+			} else {
+				buffer_append_string_len(s->once, CONST_STR_LEN("0"));
+			}
 		}
 	}
 	
@@ -245,11 +161,8 @@
 		array *ca;
 		
 		s = calloc(1, sizeof(plugin_config));
-		s->rewrite   = rewrite_rule_buffer_init();
-		
-		cv[0].destination = s->rewrite;
-		cv[1].destination = s->rewrite;
-		cv[2].destination = s->rewrite;
+		s->rewrite   = pcre_keyvalue_buffer_init();
+		s->once      = buffer_init();
 		
 		p->config_storage[i] = s;
 		ca = ((data_config *)srv->config_context->data[i])->value;
@@ -271,6 +184,7 @@
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	p->conf.rewrite = s->rewrite;
+	p->conf.once    = s->once;
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -288,15 +202,19 @@
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("url.rewrite"))) {
 				p->conf.rewrite = s->rewrite;
+				p->conf.once    = s->once;
 				p->conf.context = dc;
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("url.rewrite-once"))) {
 				p->conf.rewrite = s->rewrite;
+				p->conf.once    = s->once;
 				p->conf.context = dc;
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("url.rewrite-repeat"))) {
 				p->conf.rewrite = s->rewrite;
+				p->conf.once    = s->once;
 				p->conf.context = dc;
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("url.rewrite-final"))) {
 				p->conf.rewrite = s->rewrite;
+				p->conf.once    = s->once;
 				p->conf.context = dc;
 			}
 		}
@@ -321,7 +239,7 @@
 URIHANDLER_FUNC(mod_rewrite_uri_handler) {
 #ifdef HAVE_PCRE_H
 	plugin_data *p = p_d;
-	size_t i;
+	int i;
 	handler_ctx *hctx;
 
 	/* 
@@ -349,76 +267,21 @@
 	if (!p->conf.rewrite) return HANDLER_GO_ON;
 	
 	buffer_copy_string_buffer(p->match_buf, con->request.uri);
+	i = config_exec_pcre_keyvalue_buffer(con, p->conf.rewrite, p->conf.context, p->match_buf, con->request.uri);
 	
-	for (i = 0; i < p->conf.rewrite->used; i++) {
-		pcre *match;
-		const char *pattern;
-		size_t pattern_len;
-		int n;
-		rewrite_rule *rule = p->conf.rewrite->ptr[i];
-# define N 10
-		int ovec[N * 3];
-		
-		match       = rule->key;
-		pattern     = rule->value->ptr;
-		pattern_len = rule->value->used - 1;
-		
-		if ((n = pcre_exec(match, NULL, p->match_buf->ptr, p->match_buf->used - 1, 0, 0, ovec, 3 * N)) < 0) {
-			if (n != PCRE_ERROR_NOMATCH) {
-				log_error_write(srv, __FILE__, __LINE__, "sd",
-						"execution error while matching: ", n);
-				return HANDLER_ERROR;
-			}
-		} else {
-			const char **list;
-			size_t start, end;
-			size_t k;
-			
-			/* it matched */
-			pcre_get_substring_list(p->match_buf->ptr, ovec, n, &list);
-			
-			/* search for $[0-9] */
-			
-			buffer_reset(con->request.uri);
-			
-			start = 0; end = pattern_len;
-			for (k = 0; k < pattern_len; k++) {
-				if ((pattern[k] == '$' || pattern[k] == '%') &&
-				    isdigit((unsigned char)pattern[k + 1])) {
-					/* got one */
-					
-					size_t num = pattern[k + 1] - '0';
-					
-					end = k;
-					
-					buffer_append_string_len(con->request.uri, pattern + start, end - start);
-					
-					if (pattern[k] == '$') {
-						/* n is always > 0 */
-						if (num < (size_t)n) {
-							buffer_append_string(con->request.uri, list[num]);
-						}
-					} else {
-						config_append_cond_match_buffer(con, p->conf.context, con->request.uri, num);
-					}
-					
-					k++;
-					start = k + 1;
-				} 
-			}
-			
-			buffer_append_string_len(con->request.uri, pattern + start, pattern_len - start);
-			
-			pcre_free(list);
-			
+	if (i >= 0) {
 			hctx = handler_ctx_init();
 				
 			con->plugin_ctx[p->id] = hctx;
 			
-			if (rule->once) hctx->state = REWRITE_STATE_FINISHED;
+		if (p->conf.once->ptr[i] == '1')
+			hctx->state = REWRITE_STATE_FINISHED;
 			
 			return HANDLER_COMEBACK;
 		}
+	else if (i != PCRE_ERROR_NOMATCH) {
+		log_error_write(srv, __FILE__, __LINE__, "s",
+				"execution error while matching", i);
 	}
 #undef N
 		
--- lighttpd-1.4.11/src/mod_rrdtool.c	2005-08-22 01:52:24.000000000 +0300
+++ lighttpd/src/mod_rrdtool.c	2006-07-11 21:23:40.059853473 +0300
@@ -5,7 +5,6 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
-#include <unistd.h>
 #include <errno.h>
 #include <time.h>
 
@@ -20,6 +19,10 @@
 /* no need for waitpid if we don't have fork */
 #include <sys/wait.h>
 #endif
+
+#include "sys-files.h"
+#include "sys-process.h"
+
 typedef struct {
 	buffer *path_rrdtool_bin;
 	buffer *path_rrd;
@@ -250,14 +253,12 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_rrd_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(path_rrdtool_bin);
-	PATCH(path_rrd);
+	PATCH_OPTION(path_rrdtool_bin);
+	PATCH_OPTION(path_rrd);
 	
 	p->conf.bytes_written_ptr = &(s->bytes_written);
 	p->conf.bytes_read_ptr = &(s->bytes_read);
@@ -276,7 +277,7 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("rrdtool.db-name"))) {
-				PATCH(path_rrd);
+				PATCH_OPTION(path_rrd);
 				/* get pointers to double values */
 				
 				p->conf.bytes_written_ptr = &(s->bytes_written);
@@ -288,7 +289,6 @@
 	
 	return 0;
 }
-#undef PATCH
 
 SETDEFAULTS_FUNC(mod_rrd_set_defaults) {
 	plugin_data *p = p_d;
--- lighttpd-1.4.11/src/mod_scgi.c	2006-03-04 17:15:26.000000000 +0200
+++ lighttpd/src/mod_scgi.c	2006-07-11 21:23:40.023851218 +0300
@@ -1,5 +1,4 @@
 #include <sys/types.h>
-#include <unistd.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <string.h>
@@ -30,7 +29,9 @@
 #endif
 
 #include "sys-socket.h"
-
+#include "sys-files.h"
+#include "sys-strings.h"
+#include "sys-process.h"
 
 #ifndef UNIX_PATH_MAX
 # define UNIX_PATH_MAX 108
@@ -61,7 +62,6 @@
 	
 	pid_t pid;   /* PID of the spawned process (0 if not spawned locally) */
 
-
 	size_t load; /* number of requests waiting on this process */
 
 	time_t last_used; /* see idle_timeout */
@@ -308,7 +308,6 @@
 	size_t    request_id;
 	int       fd;        /* fd to the scgi process */
 	int       fde_ndx;   /* index into the fd-event buffer */
-
 	pid_t     pid;
 	int       got_proc;
 	
@@ -555,7 +554,9 @@
 					host = ex->hosts[n];
 					
 					for (proc = host->first; proc; proc = proc->next) {
+#ifndef _WIN32
 						if (proc->pid != 0) kill(proc->pid, SIGTERM);
+#endif
 						
 						if (proc->is_local && 
 						    !buffer_is_empty(proc->socket)) {
@@ -564,7 +565,9 @@
 					}
 					
 					for (proc = host->unused_procs; proc; proc = proc->next) {
+#ifndef _WIN32
 						if (proc->pid != 0) kill(proc->pid, SIGTERM);
+#endif
 						
 						if (proc->is_local && 
 						    !buffer_is_empty(proc->socket)) {
@@ -641,12 +644,8 @@
 		scgi_addr_un.sun_family = AF_UNIX;
 		strcpy(scgi_addr_un.sun_path, proc->socket->ptr);
 		
-#ifdef SUN_LEN
 		servlen = SUN_LEN(&scgi_addr_un);
-#else
-		/* stevens says: */
-		servlen = proc->socket->used + sizeof(scgi_addr_un.sun_family);
-#endif
+
 		socket_type = AF_UNIX;
 		scgi_addr = (struct sockaddr *) &scgi_addr_un;
 #else
@@ -1292,12 +1291,9 @@
 		/* use the unix domain socket */
 		scgi_addr_un.sun_family = AF_UNIX;
 		strcpy(scgi_addr_un.sun_path, proc->socket->ptr);
-#ifdef SUN_LEN
+		
 		servlen = SUN_LEN(&scgi_addr_un);
-#else
-		/* stevens says: */
-		servlen = proc->socket->used + sizeof(scgi_addr_un.sun_family);
-#endif
+
 		scgi_addr = (struct sockaddr *) &scgi_addr_un;
 #else
 		return -1;
@@ -2058,6 +2054,7 @@
 			int status;
 			
 			if (proc->state == PROC_STATE_DIED_WAIT_FOR_PID) {
+#ifndef _WIN32
 				switch(waitpid(proc->pid, &status, WNOHANG)) {
 				case 0:
 					/* child is still alive */
@@ -2084,6 +2081,7 @@
 					proc->state = PROC_STATE_DIED;
 					break;
 				}
+#endif
 			}
 			
 			/* 
@@ -2271,10 +2269,11 @@
 				 */ 
 				if (hctx->wb->bytes_out == 0 &&
 				    hctx->reconnects < 5) {
+#ifndef _WIN32
 					usleep(10000); /* take away the load of the webserver 
 							* to let the php a chance to restart 
 							*/
-					
+#endif
 					scgi_reconnect(srv, hctx);
 				
 					return HANDLER_WAIT_FOR_FD;
@@ -2286,7 +2285,7 @@
 				 * 
 				 */
 				
-				log_error_write(srv, __FILE__, __LINE__, "ssdsd", 
+				log_error_write(srv, __FILE__, __LINE__, "ssosd",
 						"[REPORT ME] connection was dropped after accept(). reconnect() denied:",
 						"write-offset:", hctx->wb->bytes_out,
 						"reconnect attempts:", hctx->reconnects);
@@ -2479,7 +2478,7 @@
 				int status;
 				
 				/* only fetch the zombie if it is not already done */
-				
+#ifndef _WIN32
 				switch(waitpid(proc->pid, &status, WNOHANG)) {
 				case 0:
 					/* child is still alive */
@@ -2519,6 +2518,7 @@
 					
 					break;
 				}
+#endif
 			}
 
 			if (con->file_started == 0) {
@@ -2536,7 +2536,7 @@
 					return HANDLER_WAIT_FOR_FD;
 				}
 				
-				log_error_write(srv, __FILE__, __LINE__, "sdsdsd", 
+				log_error_write(srv, __FILE__, __LINE__, "sosdsd",
 						"response not sent, request sent:", hctx->wb->bytes_out,
 						"connection-fd:", con->fd,
 						"fcgi-fd:", hctx->fd);
@@ -2631,14 +2631,13 @@
 	
 	return HANDLER_FINISHED;
 }
-#define PATCH(x) \
-	p->conf.x = s->x;
+
 static int scgi_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(exts);
-	PATCH(debug);
+	PATCH_OPTION(exts);
+	PATCH_OPTION(debug);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -2653,17 +2652,15 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("scgi.server"))) {
-				PATCH(exts);
+				PATCH_OPTION(exts);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("scgi.debug"))) {
-				PATCH(debug);
+				PATCH_OPTION(debug);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
-
 
 static handler_t scgi_check_extension(server *srv, connection *con, void *p_d, int uri_path_handler) {
 	plugin_data *p = p_d;
@@ -2971,7 +2968,7 @@
 					if (proc->load != 0) break;
 					if (host->num_procs <= host->min_procs) break;
 					if (proc->pid == 0) continue;
-					
+#ifndef _WIN32
 					if (srv->cur_ts - proc->last_used > host->idle_timeout) {
 						/* a proc is idling for a long time now,
 						 * terminated it */
@@ -3009,13 +3006,14 @@
 						/* proc is now in unused, let the next second handle the next process */
 						break;
 					}	
+#endif
 				}
 				
 				for (proc = host->unused_procs; proc; proc = proc->next) {
 					int status;
 					
 					if (proc->pid == 0) continue;
-					
+#ifndef _WIN32
 					switch (waitpid(proc->pid, &status, WNOHANG)) {
 					case 0:
 						/* child still running after timeout, good */
@@ -3059,6 +3057,7 @@
 						proc->state = PROC_STATE_UNSET;
 						host->max_id--;
 					}
+#endif
 				}
 			}
 		}
--- lighttpd-1.4.11/src/mod_secure_download.c	2005-12-14 14:37:29.000000000 +0200
+++ lighttpd/src/mod_secure_download.c	2006-07-11 21:23:39.935845706 +0300
@@ -156,16 +156,14 @@
 	return i == len;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_secdownload_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(secret);
-	PATCH(doc_root);
-	PATCH(uri_prefix);
-	PATCH(timeout);
+	PATCH_OPTION(secret);
+	PATCH_OPTION(doc_root);
+	PATCH_OPTION(uri_prefix);
+	PATCH_OPTION(timeout);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -180,21 +178,19 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("secdownload.secret"))) {
-				PATCH(secret);
+				PATCH_OPTION(secret);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("secdownload.document-root"))) {
-				PATCH(doc_root);
+				PATCH_OPTION(doc_root);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("secdownload.uri-prefix"))) {
-				PATCH(uri_prefix);
+				PATCH_OPTION(uri_prefix);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("secdownload.timeout"))) {
-				PATCH(timeout);
+				PATCH_OPTION(timeout);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
-
 
 URIHANDLER_FUNC(mod_secdownload_uri_handler) {
 	plugin_data *p = p_d;
--- lighttpd-1.4.11/src/mod_setenv.c	2006-01-14 20:33:12.000000000 +0200
+++ lighttpd/src/mod_setenv.c	2006-07-11 21:23:40.191861741 +0300
@@ -120,15 +120,13 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_setenv_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(request_header);
-	PATCH(response_header);
-	PATCH(environment);
+	PATCH_OPTION(request_header);
+	PATCH_OPTION(response_header);
+	PATCH_OPTION(environment);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -143,18 +141,17 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("setenv.add-request-header"))) {
-				PATCH(request_header);
+				PATCH_OPTION(request_header);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("setenv.add-response-header"))) {
-				PATCH(response_header);
+				PATCH_OPTION(response_header);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("setenv.add-environment"))) {
-				PATCH(environment);
+				PATCH_OPTION(environment);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 URIHANDLER_FUNC(mod_setenv_uri_handler) {
 	plugin_data *p = p_d;
--- lighttpd-1.4.11/src/mod_simple_vhost.c	2005-11-18 15:16:13.000000000 +0200
+++ lighttpd/src/mod_simple_vhost.c	2006-07-11 21:23:40.087855227 +0300
@@ -10,6 +10,8 @@
 
 #include "plugin.h"
 
+#include "sys-files.h"
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
@@ -139,7 +141,7 @@
 			 */
 			char *dp;
 			
-			BUFFER_APPEND_SLASH(out);
+			PATHNAME_APPEND_SLASH(out);
 			
 			if (NULL == (dp = strchr(host->ptr, ':'))) {
 				buffer_append_string_buffer(out, host);
@@ -147,17 +149,17 @@
 				buffer_append_string_len(out, host->ptr, dp - host->ptr);
 			}
 		}
-		BUFFER_APPEND_SLASH(out);
+		PATHNAME_APPEND_SLASH(out);
 		
 		if (p->conf.document_root->used > 2 && p->conf.document_root->ptr[0] == '/') {
 			buffer_append_string_len(out, p->conf.document_root->ptr + 1, p->conf.document_root->used - 2);
 		} else {
 			buffer_append_string_buffer(out, p->conf.document_root);
-			BUFFER_APPEND_SLASH(out);
+			PATHNAME_APPEND_SLASH(out);
 		}
 	} else {
 		buffer_copy_string_buffer(out, con->conf.document_root);
-		BUFFER_APPEND_SLASH(out);
+		PATHNAME_APPEND_SLASH(out);
 	}
 	
 	if (HANDLER_ERROR == stat_cache_get_entry(srv, con, out, &sce)) {
@@ -173,22 +175,19 @@
 	return 0;
 }
 
-
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_simple_vhost_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(server_root);
-	PATCH(default_host);
-	PATCH(document_root);
-	
-	PATCH(docroot_cache_key);
-	PATCH(docroot_cache_value);
-	PATCH(docroot_cache_servername);
+	PATCH_OPTION(server_root);
+	PATCH_OPTION(default_host);
+	PATCH_OPTION(document_root);
+
+	PATCH_OPTION(docroot_cache_key);
+	PATCH_OPTION(docroot_cache_value);
+	PATCH_OPTION(docroot_cache_servername);
 
-	PATCH(debug);
+	PATCH_OPTION(debug);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -203,23 +202,22 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("simple-vhost.server-root"))) {
-				PATCH(server_root);
-				PATCH(docroot_cache_key);
-				PATCH(docroot_cache_value);
-				PATCH(docroot_cache_servername);
+				PATCH_OPTION(server_root);
+				PATCH_OPTION(docroot_cache_key);
+				PATCH_OPTION(docroot_cache_value);
+				PATCH_OPTION(docroot_cache_servername);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("simple-vhost.default-host"))) {
-				PATCH(default_host);
+				PATCH_OPTION(default_host);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("simple-vhost.document-root"))) {
-				PATCH(document_root);
+				PATCH_OPTION(document_root);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("simple-vhost.debug"))) {
-				PATCH(debug);
+				PATCH_OPTION(debug);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 static handler_t mod_simple_vhost_docroot(server *srv, connection *con, void *p_data) {
 	plugin_data *p = p_data;
--- lighttpd-1.4.11/src/mod_skeleton.c	2005-10-02 18:30:51.000000000 +0300
+++ lighttpd/src/mod_skeleton.c	2006-07-11 21:23:40.019850968 +0300
@@ -132,13 +132,11 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_skeleton_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(match);
+	PATCH_OPTION(match);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -153,14 +151,13 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("skeleton.array"))) {
-				PATCH(match);
+				PATCH_OPTION(match);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 URIHANDLER_FUNC(mod_skeleton_uri_handler) {
 	plugin_data *p = p_d;
--- lighttpd-1.4.11/src/mod_ssi.c	2006-03-04 17:09:48.000000000 +0200
+++ lighttpd/src/mod_ssi.c	2006-07-11 21:23:40.159859737 +0300
@@ -6,7 +6,6 @@
 #include <string.h>
 #include <errno.h>
 #include <time.h>
-#include <unistd.h>
 
 #include "base.h"
 #include "log.h"
@@ -23,6 +22,8 @@
 #include "inet_ntop_cache.h"
 
 #include "sys-socket.h"
+#include "sys-strings.h"
+#include "sys-files.h"
 
 #ifdef HAVE_PWD_H
 #include <pwd.h>
@@ -660,6 +661,8 @@
 		
 		break;
 	case SSI_EXEC: {
+#ifndef _WIN32
+
 		const char *cmd = NULL;
 		pid_t pid;
 		int from_exec_fds[2];
@@ -682,7 +685,7 @@
 		 */
 		
 		if (!cmd) break;
-#ifdef HAVE_FORK	
+
 		if (pipe(from_exec_fds)) {
 			log_error_write(srv, __FILE__, __LINE__, "ss", 
 					"pipe failed: ", strerror(errno));
@@ -760,7 +763,6 @@
 		}
 		}
 #else
-
 		return -1;
 #endif
 		
@@ -1008,13 +1010,11 @@
 	return 0;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_ssi_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(ssi_extension);
+	PATCH_OPTION(ssi_extension);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -1029,14 +1029,13 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssi.extension"))) {
-				PATCH(ssi_extension);
+				PATCH_OPTION(ssi_extension);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 URIHANDLER_FUNC(mod_ssi_physical_path) {
 	plugin_data *p = p_d;
--- lighttpd-1.4.11/src/mod_staticfile.c	2006-02-15 14:31:14.000000000 +0200
+++ lighttpd/src/mod_staticfile.c	2006-07-11 21:23:39.979848462 +0300
@@ -14,6 +14,8 @@
 #include "http_chunk.h"
 #include "response.h"
 
+#include "sys-files.h"
+#include "sys-strings.h"
 /**
  * this is a staticfile for a lighttpd plugin
  * 
@@ -48,7 +50,7 @@
 	return p;
 }
 
-/* detroy the plugin data */
+/* destroy the plugin data */
 FREE_FUNC(mod_staticfile_free) {
 	plugin_data *p = p_d;
 	
@@ -107,13 +109,11 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_staticfile_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(exclude_ext);
+	PATCH_OPTION(exclude_ext);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -128,14 +128,13 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("static-file.exclude-extensions"))) {
-				PATCH(exclude_ext);
+				PATCH_OPTION(exclude_ext);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 static int http_response_parse_range(server *srv, connection *con, plugin_data *p) {
 	int multipart = 0;
@@ -396,7 +395,7 @@
 		return HANDLER_FINISHED;
 	}
 	
-	/* we only handline regular files */
+	/* we only handle regular files */
 	if (!S_ISREG(sce->st.st_mode)) {
 		con->http_status = 404;
 		
@@ -409,7 +408,7 @@
 		return HANDLER_FINISHED;
 	}
 
-	/* mod_compress might set several data directly, don't overwrite them */
+	/* mod_compress might set several parameters directly; don't overwrite them */
 	
 	/* set response content-type, if not set already */
 
--- lighttpd-1.4.11/src/mod_status.c	2006-01-10 21:45:32.000000000 +0200
+++ lighttpd/src/mod_status.c	2006-07-11 21:23:40.131857983 +0300
@@ -4,7 +4,6 @@
 #include <fcntl.h>
 #include <stdlib.h>
 #include <string.h>
-#include <unistd.h>
 #include <errno.h>
 #include <time.h>
 #include <stdio.h>
@@ -202,7 +201,7 @@
 	size_t j;
 	double avg;
 	char multiplier = '\0';
-	char buf[32];
+	char buf[128];
 	time_t ts;
 	
 	int days, hours, mins, seconds;
@@ -304,13 +303,13 @@
 	/* connection listing */
 	BUFFER_APPEND_STRING_CONST(b, "<h1>Server-Status</h1>");
 	
-	BUFFER_APPEND_STRING_CONST(b, "<table class=\"status\">");
-	BUFFER_APPEND_STRING_CONST(b, "<tr><td>Hostname</td><td class=\"string\">");
+	BUFFER_APPEND_STRING_CONST(b, "<table class=\"status\" id=\"status\" summary=\"Server Status\">");
+	BUFFER_APPEND_STRING_CONST(b, "<tr><td>Hostname</td><td class=\"string\"><span id=\"host_addr\">");
 	buffer_append_string_buffer(b, con->uri.authority);
-	BUFFER_APPEND_STRING_CONST(b, " (");
+	BUFFER_APPEND_STRING_CONST(b, "</span> (<span id=\"host_name\">");
 	buffer_append_string_buffer(b, con->server_name);
-	BUFFER_APPEND_STRING_CONST(b, ")</td></tr>\n");
-	BUFFER_APPEND_STRING_CONST(b, "<tr><td>Uptime</td><td class=\"string\">");
+	BUFFER_APPEND_STRING_CONST(b, "</span>)</td></tr>\n");
+	BUFFER_APPEND_STRING_CONST(b, "<tr><td>Uptime</td><td class=\"string\" id=\"uptime\">");
 	
 	ts = srv->cur_ts - srv->startup_ts;
 	
@@ -348,58 +347,58 @@
 	
 	ts = srv->startup_ts;
 	
-	strftime(buf, sizeof(buf) - 1, "%Y-%m-%d %H:%M:%S", localtime(&ts));
+	strftime(buf, sizeof(buf) - 1, "<span id=\"start_date\">%Y-%m-%d</span> <span id=\"start_time\">%H:%M:%S</span>", localtime(&ts));
 	buffer_append_string(b, buf);
 	BUFFER_APPEND_STRING_CONST(b, "</td></tr>\n");
 	
 	
 	BUFFER_APPEND_STRING_CONST(b, "<tr><th colspan=\"2\">absolute (since start)</th></tr>\n");
 	
-	BUFFER_APPEND_STRING_CONST(b, "<tr><td>Requests</td><td class=\"string\">");
+	BUFFER_APPEND_STRING_CONST(b, "<tr><td>Requests</td><td class=\"string\" ><span id=\"requests\">");
 	avg = p->abs_requests;
 
 	mod_status_get_multiplier(&avg, &multiplier, 1000);
 	
 	buffer_append_long(b, avg);
-	BUFFER_APPEND_STRING_CONST(b, " ");
+	BUFFER_APPEND_STRING_CONST(b, "</span> <span id=\"requests_mult\">");
 	if (multiplier)	buffer_append_string_len(b, &multiplier, 1);
-	BUFFER_APPEND_STRING_CONST(b, "req</td></tr>\n");
+	BUFFER_APPEND_STRING_CONST(b, "</span>req</td></tr>\n");
 	
-	BUFFER_APPEND_STRING_CONST(b, "<tr><td>Traffic</td><td class=\"string\">");
+	BUFFER_APPEND_STRING_CONST(b, "<tr><td>Traffic</td><td class=\"string\"><span id=\"traffic\">");
 	avg = p->abs_traffic_out;
 
 	mod_status_get_multiplier(&avg, &multiplier, 1024);
 
 	sprintf(buf, "%.2f", avg);
 	buffer_append_string(b, buf);
-	BUFFER_APPEND_STRING_CONST(b, " ");
+	BUFFER_APPEND_STRING_CONST(b, "</span>  <span id=\"traffic_mult\">");
 	if (multiplier)	buffer_append_string_len(b, &multiplier, 1);
-	BUFFER_APPEND_STRING_CONST(b, "byte</td></tr>\n");
+	BUFFER_APPEND_STRING_CONST(b, "</span>byte</td></tr>\n");
 
 
 
 	BUFFER_APPEND_STRING_CONST(b, "<tr><th colspan=\"2\">average (since start)</th></tr>\n");
 	
-	BUFFER_APPEND_STRING_CONST(b, "<tr><td>Requests</td><td class=\"string\">");
+	BUFFER_APPEND_STRING_CONST(b, "<tr><td>Requests</td><td class=\"string\"><span id=\"requests_avg\">");
 	avg = p->abs_requests / (srv->cur_ts - srv->startup_ts);
 
 	mod_status_get_multiplier(&avg, &multiplier, 1000);
 
 	buffer_append_long(b, avg);
-	BUFFER_APPEND_STRING_CONST(b, " ");
+	BUFFER_APPEND_STRING_CONST(b, "</span> <span id=\"requests_avg_mult\">");
 	if (multiplier)	buffer_append_string_len(b, &multiplier, 1);
-	BUFFER_APPEND_STRING_CONST(b, "req/s</td></tr>\n");
+	BUFFER_APPEND_STRING_CONST(b, "</span>req/s</td></tr>\n");
 	
-	BUFFER_APPEND_STRING_CONST(b, "<tr><td>Traffic</td><td class=\"string\">");
+	BUFFER_APPEND_STRING_CONST(b, "<tr><td>Traffic</td><td class=\"string\"><span id=\"traffic_avg\">");
 	avg = p->abs_traffic_out / (srv->cur_ts - srv->startup_ts);
 
 	mod_status_get_multiplier(&avg, &multiplier, 1024);
 
 	sprintf(buf, "%.2f", avg);
 	buffer_append_string(b, buf);
-	BUFFER_APPEND_STRING_CONST(b, " ");
+	BUFFER_APPEND_STRING_CONST(b, "</span> <span id=\"traffic_avg_mult\">");
 	if (multiplier)	buffer_append_string_len(b, &multiplier, 1);
-	BUFFER_APPEND_STRING_CONST(b, "byte/s</td></tr>\n");
+	BUFFER_APPEND_STRING_CONST(b, "</span>byte/s</td></tr>\n");
 
 	
 	
@@ -410,15 +409,15 @@
 	
 	avg /= 5;
 	
-	BUFFER_APPEND_STRING_CONST(b, "<tr><td>Requests</td><td class=\"string\">");
+	BUFFER_APPEND_STRING_CONST(b, "<tr><td>Requests</td><td class=\"string\"><span id=\"requests_sliding_avg\">");
 
 	mod_status_get_multiplier(&avg, &multiplier, 1000);
 
 	buffer_append_long(b, avg);
-	BUFFER_APPEND_STRING_CONST(b, " ");
+	BUFFER_APPEND_STRING_CONST(b, "</span> <span id=\"requests_sliding_avg_mult\">");
 	if (multiplier)	buffer_append_string_len(b, &multiplier, 1);
 	
-	BUFFER_APPEND_STRING_CONST(b, "req/s</td></tr>\n");
+	BUFFER_APPEND_STRING_CONST(b, "</span>req/s</td></tr>\n");
 	
 	for (j = 0, avg = 0; j < 5; j++) {
 		avg += p->mod_5s_traffic_out[j];
@@ -426,15 +425,15 @@
 	
 	avg /= 5;
 	
-	BUFFER_APPEND_STRING_CONST(b, "<tr><td>Traffic</td><td class=\"string\">");
+	BUFFER_APPEND_STRING_CONST(b, "<tr><td>Traffic</td><td class=\"string\"><span id=\"requests_sliding_traffic\">");
 
 	mod_status_get_multiplier(&avg, &multiplier, 1024);
 
 	sprintf(buf, "%.2f", avg);
 	buffer_append_string(b, buf);
-	BUFFER_APPEND_STRING_CONST(b, " ");
+	BUFFER_APPEND_STRING_CONST(b, "</span> <span id=\"requests_sliding_traffic_mult\">");
 	if (multiplier)	buffer_append_string_len(b, &multiplier, 1);
-	BUFFER_APPEND_STRING_CONST(b, "byte/s</td></tr>\n");
+	BUFFER_APPEND_STRING_CONST(b, "</span>byte/s</td></tr>\n");
 	
 	BUFFER_APPEND_STRING_CONST(b, "</table>\n");
 	
@@ -445,9 +444,9 @@
 	BUFFER_APPEND_STRING_CONST(b, "q = request-start,  Q = request-end\n");
 	BUFFER_APPEND_STRING_CONST(b, "s = response-start, S = response-end\n");
 	
-	BUFFER_APPEND_STRING_CONST(b, "<b>");
+	BUFFER_APPEND_STRING_CONST(b, "<strong><span id=\"connections\">");
 	buffer_append_long(b, srv->conns->used);
-	BUFFER_APPEND_STRING_CONST(b, " connections</b>\n");
+	BUFFER_APPEND_STRING_CONST(b, "</span> connections</strong>\n");
 	
 	for (j = 0; j < srv->conns->used; j++) {
 		connection *c = srv->conns->ptr[j];
@@ -462,7 +461,7 @@
 	
 	BUFFER_APPEND_STRING_CONST(b, "\n</pre><hr />\n<h2>Connections</h2>\n");
 	
-	BUFFER_APPEND_STRING_CONST(b, "<table class=\"status\">\n");
+	BUFFER_APPEND_STRING_CONST(b, "<table class=\"status\" summary=\"Current connections\" id=\"clients\">\n");
 	BUFFER_APPEND_STRING_CONST(b, "<tr>");
 	mod_status_header_append_sort(b, p_d, "Client IP");
 	mod_status_header_append_sort(b, p_d, "Read");
@@ -477,11 +476,11 @@
 	for (j = 0; j < srv->conns->used; j++) {
 		connection *c = srv->conns->ptr[j];
 		
-		BUFFER_APPEND_STRING_CONST(b, "<tr><td class=\"string\">");
+		BUFFER_APPEND_STRING_CONST(b, "<tr><td class=\"string ip\">");
 		
 		buffer_append_string(b, inet_ntop_cache_get_ip(srv, &(c->dst_addr)));
 		
-		BUFFER_APPEND_STRING_CONST(b, "</td><td class=\"int\">");
+		BUFFER_APPEND_STRING_CONST(b, "</td><td class=\"int bytes_read\">");
 		
 		if (con->request.content_length) {
 			buffer_append_long(b, c->request_content_queue->bytes_in);
@@ -491,21 +490,21 @@
 			BUFFER_APPEND_STRING_CONST(b, "0/0");
 		}
 	
-		BUFFER_APPEND_STRING_CONST(b, "</td><td class=\"int\">");
+		BUFFER_APPEND_STRING_CONST(b, "</td><td class=\"int bytes_written\">");
 		
 		buffer_append_off_t(b, chunkqueue_written(c->write_queue));
 		BUFFER_APPEND_STRING_CONST(b, "/");
 		buffer_append_off_t(b, chunkqueue_length(c->write_queue));
 		
-		BUFFER_APPEND_STRING_CONST(b, "</td><td class=\"string\">");
+		BUFFER_APPEND_STRING_CONST(b, "</td><td class=\"string state\">");
 		
 		buffer_append_string(b, connection_get_state(c->state));
 		
-		BUFFER_APPEND_STRING_CONST(b, "</td><td class=\"int\">");
+		BUFFER_APPEND_STRING_CONST(b, "</td><td class=\"int time\">");
 		
 		buffer_append_long(b, srv->cur_ts - c->request_start);
 		
-		BUFFER_APPEND_STRING_CONST(b, "</td><td class=\"string\">");
+		BUFFER_APPEND_STRING_CONST(b, "</td><td class=\"string host\">");
 		
 		if (buffer_is_empty(c->server_name)) {
 			buffer_append_string_buffer(b, c->uri.authority);
@@ -514,13 +513,13 @@
 			buffer_append_string_buffer(b, c->server_name);
 		}
 		
-		BUFFER_APPEND_STRING_CONST(b, "</td><td class=\"string\">");
+		BUFFER_APPEND_STRING_CONST(b, "</td><td class=\"string uri\">");
 		
 		if (!buffer_is_empty(c->uri.path)) {
 			buffer_append_string_encoded(b, CONST_BUF_LEN(c->uri.path), ENCODING_HTML);
 		}
 		
-		BUFFER_APPEND_STRING_CONST(b, "</td><td class=\"string\">");
+		BUFFER_APPEND_STRING_CONST(b, "</td><td class=\"string file\">");
 		
 		buffer_append_string_buffer(b, c->physical.path);
 		
@@ -723,16 +722,14 @@
 	return HANDLER_FINISHED;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_status_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(status_url);
-	PATCH(config_url);
-	PATCH(sort);
-	PATCH(statistics_url);
+	PATCH_OPTION(status_url);
+	PATCH_OPTION(config_url);
+	PATCH_OPTION(sort);
+	PATCH_OPTION(statistics_url);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -747,13 +744,13 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("status.status-url"))) {
-				PATCH(status_url);
+				PATCH_OPTION(status_url);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("status.config-url"))) {
-				PATCH(config_url);
+				PATCH_OPTION(config_url);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("status.enable-sort"))) {
-				PATCH(sort);
+				PATCH_OPTION(sort);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("status.statistics-url"))) {
-				PATCH(statistics_url);
+				PATCH_OPTION(statistics_url);
 			} 
 		}
 	}
--- lighttpd-1.4.11/src/mod_trigger_b4_dl.c	2005-09-23 22:53:55.000000000 +0300
+++ lighttpd/src/mod_trigger_b4_dl.c	2006-07-11 21:23:39.991849214 +0300
@@ -241,25 +241,23 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_trigger_b4_dl_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
 #if defined(HAVE_GDBM)
-	PATCH(db);
+	PATCH_OPTION(db);
 #endif	
 #if defined(HAVE_PCRE_H)
-	PATCH(download_regex);
-	PATCH(trigger_regex);
+	PATCH_OPTION(download_regex);
+	PATCH_OPTION(trigger_regex);
 #endif	
-	PATCH(trigger_timeout);
-	PATCH(deny_url);
-	PATCH(mc_namespace);
-	PATCH(debug);
+	PATCH_OPTION(trigger_timeout);
+	PATCH_OPTION(deny_url);
+	PATCH_OPTION(mc_namespace);
+	PATCH_OPTION(debug);
 #if defined(HAVE_MEMCACHE_H)
-	PATCH(mc);
+	PATCH_OPTION(mc);
 #endif
 	
 	/* skip the first, the global context */
@@ -276,27 +274,27 @@
 
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("trigger-before-download.download-url"))) {
 #if defined(HAVE_PCRE_H)
-				PATCH(download_regex);
+				PATCH_OPTION(download_regex);
 #endif
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("trigger-before-download.trigger-url"))) {
 # if defined(HAVE_PCRE_H)
-				PATCH(trigger_regex);
+				PATCH_OPTION(trigger_regex);
 # endif
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("trigger-before-download.gdbm-filename"))) {
 #if defined(HAVE_GDBM_H)
-				PATCH(db);
+				PATCH_OPTION(db);
 #endif
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("trigger-before-download.trigger-timeout"))) {
-				PATCH(trigger_timeout);
+				PATCH_OPTION(trigger_timeout);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("trigger-before-download.debug"))) {
-				PATCH(debug);
+				PATCH_OPTION(debug);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("trigger-before-download.deny-url"))) {
-				PATCH(deny_url);
+				PATCH_OPTION(deny_url);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("trigger-before-download.memcache-namespace"))) {
-				PATCH(mc_namespace);
+				PATCH_OPTION(mc_namespace);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("trigger-before-download.memcache-hosts"))) {
 #if defined(HAVE_MEMCACHE_H)
-				PATCH(mc);
+				PATCH_OPTION(mc);
 #endif
 			}
 		}
@@ -304,7 +302,6 @@
 	
 	return 0;
 }
-#undef PATCH
 
 URIHANDLER_FUNC(mod_trigger_b4_dl_uri_handler) {
 	plugin_data *p = p_d;
--- lighttpd-1.4.11/src/mod_userdir.c	2005-10-28 16:48:28.000000000 +0300
+++ lighttpd/src/mod_userdir.c	2006-07-11 21:23:40.091855478 +0300
@@ -10,6 +10,7 @@
 #include "response.h"
 
 #include "plugin.h"
+#include "sys-files.h"
 
 #ifdef HAVE_PWD_H
 #include <pwd.h>
@@ -118,16 +119,14 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_userdir_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(path);
-	PATCH(exclude_user);
-	PATCH(include_user);
-	PATCH(basepath);
+	PATCH_OPTION(path);
+	PATCH_OPTION(exclude_user);
+	PATCH_OPTION(include_user);
+	PATCH_OPTION(basepath);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -142,20 +141,19 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("userdir.path"))) {
-				PATCH(path);
+				PATCH_OPTION(path);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("userdir.exclude-user"))) {
-				PATCH(exclude_user);
+				PATCH_OPTION(exclude_user);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("userdir.include-user"))) {
-				PATCH(include_user);
+				PATCH_OPTION(include_user);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("userdir.basepath"))) {
-				PATCH(basepath);
+				PATCH_OPTION(basepath);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 URIHANDLER_FUNC(mod_userdir_docroot_handler) {
 	plugin_data *p = p_d;
@@ -252,10 +250,10 @@
 		}
 
 		buffer_copy_string_buffer(p->temp_path, p->conf.basepath);
-		BUFFER_APPEND_SLASH(p->temp_path);
+		PATHNAME_APPEND_SLASH(p->temp_path);
 		buffer_append_string_buffer(p->temp_path, p->username);
 	}
-	BUFFER_APPEND_SLASH(p->temp_path);
+	PATHNAME_APPEND_SLASH(p->temp_path);
 	buffer_append_string_buffer(p->temp_path, p->conf.path); 
 
 	if (buffer_is_empty(p->conf.basepath)) {
@@ -268,7 +266,7 @@
 		} 
 	}
 
-	BUFFER_APPEND_SLASH(p->temp_path);
+	PATHNAME_APPEND_SLASH(p->temp_path);
 	buffer_append_string(p->temp_path, rel_url + 1); /* skip the / */
 	buffer_copy_string_buffer(con->physical.path, p->temp_path);
 
--- lighttpd-1.4.11/src/mod_usertrack.c	2006-01-31 15:01:20.000000000 +0200
+++ lighttpd/src/mod_usertrack.c	2006-07-11 21:23:40.115856981 +0300
@@ -136,15 +136,13 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_usertrack_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(cookie_name);
-	PATCH(cookie_domain);
-	PATCH(cookie_max_age);
+	PATCH_OPTION(cookie_name);
+	PATCH_OPTION(cookie_domain);
+	PATCH_OPTION(cookie_max_age);
 	
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -159,18 +157,17 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("usertrack.cookie-name"))) {
-				PATCH(cookie_name);
+				PATCH_OPTION(cookie_name);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("usertrack.cookie-max-age"))) {
-				PATCH(cookie_max_age);
+				PATCH_OPTION(cookie_max_age);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("usertrack.cookie-domain"))) {
-				PATCH(cookie_domain);
+				PATCH_OPTION(cookie_domain);
 			}
 		}
 	}
 	
 	return 0;
 }
-#undef PATCH
 
 URIHANDLER_FUNC(mod_usertrack_uri_handler) {
 	plugin_data *p = p_d;
--- lighttpd-1.4.11/src/mod_webdav.c	2006-03-03 01:28:58.000000000 +0200
+++ lighttpd/src/mod_webdav.c	2006-07-11 21:23:40.123857482 +0300
@@ -3,13 +3,10 @@
 #include <ctype.h>
 #include <stdlib.h>
 #include <string.h>
-#include <dirent.h>
 #include <errno.h>
-#include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
 #include <assert.h>
-#include <sys/mman.h>
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -23,6 +20,11 @@
 #include <sqlite3.h>
 #endif
 
+#if defined(HAVE_LIBXML_H) && defined(HAVE_SQLITE3_H) && defined(HAVE_UUID_H)
+#define USE_LOCKS
+#include <uuid/uuid.h>
+#endif
+
 #include "base.h"
 #include "log.h"
 #include "buffer.h"
@@ -33,6 +35,9 @@
 #include "stream.h"
 #include "stat_cache.h"
 
+#include "sys-files.h"
+#include "sys-mmap.h"
+#include "sys-strings.h"
 
 /**
  * this is a webdav for a lighttpd plugin
@@ -62,6 +67,12 @@
 	sqlite3_stmt *stmt_delete_uri;
 	sqlite3_stmt *stmt_move_uri;
 	sqlite3_stmt *stmt_copy_uri;
+
+	sqlite3_stmt *stmt_remove_lock;
+	sqlite3_stmt *stmt_create_lock;
+	sqlite3_stmt *stmt_read_lock;
+	sqlite3_stmt *stmt_read_lock_by_uri;
+	sqlite3_stmt *stmt_refresh_lock;
 #endif
 } plugin_config;
 
@@ -123,6 +134,12 @@
 				sqlite3_finalize(s->stmt_update_prop);
 				sqlite3_finalize(s->stmt_select_prop);
 				sqlite3_finalize(s->stmt_select_propnames);
+
+				sqlite3_finalize(s->stmt_read_lock);
+				sqlite3_finalize(s->stmt_read_lock_by_uri);
+				sqlite3_finalize(s->stmt_create_lock);
+				sqlite3_finalize(s->stmt_remove_lock);
+				sqlite3_finalize(s->stmt_refresh_lock);
 				sqlite3_close(s->sql);
 			}
 #endif	
@@ -193,6 +210,24 @@
 				return HANDLER_ERROR;
 			}
 
+			if (SQLITE_OK != sqlite3_exec(s->sql,
+					"CREATE TABLE properties ("
+					"  resource TEXT NOT NULL,"
+					"  prop TEXT NOT NULL,"
+					"  ns TEXT NOT NULL,"
+					"  value TEXT NOT NULL,"
+					"  PRIMARY KEY(resource, prop, ns))",
+					NULL, NULL, &err)) {
+
+				if (0 != strcmp(err, "table properties already exists")) {
+					log_error_write(srv, __FILE__, __LINE__, "ss", "can't open transaction:", err);
+					sqlite3_free(err);
+
+					return HANDLER_ERROR;
+				}
+				sqlite3_free(err);
+			}
+
 			if (SQLITE_OK != sqlite3_prepare(s->sql, 
 				CONST_STR_LEN("SELECT value FROM properties WHERE resource = ? AND prop = ? AND ns = ?"), 
 				&(s->stmt_select_prop), &next_stmt)) {
@@ -211,23 +246,6 @@
 				return HANDLER_ERROR;
 			}
 
-			if (SQLITE_OK != sqlite3_exec(s->sql, 
-					"CREATE TABLE properties ("
-					"  resource TEXT NOT NULL,"
-					"  prop TEXT NOT NULL,"
-					"  ns TEXT NOT NULL,"
-					"  value TEXT NOT NULL,"
-					"  PRIMARY KEY(resource, prop, ns))",
-					NULL, NULL, &err)) {
-
-				if (0 != strcmp(err, "table properties already exists")) {
-					log_error_write(srv, __FILE__, __LINE__, "ss", "can't open transaction:", err);
-					sqlite3_free(err);
-
-					return HANDLER_ERROR;
-				}
-				sqlite3_free(err);
-			}
 	
 			if (SQLITE_OK != sqlite3_prepare(s->sql, 
 				CONST_STR_LEN("REPLACE INTO properties (resource, prop, ns, value) VALUES (?, ?, ?, ?)"), 
@@ -273,6 +291,76 @@
 
 				return HANDLER_ERROR;
 			}
+
+			/* LOCKS */
+
+			if (SQLITE_OK != sqlite3_exec(s->sql,
+					"CREATE TABLE locks ("
+					"  locktoken TEXT NOT NULL,"
+					"  resource TEXT NOT NULL,"
+					"  lockscope TEXT NOT NULL,"
+					"  locktype TEXT NOT NULL,"
+					"  owner TEXT NOT NULL,"
+					"  depth INT NOT NULL,"
+					"  timeout TIMESTAMP NOT NULL,"
+					"  PRIMARY KEY(locktoken))",
+					NULL, NULL, &err)) {
+
+				if (0 != strcmp(err, "table locks already exists")) {
+					log_error_write(srv, __FILE__, __LINE__, "ss", "can't open transaction:", err);
+					sqlite3_free(err);
+
+					return HANDLER_ERROR;
+				}
+				sqlite3_free(err);
+			}
+
+			if (SQLITE_OK != sqlite3_prepare(s->sql,
+				CONST_STR_LEN("INSERT INTO locks (locktoken, resource, lockscope, locktype, owner, depth, timeout) VALUES (?,?,?,?,?,?, CURRENT_TIME + 600)"),
+				&(s->stmt_create_lock), &next_stmt)) {
+				/* prepare failed */
+				log_error_write(srv, __FILE__, __LINE__, "ss", "sqlite3_prepare failed", sqlite3_errmsg(s->sql));
+
+				return HANDLER_ERROR;
+			}
+
+			if (SQLITE_OK != sqlite3_prepare(s->sql,
+				CONST_STR_LEN("DELETE FROM locks WHERE locktoken = ?"),
+				&(s->stmt_remove_lock), &next_stmt)) {
+				/* prepare failed */
+				log_error_write(srv, __FILE__, __LINE__, "ss", "sqlite3_prepare failed", sqlite3_errmsg(s->sql));
+
+				return HANDLER_ERROR;
+			}
+
+			if (SQLITE_OK != sqlite3_prepare(s->sql,
+				CONST_STR_LEN("SELECT locktoken, resource, lockscope, locktype, owner, depth, timeout FROM locks WHERE locktoken = ?"),
+				&(s->stmt_read_lock), &next_stmt)) {
+				/* prepare failed */
+				log_error_write(srv, __FILE__, __LINE__, "ss", "sqlite3_prepare failed", sqlite3_errmsg(s->sql));
+
+				return HANDLER_ERROR;
+			}
+
+			if (SQLITE_OK != sqlite3_prepare(s->sql,
+				CONST_STR_LEN("SELECT locktoken, resource, lockscope, locktype, owner, depth, timeout FROM locks WHERE resource = ?"),
+				&(s->stmt_read_lock_by_uri), &next_stmt)) {
+				/* prepare failed */
+				log_error_write(srv, __FILE__, __LINE__, "ss", "sqlite3_prepare failed", sqlite3_errmsg(s->sql));
+
+				return HANDLER_ERROR;
+			}
+
+			if (SQLITE_OK != sqlite3_prepare(s->sql,
+				CONST_STR_LEN("UPDATE locks SET timeout = CURRENT_TIME + 600 WHERE locktoken = ?"),
+				&(s->stmt_refresh_lock), &next_stmt)) {
+				/* prepare failed */
+				log_error_write(srv, __FILE__, __LINE__, "ss", "sqlite3_prepare failed", sqlite3_errmsg(s->sql));
+
+				return HANDLER_ERROR;
+			}
+
+
 #else
 			log_error_write(srv, __FILE__, __LINE__, "s", "Sorry, no sqlite3 and libxml2 support include, compile with --with-webdav-props");
 			return HANDLER_ERROR;
@@ -283,26 +371,30 @@
 	return HANDLER_GO_ON;
 }
 
-#define PATCH(x) \
-	p->conf.x = s->x;
 static int mod_webdav_patch_connection(server *srv, connection *con, plugin_data *p) {
 	size_t i, j;
 	plugin_config *s = p->config_storage[0];
 	
-	PATCH(enabled);
-	PATCH(is_readonly);
-	PATCH(log_xml);
+	PATCH_OPTION(enabled);
+	PATCH_OPTION(is_readonly);
+	PATCH_OPTION(log_xml);
 	
 #ifdef USE_PROPPATCH
-	PATCH(sql);
-	PATCH(stmt_update_prop);
-	PATCH(stmt_delete_prop);
-	PATCH(stmt_select_prop);
-	PATCH(stmt_select_propnames);
-
-	PATCH(stmt_delete_uri);
-	PATCH(stmt_move_uri);
-	PATCH(stmt_copy_uri);
+	PATCH_OPTION(sql);
+	PATCH_OPTION(stmt_update_prop);
+	PATCH_OPTION(stmt_delete_prop);
+	PATCH_OPTION(stmt_select_prop);
+	PATCH_OPTION(stmt_select_propnames);
+
+	PATCH_OPTION(stmt_delete_uri);
+	PATCH_OPTION(stmt_move_uri);
+	PATCH_OPTION(stmt_copy_uri);
+
+	PATCH_OPTION(stmt_remove_lock);
+	PATCH_OPTION(stmt_refresh_lock);
+	PATCH_OPTION(stmt_create_lock);
+	PATCH_OPTION(stmt_read_lock);
+	PATCH_OPTION(stmt_read_lock_by_uri);
 #endif
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -317,22 +409,28 @@
 			data_unset *du = dc->value->data[j];
 			
 			if (buffer_is_equal_string(du->key, CONST_STR_LEN("webdav.activate"))) {
-				PATCH(enabled);
+				PATCH_OPTION(enabled);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("webdav.is-readonly"))) {
-				PATCH(is_readonly);
+				PATCH_OPTION(is_readonly);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("webdav.log-xml"))) {
-				PATCH(log_xml);
+				PATCH_OPTION(log_xml);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("webdav.sqlite-db-name"))) {
 #ifdef USE_PROPPATCH
-				PATCH(sql);
-				PATCH(stmt_update_prop);
-				PATCH(stmt_delete_prop);
-				PATCH(stmt_select_prop);
-				PATCH(stmt_select_propnames);
-				
-				PATCH(stmt_delete_uri);
-				PATCH(stmt_move_uri);
-				PATCH(stmt_copy_uri);
+				PATCH_OPTION(sql);
+				PATCH_OPTION(stmt_update_prop);
+				PATCH_OPTION(stmt_delete_prop);
+				PATCH_OPTION(stmt_select_prop);
+				PATCH_OPTION(stmt_select_propnames);
+
+				PATCH_OPTION(stmt_delete_uri);
+				PATCH_OPTION(stmt_move_uri);
+				PATCH_OPTION(stmt_copy_uri);
+
+				PATCH_OPTION(stmt_remove_lock);
+				PATCH_OPTION(stmt_refresh_lock);
+				PATCH_OPTION(stmt_create_lock);
+				PATCH_OPTION(stmt_read_lock);
+				PATCH_OPTION(stmt_read_lock_by_uri);
 #endif
 			}
 		}
@@ -340,7 +438,6 @@
 	
 	return 0;
 }
-#undef PATCH
 
 URIHANDLER_FUNC(mod_webdav_uri_handler) {
 	plugin_data *p = p_d;
@@ -362,7 +459,7 @@
 		if (p->conf.is_readonly) {
 			response_header_insert(srv, con, CONST_STR_LEN("Allow"), CONST_STR_LEN("PROPFIND"));
 		} else {
-			response_header_insert(srv, con, CONST_STR_LEN("Allow"), CONST_STR_LEN("PROPFIND, DELETE, MKCOL, PUT, MOVE, COPY, PROPPATCH"));
+			response_header_insert(srv, con, CONST_STR_LEN("Allow"), CONST_STR_LEN("PROPFIND, DELETE, MKCOL, PUT, MOVE, COPY, PROPPATCH, LOCK, UNLOCK"));
 		}
 		break;
 	default:
@@ -496,11 +593,11 @@
 			} 
 
 			buffer_copy_string_buffer(d.path, dst->path);
-			BUFFER_APPEND_SLASH(d.path);
+			PATHNAME_APPEND_SLASH(d.path);
 			buffer_append_string(d.path, de->d_name);
 			
 			buffer_copy_string_buffer(d.rel_path, dst->rel_path);
-			BUFFER_APPEND_SLASH(d.rel_path);
+			PATHNAME_APPEND_SLASH(d.rel_path);
 			buffer_append_string(d.rel_path, de->d_name);
 
 			/* stat and unlink afterwards */
@@ -657,19 +754,19 @@
 			}
 			
 			buffer_copy_string_buffer(s.path, src->path);
-			BUFFER_APPEND_SLASH(s.path);
+			PATHNAME_APPEND_SLASH(s.path);
 			buffer_append_string(s.path, de->d_name);
 
 			buffer_copy_string_buffer(d.path, dst->path);
-			BUFFER_APPEND_SLASH(d.path);
+			PATHNAME_APPEND_SLASH(d.path);
 			buffer_append_string(d.path, de->d_name);
 
 			buffer_copy_string_buffer(s.rel_path, src->rel_path);
-			BUFFER_APPEND_SLASH(s.rel_path);
+			PATHNAME_APPEND_SLASH(s.rel_path);
 			buffer_append_string(s.rel_path, de->d_name);
 
 			buffer_copy_string_buffer(d.rel_path, dst->rel_path);
-			BUFFER_APPEND_SLASH(d.rel_path);
+			PATHNAME_APPEND_SLASH(d.rel_path);
 			buffer_append_string(d.rel_path, de->d_name);
 
 			if (-1 == stat(s.path->ptr, &st)) {
@@ -821,9 +918,9 @@
 					  SQLITE_TRANSIENT);
 
 			/* it is the PK */
-			while (SQLITE_ROW == sqlite3_step(p->conf.stmt_select_prop)) {
+			while (SQLITE_ROW == sqlite3_step(stmt)) {
 				/* there is a row for us, we only expect a single col 'value' */
-				webdav_gen_prop_tag(srv, con, prop_name, prop_ns, (char *)sqlite3_column_text(p->conf.stmt_select_prop, 0), b);
+				webdav_gen_prop_tag(srv, con, prop_name, prop_ns, (char *)sqlite3_column_text(stmt, 0), b);
 				found = 1;
 			}
 		}
@@ -991,6 +1088,113 @@
 }
 #endif
 
+int webdav_lockdiscovery(server *srv, connection *con,
+		buffer *locktoken, const char *lockscope, const char *locktype, int depth) {
+
+	buffer *b;
+
+	response_header_overwrite(srv, con, CONST_STR_LEN("Lock-Token"), CONST_BUF_LEN(locktoken));
+
+	response_header_overwrite(srv, con,
+		CONST_STR_LEN("Content-Type"),
+		CONST_STR_LEN("text/xml; charset=\"utf-8\""));
+
+	b = chunkqueue_get_append_buffer(con->write_queue);
+
+	buffer_copy_string(b, "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
+
+	buffer_append_string(b,"<D:prop xmlns:D=\"DAV:\" xmlns:ns0=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">\n");
+	buffer_append_string(b,"<D:lockdiscovery>\n");
+	buffer_append_string(b,"<D:activelock>\n");
+
+	buffer_append_string(b,"<D:lockscope>");
+	buffer_append_string(b,"<D:");
+	buffer_append_string(b, lockscope);
+	buffer_append_string(b, "/>");
+	buffer_append_string(b,"</D:lockscope>\n");
+
+	buffer_append_string(b,"<D:locktype>");
+	buffer_append_string(b,"<D:");
+	buffer_append_string(b, locktype);
+	buffer_append_string(b, "/>");
+	buffer_append_string(b,"</D:locktype>\n");
+
+	buffer_append_string(b,"<D:depth>");
+	buffer_append_string(b, depth == 0 ? "0" : "infinity");
+	buffer_append_string(b,"</D:depth>\n");
+
+	buffer_append_string(b,"<D:timeout>");
+	buffer_append_string(b, "Second-600");
+	buffer_append_string(b,"</D:timeout>\n");
+
+	buffer_append_string(b,"<D:owner>");
+	buffer_append_string(b,"</D:owner>\n");
+
+	buffer_append_string(b,"<D:locktoken>");
+	buffer_append_string(b, "<D:href>");
+	buffer_append_string_buffer(b, locktoken);
+	buffer_append_string(b, "</D:href>");
+	buffer_append_string(b,"</D:locktoken>\n");
+
+	buffer_append_string(b,"</D:activelock>\n");
+	buffer_append_string(b,"</D:lockdiscovery>\n");
+	buffer_append_string(b,"</D:prop>\n");
+
+	return 0;
+}
+/**
+ * check if resource is having the right locks to access to resource
+ *
+ *
+ *
+ */
+int webdav_has_lock(server *srv, connection *con, plugin_data *p, buffer *uri) {
+	int has_lock = 1;
+
+#ifdef USE_LOCKS
+	data_string *ds;
+
+	/**
+	 * If can have
+	 * - <lock-token>
+	 * - [etag]
+	 *
+	 * there is NOT, AND and OR
+	 * and a list can be tagged
+	 *
+	 * (<lock-token>) is untagged
+	 * <tag> (<lock-token>) is tagged
+	 *
+	 * as long as we don't handle collections it is simple. :)
+	 *
+	 * X-Litmus: locks: 11 (owner_modify)
+	 * If: <http://127.0.0.1:1025/dav/litmus/lockme> (<opaquelocktoken:2165478d-0611-49c4-be92-e790d68a38f1>)
+	 *
+	 * X-Litmus: locks: 16 (fail_cond_put)
+	 * If: (<DAV:no-lock> ["-1622396671"])
+	 */
+	if (NULL != (ds = (data_string *)array_get_element(con->request.headers, "If"))) {
+	} else {
+		/* we didn't provided a lock-token -> */
+		/* if the resource is locked -> 423 */
+
+		sqlite3_stmt *stmt = p->conf.stmt_read_lock_by_uri;
+
+		sqlite3_reset(stmt);
+
+		sqlite3_bind_text(stmt, 1,
+			  CONST_BUF_LEN(uri),
+			  SQLITE_TRANSIENT);
+
+		while (SQLITE_ROW == sqlite3_step(stmt)) {
+			has_lock = 0;
+		}
+	}
+#endif
+
+	return has_lock;
+}
+
 URIHANDLER_FUNC(mod_webdav_subrequest_handler) {
 	plugin_data *p = p_d;
 	buffer *b;
@@ -1001,6 +1205,7 @@
 	buffer *prop_200;
 	buffer *prop_404;
 	webdav_properties *req_props;
+	stat_cache_entry *sce = NULL;
 	
 	UNUSED(srv);
 
@@ -1020,6 +1225,18 @@
 
 		/* is there a content-body ? */
 	
+		switch (stat_cache_get_entry(srv, con, con->physical.path, &sce)) {
+		case HANDLER_ERROR:
+			if (errno == ENOENT) {
+				con->http_status = 404;
+				return HANDLER_FINISHED;
+			}
+			break;
+		default:
+			break;
+		}
+
+
 #ifdef USE_PROPPATCH
 		/* any special requests or just allprop ? */
 		if (con->request.content_length) {
@@ -1182,10 +1399,10 @@
 					} 
 
 					buffer_copy_string_buffer(d.path, dst->path);
-					BUFFER_APPEND_SLASH(d.path);
+					PATHNAME_APPEND_SLASH(d.path);
 
 					buffer_copy_string_buffer(d.rel_path, dst->rel_path);
-					BUFFER_APPEND_SLASH(d.rel_path);
+					PATHNAME_APPEND_SLASH(d.rel_path);
 
 					if (de->d_name[0] == '.' && de->d_name[1] == '\0') {
 						/* don't append the . */ 
@@ -1304,6 +1521,12 @@
 			return HANDLER_FINISHED;
 		}
 		
+		/* does the client have a lock for this connection ? */
+		if (!webdav_has_lock(srv, con, p, con->uri.path)) {
+			con->http_status = 423;
+			return HANDLER_FINISHED;
+		}
+
 		/* stat and unlink afterwards */
 		if (-1 == stat(con->physical.path->ptr, &st)) {
 			/* don't about it yet, unlink will fail too */
@@ -1375,22 +1598,100 @@
 	case HTTP_METHOD_PUT: {
 		int fd;
 		chunkqueue *cq = con->request_content_queue;
+		chunk *c;
+		data_string *ds_range;
 
 		if (p->conf.is_readonly) {
 			con->http_status = 403;
 			return HANDLER_FINISHED;
 		}
 
+		/* is a exclusive lock set on the source */
+		if (!webdav_has_lock(srv, con, p, con->uri.path)) {
+			con->http_status = 423;
+			return HANDLER_FINISHED;
+		}
+
+
 		assert(chunkqueue_length(cq) == (off_t)con->request.content_length);
 
-		/* taken what we have in the request-body and write it to a file */
-		if (-1 == (fd = open(con->physical.path->ptr, O_WRONLY|O_CREAT|O_TRUNC, 0600))) {
+		/* RFC2616 Section 9.6 PUT requires us to send 501 on all Content-* we don't support
+		 * - most important Content-Range
+		 *
+		 *
+		 * Example: Content-Range: bytes 100-1037/1038 */
+
+		if (NULL != (ds_range = (data_string *)array_get_element(con->request.headers, "Content-Range"))) {
+			const char *num = ds_range->value->ptr;
+			off_t offset;
+			char *err = NULL;
+
+			if (0 != strncmp(num, "bytes ", 6)) {
+				con->http_status = 501; /* not implemented */
+
+				return HANDLER_FINISHED;
+			}
+
+			/* we only support <num>- ... */
+
+			num += 6;
+
+			/* skip WS */
+			while (*num == ' ' || *num == '\t') num++;
+
+			if (*num == '\0') {
+				con->http_status = 501; /* not implemented */
+
+				return HANDLER_FINISHED;
+			}
+
+			offset = strtoll(num, &err, 10);
+
+			if (*err != '-' || offset < 0) {
+				con->http_status = 501; /* not implemented */
+
+				return HANDLER_FINISHED;
+			}
+
+			if (-1 == (fd = open(con->physical.path->ptr, O_WRONLY, 0600))) {
+				switch (errno) {
+				case ENOENT:
+					con->http_status = 404; /* not found */
+					break;
+				default:
+					con->http_status = 403; /* not found */
+					break;
+				}
+				return HANDLER_FINISHED;
+			}
+
+			if (-1 == lseek(fd, offset, SEEK_SET)) {
+				con->http_status = 501; /* not implemented */
+
+				close(fd);
+
+				return HANDLER_FINISHED;
+			}
+			con->http_status = 200; /* modified */
+		} else {
+			/* take what we have in the request-body and write it to a file */
+
+			/* if the file doesn't exist, create it */
+			if (-1 == (fd = open(con->physical.path->ptr, O_WRONLY|O_TRUNC, 0600))) {
+				if (errno == ENOENT &&
+				    -1 == (fd = open(con->physical.path->ptr, O_WRONLY|O_CREAT|O_TRUNC|O_EXCL, 0600))) {
 			/* we can't open the file */
 			con->http_status = 403;
-		} else {
-			chunk *c;
 
+					return HANDLER_FINISHED;
+				} else {
 			con->http_status = 201; /* created */
+				}
+			} else {
+				con->http_status = 200; /* modified */
+			}
+		}
+
 			con->file_finished = 1;
 
 			for (c = cq->first; c; c = cq->first) {
@@ -1462,7 +1763,6 @@
 			}
 			close(fd);
 
-		}
 		return HANDLER_FINISHED;
 	}
 	case HTTP_METHOD_MOVE: 
@@ -1476,6 +1776,14 @@
 			return HANDLER_FINISHED;
 		}
 		
+		/* is a exclusive lock set on the source */
+		if (con->request.http_method == HTTP_METHOD_MOVE) {
+			if (!webdav_has_lock(srv, con, p, con->uri.path)) {
+				con->http_status = 423;
+				return HANDLER_FINISHED;
+			}
+		}
+
 		if (NULL != (ds = (data_string *)array_get_element(con->request.headers, "Destination"))) {
 			destination = ds->value;
 		} else {
@@ -1549,7 +1857,7 @@
 		}
 
 		buffer_copy_string_buffer(p->physical.path, p->physical.doc_root);
-		BUFFER_APPEND_SLASH(p->physical.path);
+		PATHNAME_APPEND_SLASH(p->physical.path);
 		buffer_copy_string_buffer(p->physical.basedir, p->physical.path);
 
 		/* don't add a second / */ 
@@ -1613,6 +1921,12 @@
 			/* it is just a file, good */
 			int r;
 
+			/* does the client have a lock for this connection ? */
+			if (!webdav_has_lock(srv, con, p, p->uri.path)) {
+				con->http_status = 423;
+				return HANDLER_FINISHED;
+			}
+
 			/* destination exists */
 			if (0 == (r = stat(p->physical.path->ptr, &st))) {
 				if (S_ISDIR(st.st_mode)) {
@@ -1691,12 +2005,17 @@
 
 		return HANDLER_FINISHED;
 	}
-	case HTTP_METHOD_PROPPATCH: {
+	case HTTP_METHOD_PROPPATCH:
 		if (p->conf.is_readonly) {
 			con->http_status = 403;
 			return HANDLER_FINISHED;
 		}
 
+		if (!webdav_has_lock(srv, con, p, con->uri.path)) {
+			con->http_status = 423;
+			return HANDLER_FINISHED;
+		}
+
 		/* check if destination exists */
 		if (-1 == stat(con->physical.path->ptr, &st)) {
 			switch(errno) {
@@ -1789,7 +2108,8 @@
 									}
 								
 									if (SQLITE_DONE != (r = sqlite3_step(stmt))) {
-										log_error_write(srv, __FILE__, __LINE__, "ss", "sql-set failed:", sqlite3_errmsg(p->conf.sql));
+										log_error_write(srv, __FILE__, __LINE__, "ss",
+												"sql-set failed:", sqlite3_errmsg(p->conf.sql));
 									}
 								}
 							}
@@ -1821,6 +2141,7 @@
 				}
 
 propmatch_cleanup:
+
 				xmlFreeDoc(xml);
 			} else {
 				con->http_status = 400;
@@ -1830,7 +2151,303 @@
 #endif
 		con->http_status = 501;
 		return HANDLER_FINISHED;
+	case HTTP_METHOD_LOCK:
+		/**
+		 * a mac wants to write
+		 *
+		 * LOCK /dav/expire.txt HTTP/1.1\r\n
+		 * User-Agent: WebDAVFS/1.3 (01308000) Darwin/8.1.0 (Power Macintosh)\r\n
+		 * Accept: * / *\r\n
+		 * Depth: 0\r\n
+		 * Timeout: Second-600\r\n
+		 * Content-Type: text/xml; charset=\"utf-8\"\r\n
+		 * Content-Length: 229\r\n
+		 * Connection: keep-alive\r\n
+		 * Host: 192.168.178.23:1025\r\n
+		 * \r\n
+		 * <?xml version=\"1.0\" encoding=\"utf-8\"?>\n
+		 * <D:lockinfo xmlns:D=\"DAV:\">\n
+		 *  <D:lockscope><D:exclusive/></D:lockscope>\n
+		 *  <D:locktype><D:write/></D:locktype>\n
+		 *  <D:owner>\n
+		 *   <D:href>http://www.apple.com/webdav_fs/</D:href>\n
+		 *  </D:owner>\n
+		 * </D:lockinfo>\n
+		 */
+
+		if (depth != 0 && depth != -1) {
+			con->http_status = 400;
+
+			return HANDLER_FINISHED;
+		}
+
+#ifdef USE_LOCKS
+		if (con->request.content_length) {
+			xmlDocPtr xml;
+			buffer *hdr_if = NULL;
+
+			if (NULL != (ds = (data_string *)array_get_element(con->request.headers, "If"))) {
+				hdr_if = ds->value;
+			}
+
+			/* we don't support Depth: Infinity on locks */
+			if (hdr_if == NULL && depth == -1) {
+				con->http_status = 409; /* Conflict */
+
+				return HANDLER_FINISHED;
+			}
+
+			if (1 == webdav_parse_chunkqueue(srv, con, p, con->request_content_queue, &xml)) {
+				xmlNode *rootnode = xmlDocGetRootElement(xml);
+
+				assert(rootnode);
+
+				if (0 == xmlStrcmp(rootnode->name, BAD_CAST "lockinfo")) {
+					xmlNode *lockinfo;
+					const xmlChar *lockscope = NULL, *locktype = NULL, *owner = NULL;
+
+					for (lockinfo = rootnode->children; lockinfo; lockinfo = lockinfo->next) {
+						if (0 == xmlStrcmp(lockinfo->name, BAD_CAST "lockscope")) {
+							xmlNode *value;
+							for (value = lockinfo->children; value; value = value->next) {
+								if ((0 == xmlStrcmp(value->name, BAD_CAST "exclusive")) ||
+								    (0 == xmlStrcmp(value->name, BAD_CAST "shared"))) {
+									lockscope = value->name;
+								} else {
+									con->http_status = 400;
+
+									xmlFreeDoc(xml);
+									return HANDLER_FINISHED;
+								}
+							}
+						} else if (0 == xmlStrcmp(lockinfo->name, BAD_CAST "locktype")) {
+							xmlNode *value;
+							for (value = lockinfo->children; value; value = value->next) {
+								if ((0 == xmlStrcmp(value->name, BAD_CAST "write"))) {
+									locktype = value->name;
+								} else {
+									con->http_status = 400;
+
+									xmlFreeDoc(xml);
+									return HANDLER_FINISHED;
+								}
+							}
+
+						} else if (0 == xmlStrcmp(lockinfo->name, BAD_CAST "owner")) {
+						}
+					}
+
+					if (lockscope && locktype) {
+						sqlite3_stmt *stmt = p->conf.stmt_read_lock_by_uri;
+
+						/* is this resourse already locked ? */
+
+						/* SELECT locktoken, resource, lockscope, locktype, owner, depth, timeout
+						 *   FROM locks
+						 *  WHERE resource = ? */
+
+						if (stmt) {
+
+							sqlite3_reset(stmt);
+
+							sqlite3_bind_text(stmt, 1,
+									  p->uri.path->ptr,
+									  p->uri.path->used - 1,
+									  SQLITE_TRANSIENT);
+
+							/* it is the PK */
+							while (SQLITE_ROW == sqlite3_step(stmt)) {
+								/* we found a lock
+								 * 1. is it compatible ?
+								 * 2. is it ours */
+								char *sql_lockscope = (char *)sqlite3_column_text(stmt, 2);
+
+								if (strcmp(sql_lockscope, "exclusive")) {
+									con->http_status = 423;
+								} else if (0 == xmlStrcmp(lockscope, BAD_CAST "exclusive")) {
+									/* resourse is locked with a shared lock
+									 * client wants exclusive */
+									con->http_status = 423;
+								}
+							}
+							if (con->http_status == 423) {
+								xmlFreeDoc(xml);
+								return HANDLER_FINISHED;
+							}
 	}
+
+						stmt = p->conf.stmt_create_lock;
+						if (stmt) {
+							/* create a lock-token */
+							uuid_t id;
+							char uuid[37] /* 36 + \0 */;
+
+							uuid_generate(id);
+							uuid_unparse(id, uuid);
+
+							buffer_copy_string(p->tmp_buf, "opaquelocktoken:");
+							buffer_append_string(p->tmp_buf, uuid);
+
+							/* "CREATE TABLE locks ("
+							 * "  locktoken TEXT NOT NULL,"
+							 * "  resource TEXT NOT NULL,"
+							 * "  lockscope TEXT NOT NULL,"
+							 * "  locktype TEXT NOT NULL,"
+							 * "  owner TEXT NOT NULL,"
+							 * "  depth INT NOT NULL,"
+							 */
+
+							sqlite3_reset(stmt);
+
+							sqlite3_bind_text(stmt, 1,
+									  CONST_BUF_LEN(p->tmp_buf),
+									  SQLITE_TRANSIENT);
+
+							sqlite3_bind_text(stmt, 2,
+									  CONST_BUF_LEN(con->uri.path),
+									  SQLITE_TRANSIENT);
+
+							sqlite3_bind_text(stmt, 3,
+									  lockscope,
+									  xmlStrlen(lockscope),
+									  SQLITE_TRANSIENT);
+
+							sqlite3_bind_text(stmt, 4,
+									  locktype,
+									  xmlStrlen(locktype),
+									  SQLITE_TRANSIENT);
+
+							/* owner */
+							sqlite3_bind_text(stmt, 5,
+									  "",
+									  0,
+									  SQLITE_TRANSIENT);
+
+							/* depth */
+							sqlite3_bind_int(stmt, 6,
+									 depth);
+
+
+							if (SQLITE_DONE != sqlite3_step(stmt)) {
+								log_error_write(srv, __FILE__, __LINE__, "ss",
+										"create lock:", sqlite3_errmsg(p->conf.sql));
+							}
+
+							/* looks like we survived */
+							webdav_lockdiscovery(srv, con, p->tmp_buf, lockscope, locktype, depth);
+
+							con->http_status = 201;
+							con->file_finished = 1;
+						}
+					}
+				}
+
+				xmlFreeDoc(xml);
+				return HANDLER_FINISHED;
+			} else {
+				con->http_status = 400;
+				return HANDLER_FINISHED;
+			}
+		} else {
+
+			if (NULL != (ds = (data_string *)array_get_element(con->request.headers, "If"))) {
+				buffer *locktoken = ds->value;
+				sqlite3_stmt *stmt = p->conf.stmt_refresh_lock;
+
+				/* remove the < > around the token */
+				if (locktoken->used < 6) {
+					con->http_status = 400;
+
+					return HANDLER_FINISHED;
+				}
+
+				buffer_copy_string_len(p->tmp_buf, locktoken->ptr + 2, locktoken->used - 5);
+
+				sqlite3_reset(stmt);
+
+				sqlite3_bind_text(stmt, 1,
+					  CONST_BUF_LEN(p->tmp_buf),
+					  SQLITE_TRANSIENT);
+
+				if (SQLITE_DONE != sqlite3_step(stmt)) {
+					log_error_write(srv, __FILE__, __LINE__, "ss",
+						"refresh lock:", sqlite3_errmsg(p->conf.sql));
+				}
+
+				webdav_lockdiscovery(srv, con, p->tmp_buf, "exclusive", "write", 0);
+
+				con->http_status = 200;
+				con->file_finished = 1;
+				return HANDLER_FINISHED;
+			} else {
+				/* we need a lock-token to refresh */
+				con->http_status = 400;
+
+				return HANDLER_FINISHED;
+			}
+		}
+		break;
+#else
+		con->http_status = 501;
+		return HANDLER_FINISHED;
+#endif
+	case HTTP_METHOD_UNLOCK:
+#ifdef USE_LOCKS
+		if (NULL != (ds = (data_string *)array_get_element(con->request.headers, "Lock-Token"))) {
+			buffer *locktoken = ds->value;
+			sqlite3_stmt *stmt = p->conf.stmt_remove_lock;
+
+			/* remove the < > around the token */
+			if (locktoken->used < 4) {
+				con->http_status = 400;
+
+				return HANDLER_FINISHED;
+			}
+
+			/**
+			 * FIXME:
+			 *
+			 * if the resourse is locked:
+			 * - by us: unlock
+			 * - by someone else: 401
+			 * if the resource is not locked:
+			 * - 412
+			 *  */
+
+			buffer_copy_string_len(p->tmp_buf, locktoken->ptr + 1, locktoken->used - 3);
+
+			sqlite3_reset(stmt);
+
+			sqlite3_bind_text(stmt, 1,
+				  CONST_BUF_LEN(p->tmp_buf),
+				  SQLITE_TRANSIENT);
+
+			sqlite3_bind_text(stmt, 2,
+				  CONST_BUF_LEN(con->uri.path),
+				  SQLITE_TRANSIENT);
+
+			if (SQLITE_DONE != sqlite3_step(stmt)) {
+				log_error_write(srv, __FILE__, __LINE__, "ss",
+					"remove lock:", sqlite3_errmsg(p->conf.sql));
+			}
+
+			if (0 == sqlite3_changes(p->conf.sql)) {
+				con->http_status = 401;
+			} else {
+				con->http_status = 204;
+			}
+			return HANDLER_FINISHED;
+		} else {
+			/* we need a lock-token to unlock */
+			con->http_status = 400;
+
+			return HANDLER_FINISHED;
+		}
+		break;
+#else
+		con->http_status = 501;
+		return HANDLER_FINISHED;
+#endif
 	default:
 		break;
 	}
--- lighttpd-1.4.11/src/network.c	2006-03-04 16:45:46.000000000 +0200
+++ lighttpd/src/network.c	2006-07-11 21:23:39.983848713 +0300
@@ -1,14 +1,14 @@
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/time.h>
 
 #include <errno.h>
 #include <fcntl.h>
-#include <unistd.h>
 #include <string.h>
 #include <stdlib.h>
 #include <assert.h>
 
+#include <stdio.h>
+
 #include "network.h"
 #include "fdevent.h"
 #include "log.h"
@@ -19,6 +19,7 @@
 #include "network_backends.h"
 #include "sys-mmap.h"
 #include "sys-socket.h"
+#include "sys-files.h"
 
 #ifdef USE_OPENSSL
 # include <openssl/ssl.h> 
@@ -77,7 +78,7 @@
 	struct accept_filter_arg afa;
 #endif
 
-#ifdef __WIN32
+#ifdef _WIN32
 	WORD wVersionRequested;
 	WSADATA wsaData;
 	int err;
@@ -244,6 +245,7 @@
 		addr_len = sizeof(struct sockaddr_in);
 		
 		break;
+#ifndef _WIN32
 	case AF_UNIX:
 		srv_socket->addr.un.sun_family = AF_UNIX;
 		strcpy(srv_socket->addr.un.sun_path, host);
@@ -283,6 +285,7 @@
 		}
 
 		break;
+#endif
 	default:
 		addr_len = 0;
 		
@@ -404,7 +407,6 @@
 	}
 	
 	srv->srv_sockets.ptr[srv->srv_sockets.used++] = srv_socket;
-	
 	buffer_free(b);
 	
 	return 0;
@@ -425,11 +427,20 @@
 			close(srv_socket->fd);
 		}
 		
+		if (srv_socket->is_ssl) {
+#ifdef USE_OPENSSL
+			SSL_CTX_free(srv_socket->ssl_ctx);
+#endif
+		}
+
 		buffer_free(srv_socket->srv_token);
 		
 		free(srv_socket);
 	}
 	
+#ifdef USE_OPENSSL
+	ERR_free_strings();
+#endif
 	free(srv->srv_sockets.ptr);
 	
 	return 0;
@@ -437,11 +448,15 @@
 
 typedef enum {
 	NETWORK_BACKEND_UNSET,
+
 	NETWORK_BACKEND_WRITE,
 	NETWORK_BACKEND_WRITEV,
 	NETWORK_BACKEND_LINUX_SENDFILE,
 	NETWORK_BACKEND_FREEBSD_SENDFILE,
-	NETWORK_BACKEND_SOLARIS_SENDFILEV
+	NETWORK_BACKEND_SOLARIS_SENDFILEV,
+
+    NETWORK_BACKEND_WIN32_SEND,
+    NETWORK_BACKEND_WIN32_TRANSMITFILE,
 } network_backend_t;
 
 int network_init(server *srv) {
@@ -466,7 +481,16 @@
 #if defined USE_WRITEV
 		{ NETWORK_BACKEND_WRITEV,		"writev" },
 #endif
+#if defined USE_WRITE
 		{ NETWORK_BACKEND_WRITE,		"write" },
+#endif
+#if defined USE_WIN32_TRANSMITFILE
+		{ NETWORK_BACKEND_WIN32_TRANSMITFILE,	"win32-transmitfile" },
+#endif
+#if defined USE_WIN32_SEND
+		{ NETWORK_BACKEND_WIN32_SEND,	    	"win32-send" },
+#endif
+
 		{ NETWORK_BACKEND_UNSET,        	NULL }
 	};
 	
@@ -508,33 +532,59 @@
 		}
 	}
 
+#define SET_NETWORK_BACKEND(read, write) \
+    srv->network_backend_write = network_write_chunkqueue_##write;\
+    srv->network_backend_read = network_read_chunkqueue_##read
+
+#define SET_NETWORK_BACKEND_SSL(read, write) \
+    srv->network_ssl_backend_write = network_write_chunkqueue_##write;\
+    srv->network_ssl_backend_read = network_read_chunkqueue_##read
+
 	switch(backend) {
+
+#ifdef USE_WIN32_SEND
+	case NETWORK_BACKEND_WIN32_SEND:
+        SET_NETWORK_BACKEND(win32recv, win32send);
+		break;
+#ifdef USE_WIN32_TRANSMITFILE
+	case NETWORK_BACKEND_WIN32_TRANSMITFILE:
+        SET_NETWORK_BACKEND(win32recv, win32transmitfile);
+		break;
+#endif
+#endif
+
+#ifdef USE_WRITE
 	case NETWORK_BACKEND_WRITE:
-		srv->network_backend_write = network_write_chunkqueue_write;
+        SET_NETWORK_BACKEND(read, write);
 		break;
+
 #ifdef USE_WRITEV
 	case NETWORK_BACKEND_WRITEV:
-		srv->network_backend_write = network_write_chunkqueue_writev;
+        SET_NETWORK_BACKEND(read, writev);
 		break;
 #endif
 #ifdef USE_LINUX_SENDFILE
 	case NETWORK_BACKEND_LINUX_SENDFILE:
-		srv->network_backend_write = network_write_chunkqueue_linuxsendfile; 
+        SET_NETWORK_BACKEND(read, linuxsendfile);
 		break;
 #endif
 #ifdef USE_FREEBSD_SENDFILE
 	case NETWORK_BACKEND_FREEBSD_SENDFILE:
-		srv->network_backend_write = network_write_chunkqueue_freebsdsendfile; 
+        SET_NETWORK_BACKEND(read, freebsdsendfile);
 		break;
 #endif
 #ifdef USE_SOLARIS_SENDFILEV
 	case NETWORK_BACKEND_SOLARIS_SENDFILEV:
-		srv->network_backend_write = network_write_chunkqueue_solarissendfilev; 
+        SET_NETWORK_BACKEND(read, solarissendfilev);
 		break;
 #endif
+#endif
 	default:
 		return -1;
 	}
+#ifdef USE_OPENSSL
+        SET_NETWORK_BACKEND_SSL(openssl, openssl);
+#endif
 
 	/* check for $SERVER["socket"] */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -569,23 +619,34 @@
 
 int network_register_fdevents(server *srv) {
 	size_t i;
-	
 	if (-1 == fdevent_reset(srv->ev)) {
 		return -1;
 	}
-	
 	/* register fdevents after reset */
 	for (i = 0; i < srv->srv_sockets.used; i++) {
 		server_socket *srv_socket = srv->srv_sockets.ptr[i];
-		
 		fdevent_register(srv->ev, srv_socket->fd, network_server_handle_fdevent, srv_socket);
 		fdevent_event_add(srv->ev, &(srv_socket->fde_ndx), srv_socket->fd, FDEVENT_IN);
 	}
 	return 0;
 }
 
-int network_write_chunkqueue(server *srv, connection *con, chunkqueue *cq) {
-	int ret = -1;
+network_status_t network_read_chunkqueue(server *srv, connection *con, chunkqueue *cq) {
+    server_socket *srv_socket = con->srv_socket;
+
+   	if (srv_socket->is_ssl) {
+#ifdef USE_OPENSSL
+		return srv->network_ssl_backend_read(srv, con, con->ssl, cq);
+#else
+		return NETWORK_STATUS_FATAL_ERROR;
+#endif
+	} else {
+		return srv->network_backend_read(srv, con, con->fd, cq);
+	}
+}
+
+network_status_t network_write_chunkqueue(server *srv, connection *con, chunkqueue *cq) {
+	network_status_t ret = NETWORK_STATUS_UNSET;
 	off_t written = 0;
 #ifdef TCP_CORK	
 	int corked = 0;
@@ -622,9 +683,14 @@
 		ret = srv->network_backend_write(srv, con, con->fd, cq);
 	}
 	
-	if (ret >= 0) {
+    switch (ret) {
+    case NETWORK_STATUS_WAIT_FOR_EVENT:
+    case NETWORK_STATUS_SUCCESS:
 		chunkqueue_remove_finished_chunks(cq);
-		ret = chunkqueue_is_empty(cq) ? 0 : 1;
+
+        break;
+    default:
+        break;
 	}
 	
 #ifdef TCP_CORK
--- lighttpd-1.4.11/src/network.h	2005-08-11 01:26:42.000000000 +0300
+++ lighttpd/src/network.h	2006-07-11 21:23:39.983848713 +0300
@@ -3,7 +3,8 @@
 
 #include "server.h"
 
-int network_write_chunkqueue(server *srv, connection *con, chunkqueue *c);
+network_status_t network_write_chunkqueue(server *srv, connection *con, chunkqueue *c);
+network_status_t network_read_chunkqueue(server *srv, connection *con, chunkqueue *c);
 
 int network_init(server *srv);
 int network_close(server *srv);
--- lighttpd-1.4.11/src/network_backends.h	2005-10-24 15:13:51.000000000 +0300
+++ lighttpd/src/network_backends.h	2006-07-11 21:23:40.035851970 +0300
@@ -43,16 +43,52 @@
 # define USE_AIX_SENDFILE
 #endif
 
+/**
+* unix can use read/write or recv/send on sockets
+* win32 only recv/send
+*/
+#ifdef _WIN32
+# define USE_WIN32_SEND
+/* wait for async-io support
+# define USE_WIN32_TRANSMITFILE
+*/
+#else
+# define USE_WRITE
+#endif
+
 #include "base.h"
+#include "network.h"
+
+#define NETWORK_BACKEND_WRITE_CHUNK(x) \
+    network_status_t network_write_chunkqueue_##x(server *srv, connection *con, int fd, chunkqueue *cq, chunk *c)
+
+#define NETWORK_BACKEND_WRITE(x) \
+    network_status_t network_write_chunkqueue_##x(server *srv, connection *con, int fd, chunkqueue *cq)
+#define NETWORK_BACKEND_READ(x) \
+    network_status_t network_read_chunkqueue_##x(server *srv, connection *con, int fd, chunkqueue *cq)
 
+NETWORK_BACKEND_WRITE_CHUNK(writev_mem);
+
+NETWORK_BACKEND_WRITE(write);
+NETWORK_BACKEND_WRITE(writev);
+NETWORK_BACKEND_WRITE(linuxsendfile);
+NETWORK_BACKEND_WRITE(freebsdsendfile);
+NETWORK_BACKEND_WRITE(solarissendfilev);
+
+NETWORK_BACKEND_WRITE(win32transmitfile);
+NETWORK_BACKEND_WRITE(win32send);
+
+NETWORK_BACKEND_READ(read);
+NETWORK_BACKEND_READ(win32recv);
 
-int network_write_chunkqueue_write(server *srv, connection *con, int fd, chunkqueue *cq);
-int network_write_chunkqueue_writev(server *srv, connection *con, int fd, chunkqueue *cq);
-int network_write_chunkqueue_linuxsendfile(server *srv, connection *con, int fd, chunkqueue *cq);
-int network_write_chunkqueue_freebsdsendfile(server *srv, connection *con, int fd, chunkqueue *cq);
-int network_write_chunkqueue_solarissendfilev(server *srv, connection *con, int fd, chunkqueue *cq);
 #ifdef USE_OPENSSL
-int network_write_chunkqueue_openssl(server *srv, connection *con, SSL *ssl, chunkqueue *cq);
+#define NETWORK_BACKEND_WRITE_SSL(x) \
+    network_status_t network_write_chunkqueue_##x(server *srv, connection *con, SSL *ssl, chunkqueue *cq)
+#define NETWORK_BACKEND_READ_SSL(x) \
+    network_status_t network_read_chunkqueue_##x(server *srv, connection *con, SSL *ssl, chunkqueue *cq)
+
+NETWORK_BACKEND_WRITE_SSL(openssl);
+NETWORK_BACKEND_READ_SSL(openssl);
 #endif
 
 #endif
--- lighttpd-1.4.11/src/network_freebsd_sendfile.c	2005-10-22 12:28:18.000000000 +0300
+++ lighttpd/src/network_freebsd_sendfile.c	2006-07-11 21:23:40.107856480 +0300
@@ -31,106 +31,25 @@
 # endif
 #endif
 
-int network_write_chunkqueue_freebsdsendfile(server *srv, connection *con, int fd, chunkqueue *cq) {
+NETWORK_BACKEND_WRITE(freebsdsendfile) {
 	chunk *c;
 	size_t chunks_written = 0;
 	
 	for(c = cq->first; c; c = c->next, chunks_written++) {
 		int chunk_finished = 0;
+		network_status_t ret;
 		
 		switch(c->type) {
-		case MEM_CHUNK: {
-			char * offset;
-			size_t toSend;
-			ssize_t r;
-			
-			size_t num_chunks, i;
-			struct iovec chunks[UIO_MAXIOV];
-			chunk *tc;
-			size_t num_bytes = 0;
-			
-			/* we can't send more then SSIZE_MAX bytes in one chunk */
-			
-			/* build writev list 
-			 * 
-			 * 1. limit: num_chunks < UIO_MAXIOV
-			 * 2. limit: num_bytes < SSIZE_MAX
-			 */
-			for(num_chunks = 0, tc = c; tc && tc->type == MEM_CHUNK && num_chunks < UIO_MAXIOV; num_chunks++, tc = tc->next);
-			
-			for(tc = c, i = 0; i < num_chunks; tc = tc->next, i++) {
-				if (tc->mem->used == 0) {
-					chunks[i].iov_base = tc->mem->ptr;
-					chunks[i].iov_len  = 0;
-				} else {
-					offset = tc->mem->ptr + tc->offset;
-					toSend = tc->mem->used - 1 - tc->offset;
-					
-					chunks[i].iov_base = offset;
-					
-					/* protect the return value of writev() */
-					if (toSend > SSIZE_MAX ||
-					    num_bytes + toSend > SSIZE_MAX) {
-						chunks[i].iov_len = SSIZE_MAX - num_bytes;
-						
-						num_chunks = i + 1;
-						break;
-					} else {
-						chunks[i].iov_len = toSend;
-					}
-				 
-					num_bytes += toSend;
-				}
-			}
-			
-			if ((r = writev(fd, chunks, num_chunks)) < 0) {
-				switch (errno) {
-				case EAGAIN:
-				case EINTR:
-					r = 0;
-					break;
-				case EPIPE:
-				case ECONNRESET:
-					return -2;
-				default:
-					log_error_write(srv, __FILE__, __LINE__, "ssd", 
-							"writev failed:", strerror(errno), fd);
-					
-					return -1;
-				}
-
-				r = 0;
-			}
+		case MEM_CHUNK:
+			ret = network_write_chunkqueue_writev_mem(srv, con, fd, cq, &c);
 			
-			/* check which chunks have been written */
-			cq->bytes_out += r;
-			
-			for(i = 0, tc = c; i < num_chunks; i++, tc = tc->next) {
-				if (r >= (ssize_t)chunks[i].iov_len) {
-					/* written */
-					r -= chunks[i].iov_len;
-					tc->offset += chunks[i].iov_len;
-					
-					if (chunk_finished) {
-						/* skip the chunks from further touches */
-						chunks_written++;
-						c = c->next;
-					} else {
-						/* chunks_written + c = c->next is done in the for()*/
-						chunk_finished++;
+			if (ret != NETWORK_STATUS_SUCCESS) {
+				return ret;
 					}
-				} else {
-					/* partially written */
 					
-					tc->offset += r;
-					chunk_finished = 0;
-					
-					break;
-				}
-			}
+			chunk_finished = 1;
 			
 			break;
-		}
 		case FILE_CHUNK: {
 			off_t offset, r;
 			size_t toSend;
@@ -140,7 +59,7 @@
 			if (HANDLER_ERROR == stat_cache_get_entry(srv, con, c->file.name, &sce)) {
 				log_error_write(srv, __FILE__, __LINE__, "sb",
 						strerror(errno), c->file.name);
-				return -1;
+				return NETWORK_STATUS_FATAL_ERROR;
 			}
 			
 			offset = c->file.start + c->offset;
@@ -151,13 +70,13 @@
 			if (offset > sce->st.st_size) {
 				log_error_write(srv, __FILE__, __LINE__, "sb", "file was shrinked:", c->file.name);
 				
-				return -1;
+				return NETWORK_STATUS_FATAL_ERROR;
 			}
 			
 			if (-1 == (ifd = open(c->file.name->ptr, O_RDONLY))) {
 				log_error_write(srv, __FILE__, __LINE__, "ss", "open failed: ", strerror(errno));
 				
-				return -1;
+				return NETWORK_STATUS_FATAL_ERROR;
 			}
 			
 			r = 0;
@@ -169,11 +88,11 @@
 					break;
 				case ENOTCONN:
 					close(ifd);
-					return -2;
+					return NETWORK_STATUS_CONNECTION_CLOSE;
 				default:
 					log_error_write(srv, __FILE__, __LINE__, "ssd", "sendfile: ", strerror(errno), errno);
 					close(ifd);
-					return -1;
+					return NETWORK_STATUS_FATAL_ERROR;
 				}
 			}
 			close(ifd);
@@ -201,7 +120,7 @@
 		}
 	}
 
-	return chunks_written;
+	return NETWORK_STATUS_SUCCESS;
 }
 
 #endif
--- lighttpd-1.4.11/src/network_linux_sendfile.c	2006-02-15 20:02:36.000000000 +0200
+++ lighttpd/src/network_linux_sendfile.c	2006-07-11 21:23:40.271866752 +0300
@@ -26,106 +26,38 @@
 /* on linux 2.4.29 + debian/ubuntu we have crashes if this is enabled */
 #undef HAVE_POSIX_FADVISE
 
-int network_write_chunkqueue_linuxsendfile(server *srv, connection *con, int fd, chunkqueue *cq) {
-	chunk *c;
+NETWORK_BACKEND_WRITE(linuxsendfile) {
+	chunk *c, *tc;
 	size_t chunks_written = 0;
 	
 	for(c = cq->first; c; c = c->next, chunks_written++) {
 		int chunk_finished = 0;
+		network_status_t ret;
 		
 		switch(c->type) {
-		case MEM_CHUNK: {
-			char * offset;
-			size_t toSend;
-			ssize_t r;
-			
-			size_t num_chunks, i;
-			struct iovec chunks[UIO_MAXIOV];
-			chunk *tc;
-			size_t num_bytes = 0;
-			
-			/* we can't send more then SSIZE_MAX bytes in one chunk */
-			
-			/* build writev list 
-			 * 
-			 * 1. limit: num_chunks < UIO_MAXIOV
-			 * 2. limit: num_bytes < SSIZE_MAX
-			 */
-			for (num_chunks = 0, tc = c; 
-			     tc && tc->type == MEM_CHUNK && num_chunks < UIO_MAXIOV; 
-			     tc = tc->next, num_chunks++);
-			
-			for (tc = c, i = 0; i < num_chunks; tc = tc->next, i++) {
-				if (tc->mem->used == 0) {
-					chunks[i].iov_base = tc->mem->ptr;
-					chunks[i].iov_len  = 0;
-				} else {
-					offset = tc->mem->ptr + tc->offset;
-					toSend = tc->mem->used - 1 - tc->offset;
-				
-					chunks[i].iov_base = offset;
-					
-					/* protect the return value of writev() */
-					if (toSend > SSIZE_MAX ||
-					    num_bytes + toSend > SSIZE_MAX) {
-						chunks[i].iov_len = SSIZE_MAX - num_bytes;
-						
-						num_chunks = i + 1;
-						break;
-					} else {
-						chunks[i].iov_len = toSend;
-					}
-				 
-					num_bytes += toSend;
-				}
-			}
-			
-			if ((r = writev(fd, chunks, num_chunks)) < 0) {
-				switch (errno) {
-				case EAGAIN:
-				case EINTR:
-					r = 0;
-					break;
-				case EPIPE:
-				case ECONNRESET:
-					return -2;
-				default:
-					log_error_write(srv, __FILE__, __LINE__, "ssd", 
-							"writev failed:", strerror(errno), fd);
-				
-					return -1;
-				}
-			}
-			
-			/* check which chunks have been written */
-			cq->bytes_out += r;
-
-			for(i = 0, tc = c; i < num_chunks; i++, tc = tc->next) {
-				if (r >= (ssize_t)chunks[i].iov_len) {
-					/* written */
-					r -= chunks[i].iov_len;
-					tc->offset += chunks[i].iov_len;
+		case MEM_CHUNK:
+			ret = network_write_chunkqueue_writev_mem(srv, con, fd, cq, c);
 					
+			/* check which chunks are finished now */
+			for (tc = c; tc; tc = tc->next) {
+				/* finished the chunk */
+				if (tc->offset == tc->mem->used - 1) {
+					/* skip the first c->next as that will be done by the c = c->next in the other for()-loop */
 					if (chunk_finished) {
-						/* skip the chunks from further touches */
-						chunks_written++;
 						c = c->next;
 					} else {
-						/* chunks_written + c = c->next is done in the for()*/
-						chunk_finished++;
+						chunk_finished = 1;
 					}
 				} else {
-					/* partially written */
-					
-					tc->offset += r;
-					chunk_finished = 0;
-					
 					break;
 				}
 			}
 			
-			break;
+			if (ret != NETWORK_STATUS_SUCCESS) {
+				return ret;
 		}
+
+			break;
 		case FILE_CHUNK: {
 			ssize_t r;
 			off_t offset;
--- lighttpd-1.4.11/src/network_openssl.c	2005-11-17 14:53:29.000000000 +0200
+++ lighttpd/src/network_openssl.c	2006-07-11 21:23:40.107856480 +0300
@@ -26,7 +26,77 @@
 # include <openssl/ssl.h> 
 # include <openssl/err.h> 
 
-int network_write_chunkqueue_openssl(server *srv, connection *con, SSL *ssl, chunkqueue *cq) {
+NETWORK_BACKEND_READ_SSL(openssl) {
+	buffer *b;
+	off_t len;
+
+	b = chunkqueue_get_append_buffer(cq);
+	buffer_prepare_copy(b, 8192);
+	len = SSL_read(ssl, b->ptr, b->size - 1);
+
+	log_error_write(srv, __FILE__, __LINE__, "so", "SSL:", len);
+
+	if (len < 0) {
+		int r, ssl_err;
+
+		switch ((r = SSL_get_error(con->ssl, len))) {
+		case SSL_ERROR_WANT_READ:
+			return NETWORK_STATUS_WAIT_FOR_EVENT;
+		case SSL_ERROR_SYSCALL:
+			/**
+			 * man SSL_get_error()
+			 *
+			 * SSL_ERROR_SYSCALL
+			 *   Some I/O error occurred.  The OpenSSL error queue may contain more
+			 *   information on the error.  If the error queue is empty (i.e.
+			 *   ERR_get_error() returns 0), ret can be used to find out more about
+			 *   the error: If ret == 0, an EOF was observed that violates the
+			 *   protocol.  If ret == -1, the underlying BIO reported an I/O error
+			 *   (for socket I/O on Unix systems, consult errno for details).
+			 *
+			 */
+			while((ssl_err = ERR_get_error())) {
+				/* get all errors from the error-queue */
+				log_error_write(srv, __FILE__, __LINE__, "sds", "SSL:",
+						r, ERR_error_string(ssl_err, NULL));
+			}
+
+			switch(errno) {
+			default:
+				log_error_write(srv, __FILE__, __LINE__, "sddds", "SSL:",
+						len, r, errno,
+						strerror(errno));
+				break;
+			}
+
+			break;
+		case SSL_ERROR_ZERO_RETURN:
+			/* clean shutdown on the remote side */
+
+			if (r == 0) {
+				/* FIXME: later */
+			}
+
+			/* fall thourgh */
+		default:
+			while((ssl_err = ERR_get_error())) {
+				/* get all errors from the error-queue */
+				log_error_write(srv, __FILE__, __LINE__, "sds", "SSL:",
+						r, ERR_error_string(ssl_err, NULL));
+			}
+			break;
+		}
+	}
+
+	assert(len > 0);
+	b->used += len;
+	b->ptr[b->used - 1] = '\0';
+
+	return NETWORK_STATUS_SUCCESS;
+}
+
+
+NETWORK_BACKEND_WRITE_SSL(openssl) {
 	int ssl_r;
 	chunk *c;
 	size_t chunks_written = 0;
@@ -65,7 +135,7 @@
 		case MEM_CHUNK: {
 			char * offset;
 			size_t toSend;
-			ssize_t r;
+			ssize_t r = 0;
 			
 			if (c->mem->used == 0) {
 				chunk_finished = 1;
@@ -83,9 +153,11 @@
 			 *        SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE, it must be
 			 *        repeated with the same arguments.
 			 * 
+			 * SSL_write(..., 0) return 0 which is handle as an error (Success)
+			 * checking toSend and not calling SSL_write() is simpler
 			 */
 			
-			if ((r = SSL_write(ssl, offset, toSend)) <= 0) {
+			if (toSend != 0 && (r = SSL_write(ssl, offset, toSend)) <= 0) {
 				unsigned long err;
 
 				switch ((ssl_r = SSL_get_error(ssl, r))) {
--- lighttpd-1.4.11/src/network_solaris_sendfilev.c	2005-10-22 12:28:27.000000000 +0300
+++ lighttpd/src/network_solaris_sendfilev.c	2006-07-11 21:23:40.211862994 +0300
@@ -38,105 +38,25 @@
  */
 
 
-int network_write_chunkqueue_solarissendfilev(server *srv, connection *con, int fd, chunkqueue *cq) {
+NETWORK_BACKEND_WRITE(solarissendfilev) {
 	chunk *c;
 	size_t chunks_written = 0;
 	
 	for(c = cq->first; c; c = c->next, chunks_written++) {
 		int chunk_finished = 0;
+		network_status_t ret;
 		
 		switch(c->type) {
-		case MEM_CHUNK: {
-			char * offset;
-			size_t toSend;
-			ssize_t r;
-			
-			size_t num_chunks, i;
-			struct iovec chunks[UIO_MAXIOV];
-			chunk *tc;
-			
-			size_t num_bytes = 0;
-			
-			/* we can't send more then SSIZE_MAX bytes in one chunk */
-			
-			/* build writev list 
-			 * 
-			 * 1. limit: num_chunks < UIO_MAXIOV
-			 * 2. limit: num_bytes < SSIZE_MAX
-			 */
-			for(num_chunks = 0, tc = c; tc && tc->type == MEM_CHUNK && num_chunks < UIO_MAXIOV; num_chunks++, tc = tc->next);
-			
-			for(tc = c, i = 0; i < num_chunks; tc = tc->next, i++) {
-				if (tc->mem->used == 0) {
-					chunks[i].iov_base = tc->mem->ptr;
-					chunks[i].iov_len  = 0;
-				} else {
-					offset = tc->mem->ptr + tc->offset;
-					toSend = tc->mem->used - 1 - tc->offset;
-				
-					chunks[i].iov_base = offset;
-					
-					/* protect the return value of writev() */
-					if (toSend > SSIZE_MAX ||
-					    num_bytes + toSend > SSIZE_MAX) {
-						chunks[i].iov_len = SSIZE_MAX - num_bytes;
-						
-						num_chunks = i + 1;
-						break;
-					} else {
-						chunks[i].iov_len = toSend;
-					}
-					
-					num_bytes += toSend;
-				}
-			}
-			
-			if ((r = writev(fd, chunks, num_chunks)) < 0) {
-				switch (errno) {
-				case EAGAIN:
-				case EINTR:
-					r = 0;
-					break;
-				case EPIPE:
-				case ECONNRESET:
-					return -2;
-				default:
-					log_error_write(srv, __FILE__, __LINE__, "ssd", 
-							"writev failed:", strerror(errno), fd);
-				
-					return -1;
-				}
-			}
+		case MEM_CHUNK:
+			ret = network_write_chunkqueue_writev_mem(srv, con, fd, cq, &c);
 			
-			/* check which chunks have been written */
-			cq->bytes_out += r;
-			
-			for(i = 0, tc = c; i < num_chunks; i++, tc = tc->next) {
-				if (r >= (ssize_t)chunks[i].iov_len) {
-					/* written */
-					r -= chunks[i].iov_len;
-					tc->offset += chunks[i].iov_len;
-					
-					if (chunk_finished) {
-						/* skip the chunks from further touches */
-						chunks_written++;
-						c = c->next;
-					} else {
-						/* chunks_written + c = c->next is done in the for()*/
-						chunk_finished++;
+			if (ret != NETWORK_STATUS_SUCCESS) {
+				return ret;
 					}
-				} else {
-					/* partially written */
-					
-					tc->offset += r;
-					chunk_finished = 0;
 					
-					break;
-				}
-			}
+			chunk_finished = 1;
 			
 			break;
-		}
 		case FILE_CHUNK: {
 			ssize_t r;
 			off_t offset;
@@ -177,7 +97,7 @@
 					log_error_write(srv, __FILE__, __LINE__, "ssd", "sendfile: ", strerror(errno), errno);
 					
 					close(ifd);
-					return -1;
+					return NETWORK_STATUS_FATAL_ERROR;
 				}
 				
 				r = 0;
@@ -194,10 +114,9 @@
 			break;
 		}
 		default:
-			
 			log_error_write(srv, __FILE__, __LINE__, "ds", c, "type not known");
 			
-			return -1;
+			return NETWORK_STATUS_FATAL_ERROR;
 		}
 		
 		if (!chunk_finished) {
@@ -207,7 +126,7 @@
 		}
 	}
 
-	return chunks_written;
+	return NETWORK_STATUS_SUCCESS;
 }
 
 #endif
--- lighttpd-1.4.11/src/network_write.c	2005-10-22 12:27:56.000000000 +0300
+++ lighttpd/src/network_write.c	2006-07-11 21:23:39.887842700 +0300
@@ -1,11 +1,11 @@
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/time.h>
+
 #include <errno.h>
 #include <fcntl.h>
-#include <unistd.h>
 #include <string.h>
 #include <stdlib.h>
+#include <assert.h>
 
 #include "network.h"
 #include "fdevent.h"
@@ -13,9 +13,12 @@
 #include "stat_cache.h"
 
 #include "sys-socket.h"
+#include "sys-files.h"
 
 #include "network_backends.h"
 
+#ifdef USE_WRITE
+
 #ifdef HAVE_SYS_FILIO_H
 # include <sys/filio.h>
 #endif
@@ -24,7 +27,53 @@
 #include <sys/resource.h>
 #endif
 
-int network_write_chunkqueue_write(server *srv, connection *con, int fd, chunkqueue *cq) {
+/**
+* fill the chunkqueue will all the data that we can get
+*
+* this might be optimized into a readv() which uses the chunks
+* as vectors
+*/
+NETWORK_BACKEND_READ(read) {
+    int toread;
+    buffer *b;
+    off_t r;
+
+	/* check how much we have to read */
+	if (ioctl(fd, FIONREAD, &toread)) {
+		log_error_write(srv, __FILE__, __LINE__, "sd",
+				"ioctl failed: ",
+				fd);
+		return NETWORK_STATUS_FATAL_ERROR;
+	}
+
+	if (toread == 0) return NETWORK_STATUS_WAIT_FOR_EVENT;
+
+    /*
+    * our chunk queue is quiet large already
+    *
+    * let's buffer it to disk
+    */
+
+    b = chunkqueue_get_append_buffer(cq);
+
+    buffer_prepare_copy(b, toread);
+
+    if (-1 == (r = read(fd, b->ptr, toread))) {
+		log_error_write(srv, __FILE__, __LINE__, "sds",
+				"unexpected end-of-file (perhaps the proxy process died):",
+				fd, strerror(errno));
+		return NETWORK_STATUS_FATAL_ERROR;
+	}
+
+	/* this should be catched by the b > 0 above */
+	assert(r);
+	b->used += r + 1;
+	b->ptr[b->used - 1] = '\0';
+
+    return NETWORK_STATUS_SUCCESS;
+}
+
+NETWORK_BACKEND_WRITE(write) {
 	chunk *c;
 	size_t chunks_written = 0;
 	
@@ -44,19 +93,12 @@
 			
 			offset = c->mem->ptr + c->offset;
 			toSend = c->mem->used - 1 - c->offset;
-#ifdef __WIN32	
-			if ((r = send(fd, offset, toSend, 0)) < 0) {
-				log_error_write(srv, __FILE__, __LINE__, "ssd", "write failed: ", strerror(errno), fd);
 				
-				return -1;
-			}
-#else
 			if ((r = write(fd, offset, toSend)) < 0) {
 				log_error_write(srv, __FILE__, __LINE__, "ssd", "write failed: ", strerror(errno), fd);
 				
-				return -1;
+				return NETWORK_STATUS_FATAL_ERROR;
 			}
-#endif
 			
 			c->offset += r;
 			cq->bytes_out += r;
@@ -80,7 +122,7 @@
 			if (HANDLER_ERROR == stat_cache_get_entry(srv, con, c->file.name, &sce)) {
 				log_error_write(srv, __FILE__, __LINE__, "sb",
 						strerror(errno), c->file.name);
-				return -1;
+				return NETWORK_STATUS_FATAL_ERROR;
 			}
 			
 			offset = c->file.start + c->offset;
@@ -89,13 +131,13 @@
 			if (offset > sce->st.st_size) {
 				log_error_write(srv, __FILE__, __LINE__, "sb", "file was shrinked:", c->file.name);
 				
-				return -1;
+				return NETWORK_STATUS_FATAL_ERROR;
 			}
 
 			if (-1 == (ifd = open(c->file.name->ptr, O_RDONLY))) {
 				log_error_write(srv, __FILE__, __LINE__, "ss", "open failed: ", strerror(errno));
 				
-				return -1;
+				return NETWORK_STATUS_FATAL_ERROR;
 			}
 			
 #if defined USE_MMAP
@@ -104,14 +146,14 @@
 
 				close(ifd);
 				
-				return -1;
+				return NETWORK_STATUS_FATAL_ERROR;
 			}
 			close(ifd);
 
 			if ((r = write(fd, p + offset, toSend)) <= 0) {
 				log_error_write(srv, __FILE__, __LINE__, "ss", "write failed: ", strerror(errno));
 				munmap(p, sce->st.st_size);
-				return -1;
+				return NETWORK_STATUS_FATAL_ERROR;
 			}
 			
 			munmap(p, sce->st.st_size);
@@ -123,14 +165,14 @@
 				log_error_write(srv, __FILE__, __LINE__, "ss", "read: ", strerror(errno));
 				close(ifd);
 				
-				return -1;
+				return NETWORK_STATUS_FATAL_ERROR;
 			}
 			close(ifd);
 
 			if (-1 == (r = send(fd, srv->tmp_buf->ptr, toSend, 0))) {
 				log_error_write(srv, __FILE__, __LINE__, "ss", "write: ", strerror(errno));
 				
-				return -1;
+				return NETWORK_STATUS_FATAL_ERROR;
 			}
 #endif
 			c->offset += r;
@@ -146,7 +188,7 @@
 			
 			log_error_write(srv, __FILE__, __LINE__, "ds", c, "type not known");
 			
-			return -1;
+			return NETWORK_STATUS_FATAL_ERROR;
 		}
 		
 		if (!chunk_finished) {
@@ -158,11 +200,7 @@
 		chunks_written++;
 	}
 
-	return chunks_written;
+	return NETWORK_STATUS_SUCCESS;
 }
 
-#if 0
-network_write_init(void) {
-	p->write = network_write_write_chunkset;
-}
 #endif
--- lighttpd-1.4.11/src/network_writev.c	2006-02-15 01:02:36.000000000 +0200
+++ lighttpd/src/network_writev.c	2006-07-11 21:23:40.103856229 +0300
@@ -51,22 +51,14 @@
 #define LOCAL_BUFFERING 1
 #endif
 
-int network_write_chunkqueue_writev(server *srv, connection *con, int fd, chunkqueue *cq) {
-	chunk *c;
-	size_t chunks_written = 0;
-	
-	for(c = cq->first; c; c = c->next) {
-		int chunk_finished = 0;
-		
-		switch(c->type) {
-		case MEM_CHUNK: {
+NETWORK_BACKEND_WRITE_CHUNK(writev_mem) {
 			char * offset;
 			size_t toSend;
 			ssize_t r;
 			
 			size_t num_chunks, i;
 			struct iovec chunks[UIO_MAXIOV];
-			chunk *tc;
+	chunk *tc; /* transfer chunks */
 			size_t num_bytes = 0;
 			
 			/* we can't send more then SSIZE_MAX bytes in one chunk */
@@ -111,12 +103,12 @@
 					break;
 				case EPIPE:
 				case ECONNRESET:
-					return -2;
+			return NETWORK_STATUS_CONNECTION_CLOSE;
 				default:
 					log_error_write(srv, __FILE__, __LINE__, "ssd", 
 							"writev failed:", strerror(errno), fd);
 				
-					return -1;
+			return NETWORK_STATUS_FATAL_ERROR;
 				}
 			}
 			
@@ -129,27 +121,49 @@
 					/* written */
 					r -= chunks[i].iov_len;
 					tc->offset += chunks[i].iov_len;
+		} else {
+			/* partially written */
 					
+			tc->offset += r;
+			break;
+		}
+	}
+
+	return NETWORK_STATUS_SUCCESS;
+}
+
+NETWORK_BACKEND_WRITE(writev) {
+	chunk *c, *tc;
+	size_t chunks_written = 0;
+
+	for(c = cq->first; c; c = c->next) {
+		int chunk_finished = 0;
+		network_status_t ret;
+
+		switch(c->type) {
+		case MEM_CHUNK:
+			ret = network_write_chunkqueue_writev_mem(srv, con, fd, cq, c);
+
+			/* check which chunks are finished now */
+			for (tc = c; tc; tc = tc->next) {
+				/* finished the chunk */
+				if (tc->offset == tc->mem->used - 1) {
+					/* skip the first c->next as that will be done by the c = c->next in the other for()-loop */
 					if (chunk_finished) {
-						/* skip the chunks from further touches */
-						chunks_written++;
 						c = c->next;
 					} else {
-						/* chunks_written + c = c->next is done in the for()*/
-						chunk_finished++;
+						chunk_finished = 1;
 					}
 				} else {
-					/* partially written */
-					
-					tc->offset += r;
-					chunk_finished = 0;
-
 					break;
 				}
 			}
 			
-			break;
+			if (ret != NETWORK_STATUS_SUCCESS) {
+				return ret;
 		}
+
+			break;
 		case FILE_CHUNK: {
 			ssize_t r;
 			off_t abs_offset;
@@ -165,7 +179,7 @@
 			if (HANDLER_ERROR == stat_cache_get_entry(srv, con, c->file.name, &sce)) {
 				log_error_write(srv, __FILE__, __LINE__, "sb",
 						strerror(errno), c->file.name);
-				return -1;
+				return NETWORK_STATUS_FATAL_ERROR;
 			}
 
 			abs_offset = c->file.start + c->offset;
@@ -174,7 +188,7 @@
 				log_error_write(srv, __FILE__, __LINE__, "sb", 
 						"file was shrinked:", c->file.name);
 				
-				return -1;
+				return NETWORK_STATUS_FATAL_ERROR;
 			}
 
 			/* mmap the buffer 
@@ -235,7 +249,7 @@
 					if (-1 == (c->file.fd = open(c->file.name->ptr, O_RDONLY))) {
 						log_error_write(srv, __FILE__, __LINE__, "sbs", "open failed for:", c->file.name, strerror(errno));
 				
-						return -1;
+						return NETWORK_STATUS_FATAL_ERROR;
 					}
 #ifdef FD_CLOEXEC
 					fcntl(c->file.fd, F_SETFD, FD_CLOEXEC);
@@ -248,7 +262,7 @@
 					log_error_write(srv, __FILE__, __LINE__, "ssbd", "mmap failed:", 
 							strerror(errno), c->file.name, c->file.fd);
 
-					return -1;
+					return NETWORK_STATUS_FATAL_ERROR;
 				}
 
 				c->file.mmap.length = to_mmap;
@@ -297,12 +311,12 @@
 					break;
 				case EPIPE:
 				case ECONNRESET:
-					return -2;
+					return NETWORK_STATUS_CONNECTION_CLOSE;
 				default:
 					log_error_write(srv, __FILE__, __LINE__, "ssd", 
 							"write failed:", strerror(errno), fd);
 					
-					return -1;
+					return NETWORK_STATUS_FATAL_ERROR;
 				}
 			}
 			
@@ -325,7 +339,7 @@
 			
 			log_error_write(srv, __FILE__, __LINE__, "ds", c, "type not known");
 			
-			return -1;
+			return NETWORK_STATUS_FATAL_ERROR;
 		}
 		
 		if (!chunk_finished) {
@@ -337,7 +351,7 @@
 		chunks_written++;
 	}
 
-	return chunks_written;
+	return NETWORK_STATUS_SUCCESS;
 }
 
 #endif
--- lighttpd-1.4.11/src/plugin.c	2006-02-08 14:00:54.000000000 +0200
+++ lighttpd/src/plugin.c	2006-07-11 21:23:40.067853974 +0300
@@ -13,7 +13,7 @@
 #include <valgrind/valgrind.h>
 #endif
 
-#ifndef __WIN32
+#ifndef _WIN32
 #include <dlfcn.h>
 #endif
 /*
@@ -56,19 +56,23 @@
 	
 	p = calloc(1, sizeof(*p));
 	
+	p->required_plugins = array_init();
+
 	return p;
 }
 
 static void plugin_free(plugin *p) {
 	int use_dlclose = 1;
 	if (p->name) buffer_free(p->name);
+
+	array_free(p->required_plugins);
 #ifdef HAVE_VALGRIND_VALGRIND_H
 	/*if (RUNNING_ON_VALGRIND) use_dlclose = 0;*/
 #endif
 
 #ifndef LIGHTTPD_STATIC
 	if (use_dlclose && p->lib) {	
-#ifdef __WIN32
+#ifdef _WIN32
 		FreeLibrary(p->lib);
 #else
 		dlclose(p->lib);
@@ -121,9 +125,14 @@
 #else
 int plugins_load(server *srv) {
 	plugin *p;
+#ifdef _WIN32
+    FARPROC init;
+#else
 	int (*init)(plugin *pl);
+#endif
+
 	const char *error;
-	size_t i;
+	size_t i, j, k;
 	
 	for (i = 0; i < srv->srvconf.modules->used; i++) {
 		data_string *d = (data_string *)srv->srvconf.modules->data[i];
@@ -133,14 +142,14 @@
 
 		buffer_append_string(srv->tmp_buf, "/");
 		buffer_append_string(srv->tmp_buf, modules);
-#if defined(__WIN32) || defined(__CYGWIN__)
+#if defined(_WIN32) || defined(__CYGWIN__)
 		buffer_append_string(srv->tmp_buf, ".dll");
 #else
 		buffer_append_string(srv->tmp_buf, ".so");
 #endif
 	
 		p = plugin_init();
-#ifdef __WIN32
+#ifdef _WIN32
 		if (NULL == (p->lib = LoadLibrary(srv->tmp_buf->ptr))) {
 			LPVOID lpMsgBuf;
 			FormatMessage(
@@ -175,7 +184,7 @@
 		buffer_copy_string(srv->tmp_buf, modules);
 		buffer_append_string(srv->tmp_buf, "_plugin_init");
 
-#ifdef __WIN32
+#ifdef _WIN32
 		init = GetProcAddress(p->lib, srv->tmp_buf->ptr);
 
 		if (init == NULL)  {
@@ -218,6 +227,25 @@
 #if 0
 		log_error_write(srv, __FILE__, __LINE__, "ss", modules, "plugin loaded" );
 #endif
+		/* check if the required plugin is loaded */
+		for (k = 0; k < p->required_plugins->used; k++) {
+			data_string *req = (data_string *)p->required_plugins->data[k];
+
+			for (j = 0; j < i; j++) {
+				data_string *mod = (data_string *)srv->srvconf.modules->data[j];
+
+				if (buffer_is_equal(req->value, mod->value)) break;
+			}
+
+			if (j == i) {
+				/* not found */
+				log_error_write(srv, __FILE__, __LINE__, "ssbs", modules, "failed to load. required plugin", req->value, "was not loaded" );
+
+				plugin_free(p);
+			
+				return -1;
+			}
+		}
 		plugins_register(srv, p);
 	}
 	
@@ -426,6 +454,23 @@
 	return HANDLER_GO_ON;
 }
 
+/**
+ * get the config-storage of the named plugin 
+ */
+void *plugin_get_config(server *srv, const char *name) {
+	size_t i;
+
+	for (i = 0; i < srv->plugins.used; i++) {
+		plugin *p = ((plugin **)srv->plugins.ptr)[i];
+
+		if (buffer_is_equal_string(p->name, name, strlen(name))) {
+			return p->data;
+		}
+	}
+
+	return NULL;
+}
+
 void plugins_free(server *srv) {
 	size_t i;
 	plugins_call_cleanup(srv);
--- lighttpd-1.4.11/src/plugin.h	2005-08-15 12:28:56.000000000 +0300
+++ lighttpd/src/plugin.h	2006-07-11 21:23:40.075854475 +0300
@@ -12,6 +12,12 @@
 
 #define INIT_FUNC(x) \
 		static void *x()
+/*
+ * The PATCH_OPTION() macro is used in the patch_connection() functions
+ * of the modules to update the config object for the current request.
+ */
+#define PATCH_OPTION(x) \
+		p->conf.x = s->x
 
 #define FREE_FUNC          SERVER_FUNC
 #define TRIGGER_FUNC       SERVER_FUNC
@@ -59,6 +65,8 @@
 	
 	/* dlopen handle */
 	void *lib;
+
+	array *required_plugins;
 } plugin;
 
 int plugins_load(server *srv);
@@ -88,5 +96,8 @@
 int config_patch_connection(server *srv, connection *con, comp_key_t comp);
 int config_check_cond(server *srv, connection *con, data_config *dc);
 int config_append_cond_match_buffer(connection *con, data_config *dc, buffer *buf, int n);
+int config_exec_pcre_keyvalue_buffer(connection *con, pcre_keyvalue_buffer *kvb, data_config *context, buffer *match_buf, buffer *result);
+
+void *plugin_get_config(server *srv, const char *name);
 
 #endif
--- lighttpd-1.4.11/src/proc_open.c	2005-08-11 01:26:39.000000000 +0300
+++ lighttpd/src/proc_open.c	2006-07-11 21:23:40.283867504 +0300
@@ -13,13 +13,13 @@
 #endif
 
 
-#ifdef WIN32
+#ifdef _WIN32
 /* {{{ win32 stuff */
 # define SHELLENV "ComSpec"
 # define SECURITY_DC , SECURITY_ATTRIBUTES *security
 # define SECURITY_CC , security
 # define pipe(pair) (CreatePipe(&pair[0], &pair[1], security, 2048L) ? 0 : -1)
-static inline HANDLE dup_handle(HANDLE src, BOOL inherit, BOOL closeorig)
+static HANDLE dup_handle(HANDLE src, BOOL inherit, BOOL closeorig)
 {
 	HANDLE copy, self = GetCurrentProcess();
 
@@ -148,11 +148,14 @@
 	STARTUPINFO si;
 	BOOL procok;
 	SECURITY_ATTRIBUTES security;
-	const char *shell;
+	const char *shell = NULL;
+	const char *windir = NULL;
 	buffer *cmdline;
 
-	if (NULL == (shell = getenv(SHELLENV))) {
-		fprintf(stderr, "env %s is required", SHELLENV);
+	if (NULL == (shell = getenv(SHELLENV)) &&
+			NULL == (windir = getenv("SystemRoot")) &&
+			NULL == (windir = getenv("windir"))) {
+		fprintf(stderr, "One of %s,%%SystemRoot,%%windir is required", SHELLENV);
 		return -1;
 	}
 
@@ -177,17 +180,23 @@
 	memset(&pi, 0, sizeof(pi));
 
 	cmdline = buffer_init();
+	if (shell) {
 	buffer_append_string(cmdline, shell);
+	} else {
+		buffer_append_string(cmdline, windir);
+		buffer_append_string(cmdline, "\\system32\\cmd.exe");
+	}
 	buffer_append_string_len(cmdline, CONST_STR_LEN(" /c "));
 	buffer_append_string(cmdline, command);
 	procok = CreateProcess(NULL, cmdline->ptr, &security, &security, TRUE,
 			NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi);
-	buffer_free(cmdline);
 
 	if (FALSE == procok) {
-		fprintf(stderr, "failed to CreateProcess");
+		fprintf(stderr, "failed to CreateProcess: %s", cmdline->ptr);
+		buffer_free(cmdline);
 		return -1;
 	}
+	buffer_free(cmdline);
 
 	proc->child = pi.hProcess;
 	CloseHandle(pi.hThread);
@@ -226,8 +235,7 @@
 	const char *shell;
 
 	if (NULL == (shell = getenv(SHELLENV))) {
-		fprintf(stderr, "env %s is required", SHELLENV);
-		return -1;
+		shell = "/bin/sh";
 	}
 
 	if (proc_open_pipes(proc) != 0) {
@@ -262,11 +270,11 @@
 	}
 }
 /* }}} */
-#endif /* WIN32 */
+#endif /* _WIN32 */
 
 /* {{{ proc_read_fd_to_buffer */
 static void proc_read_fd_to_buffer(int fd, buffer *b) {
-	ssize_t s;
+	int s; /* win32 has not ssize_t */
 
 	for (;;) {
 		buffer_prepare_append(b, 512);
--- lighttpd-1.4.11/src/proc_open.h	2005-08-11 01:26:39.000000000 +0300
+++ lighttpd/src/proc_open.h	2006-07-11 21:23:40.287867754 +0300
@@ -1,7 +1,7 @@
 
 #include "buffer.h"
 
-#ifdef WIN32
+#ifdef _WIN32
 #include <windows.h>
 typedef HANDLE descriptor_t;
 typedef HANDLE proc_pid_t;
--- lighttpd-1.4.11/src/request.c	2006-03-05 11:58:09.000000000 +0200
+++ lighttpd/src/request.c	2006-07-11 21:23:40.035851970 +0300
@@ -10,6 +10,8 @@
 #include "keyvalue.h"
 #include "log.h"
 
+#include "sys-strings.h"
+
 static int request_check_hostname(server *srv, connection *con, buffer *host) {
 	enum { DOMAINLABEL, TOPLABEL } stage = TOPLABEL;
 	size_t i;
@@ -413,7 +415,7 @@
 					}
 
 					if (major_num == 1 && minor_num == 1) {
-						con->request.http_version = con->conf.allow_http11 ? HTTP_VERSION_1_1 : HTTP_VERSION_1_0;
+						con->request.http_version = HTTP_VERSION_1_1;
 					} else if (major_num == 1 && minor_num == 0) {
 						con->request.http_version = HTTP_VERSION_1_0;
 					} else { 
@@ -797,6 +799,7 @@
 												"request-header:\n",
 												con->request.request);
 									}
+									ds->free((data_unset *) ds);
 									return 0;
 								}
 								
@@ -846,6 +849,7 @@
 												"request-header:\n",
 												con->request.request);
 									}
+									ds->free((data_unset *) ds);
 									return 0;
 								}
 							} else if (cmp > 0 && 0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN("Expect")))) {
@@ -883,6 +887,7 @@
 												"request-header:\n",
 												con->request.request);
 									}
+									ds->free((data_unset *) ds);
 									return 0;
 								}
 							} else if (cmp > 0 && 0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN("If-Modified-Since")))) {
@@ -905,6 +910,7 @@
 												"request-header:\n",
 												con->request.request);
 									}
+									ds->free((data_unset *) ds);
 									return 0;
 								}
 							} else if (cmp > 0 && 0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN("If-None-Match")))) {
@@ -922,6 +928,7 @@
 												"request-header:\n",
 												con->request.request);
 									}
+									ds->free((data_unset *) ds);
 									return 0;
 								}
 							} else if (cmp > 0 && 0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN("Range")))) {
@@ -945,6 +952,7 @@
 												"request-header:\n",
 												con->request.request);
 									}
+									ds->free((data_unset *) ds);
 									return 0;
 								}
 							}
--- lighttpd-1.4.11/src/response.c	2006-03-04 16:41:39.000000000 +0200
+++ lighttpd/src/response.c	2006-07-11 21:23:40.067853974 +0300
@@ -7,7 +7,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
-#include <unistd.h>
 #include <ctype.h>
 #include <assert.h>
 
@@ -24,6 +23,8 @@
 #include "plugin.h"
 
 #include "sys-socket.h"
+#include "sys-files.h"
+#include "sys-strings.h"
 
 int http_response_write_header(server *srv, connection *con) {
 	buffer *b;
@@ -59,7 +60,8 @@
 		ds = (data_string *)con->response.headers->data[i];
 		
 		if (ds->value->used && ds->key->used &&
-		    0 != strncmp(ds->key->ptr, "X-LIGHTTPD-", sizeof("X-LIGHTTPD-") - 1)) {
+		    0 != strncmp(ds->key->ptr, "X-LIGHTTPD-", sizeof("X-LIGHTTPD-") - 1) &&
+		    0 != strcasecmp(ds->key->ptr, "X-Sendfile")) {
 			if (buffer_is_equal_string(ds->key, CONST_STR_LEN("Date"))) have_date = 1;
 			if (buffer_is_equal_string(ds->key, CONST_STR_LEN("Server"))) have_server = 1;
 
@@ -119,7 +121,7 @@
 handler_t http_response_prepare(server *srv, connection *con) {
 	handler_t r;
 	
-	/* looks like someone has already done a decision */
+	/* looks like someone has already made a decision */
 	if (con->mode == DIRECT && 
 	    (con->http_status != 0 && con->http_status != 200)) {
 		/* remove a packets in the queue */
@@ -134,7 +136,7 @@
 	if (con->mode == DIRECT && con->physical.path->used == 0) {
 		char *qstr;
 
-		/* we only come here when we have the parse the full request again
+		/* we only come here when we have to parse the full request again
 		 * 
 		 * a HANDLER_COMEBACK from mod_rewrite and mod_fastcgi might be a 
 		 * problem here as mod_setenv might get called multiple times
@@ -262,6 +264,11 @@
 		
 		config_patch_connection(srv, con, COMP_HTTP_URL); /* HTTPurl */
 		
+		/* do we have to downgrade to 1.0 ? */
+		if (!con->conf.allow_http11) {
+			con->request.http_version = HTTP_VERSION_1_0;
+		}
+
 		switch(r = plugins_call_handle_uri_clean(srv, con)) {
 		case HANDLER_GO_ON:
 			break;
@@ -277,7 +284,7 @@
 		
 		if (con->request.http_method == HTTP_METHOD_OPTIONS &&
 		    con->uri.path->ptr[0] == '*' && con->uri.path_raw->ptr[1] == '\0') {
-			/* option requests are handled directly without checking of the path */
+			/* option requests are handled directly without checking the path */
 		
 			response_header_insert(srv, con, CONST_STR_LEN("Allow"), CONST_STR_LEN("OPTIONS, GET, HEAD, POST"));
 
@@ -320,14 +327,15 @@
 		buffer_copy_string_buffer(con->physical.doc_root, con->conf.document_root);
 		buffer_copy_string_buffer(con->physical.rel_path, con->uri.path);
 		
-#if defined(__WIN32) || defined(__CYGWIN__)
-		/* strip dots from the end and spaces
+		filename_unix2local(con->physical.rel_path);
+#if defined(_WIN32) || defined(__CYGWIN__)
+		/* strip dots and spaces from the end
 		 *
 		 * windows/dos handle those filenames as the same file
 		 *
 		 * foo == foo. == foo..... == "foo...   " == "foo..  ./"
 		 *
-		 * This will affect in some cases PATHINFO
+		 * This will affect PATHINFO in some cases
 		 *
 		 * on native windows we could prepend the filename with \\?\ to circumvent
 		 * this behaviour. I have no idea how to push this through cygwin
@@ -378,15 +386,14 @@
 			break;
 		}
 		
-		/* MacOS X and Windows can't distiguish between upper and lower-case 
-		 * 
-		 * convert to lower-case
+		/* The default Mac OS X and Windows filesystems can't distiguish between
+		 * upper- and lowercase, so convert to lowercase
 		 */
 		if (con->conf.force_lowercase_filenames) {
 			buffer_to_lower(con->physical.rel_path);
 		}
 
-		/* the docroot plugins might set the servername, if they don't we take http-host */
+		/* the docroot plugins might set the servername; if they don't we take http-host */
 		if (buffer_is_empty(con->server_name)) {
 			buffer_copy_string_buffer(con->server_name, con->uri.authority);
 		}
@@ -398,15 +405,21 @@
 		 */
 		
 		buffer_copy_string_buffer(con->physical.path, con->physical.doc_root);
-		BUFFER_APPEND_SLASH(con->physical.path);
+		PATHNAME_APPEND_SLASH(con->physical.path);
 		buffer_copy_string_buffer(con->physical.basedir, con->physical.path);
 		if (con->physical.rel_path->used &&
-		    con->physical.rel_path->ptr[0] == '/') {
+		    con->physical.rel_path->ptr[0] == DIR_SEPERATOR) {
 			buffer_append_string_len(con->physical.path, con->physical.rel_path->ptr + 1, con->physical.rel_path->used - 2);
 		} else {
 			buffer_append_string_buffer(con->physical.path, con->physical.rel_path);
 		}
 
+        /* win32: directories can't have a trailing slash */
+        if (con->physical.path->ptr[con->physical.path->used - 2] == DIR_SEPERATOR) {
+            con->physical.path->ptr[con->physical.path->used - 2] = '\0';
+            con->physical.path->used--;
+        }
+
 		if (con->conf.log_request_handling) {
 			log_error_write(srv, __FILE__, __LINE__,  "s",  "-- after doc_root");
 			log_error_write(srv, __FILE__, __LINE__,  "sb", "Doc-Root     :", con->physical.doc_root);
@@ -436,7 +449,7 @@
 	}
 	
 	/* 
-	 * Noone catched away the file from normal path of execution yet (like mod_access)
+	 * No one took the file away from the normal path of execution yet (like mod_access)
 	 * 
 	 * Go on and check of the file exists at all
 	 */
@@ -461,7 +474,7 @@
 			}
 			
 			if (S_ISDIR(sce->st.st_mode)) {
-				if (con->physical.path->ptr[con->physical.path->used - 2] != '/') {
+				if (con->uri.path->ptr[con->uri.path->used - 2] != '/') {
 					/* redirect to .../ */
 					
 					http_response_redirect_to_directory(srv, con);
@@ -499,7 +512,7 @@
 				/* PATH_INFO ! :) */
 				break;
 			default:
-				/* we have no idea what happend. let's tell the user so. */
+				/* we have no idea what happened, so tell the user. */
 				con->http_status = 500;
 				buffer_reset(con->physical.path);
 				
@@ -544,7 +557,7 @@
 			} while ((found == 0) && (slash != NULL) && (slash - srv->tmp_buf->ptr > con->physical.basedir->used - 2));
 			
 			if (found == 0) {
-				/* no it really doesn't exists */
+				/* no, it really doesn't exists */
 				con->http_status = 404;
 				
 				if (con->conf.log_file_not_found) {
@@ -594,11 +607,11 @@
 				log_error_write(srv, __FILE__, __LINE__,  "s",  "-- subrequest finished");
 			}
 			
-			/* something strange happend */
+			/* something strange happened */
 			return r;
 		}
 		
-		/* if we are still here, no one wanted the file, status 403 is ok I think */
+		/* if we are still here, no one wanted the file; status 403 is ok I think */
 		
 		if (con->mode == DIRECT) {
 			con->http_status = 403;
@@ -610,12 +623,12 @@
 	
 	switch(r = plugins_call_handle_subrequest(srv, con)) {
 	case HANDLER_GO_ON:
-		/* request was not handled, looks like we are done */
+		/* request was not handled; looks like we are done */
 		return HANDLER_FINISHED;
 	case HANDLER_FINISHED:
 		/* request is finished */
 	default:
-		/* something strange happend */
+		/* something strange happened */
 		return r;
 	}
 	
--- lighttpd-1.4.11/src/server.c	2006-03-04 19:12:17.000000000 +0200
+++ lighttpd/src/server.c	2006-07-11 21:23:40.247865249 +0300
@@ -1,11 +1,9 @@
 #include <sys/types.h>
-#include <sys/time.h>
 #include <sys/stat.h>
 
 #include <string.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <unistd.h>
 #include <stdlib.h>
 #include <time.h>
 #include <signal.h>
@@ -29,9 +27,14 @@
 #include "plugin.h"
 #include "joblist.h"
 #include "network_backends.h"
-
+#ifdef _WIN32
+/* use local getopt implementation */
+# undef HAVE_GETOPT_H
+#endif
 #ifdef HAVE_GETOPT_H
 #include <getopt.h>
+#else
+#include "getopt.h"
 #endif
 
 #ifdef HAVE_VALGRIND_VALGRIND_H
@@ -60,8 +63,16 @@
 /* #define USE_ALARM */
 #endif
 
+#ifdef _WIN32
+#undef HAVE_SIGNAL
+#endif
+
+#include "sys-files.h"
+#include "sys-process.h"
+
 static volatile sig_atomic_t srv_shutdown = 0;
 static volatile sig_atomic_t graceful_shutdown = 0;
+static volatile sig_atomic_t graceful_restart = 0;
 static volatile sig_atomic_t handle_sig_alarm = 1;
 static volatile sig_atomic_t handle_sig_hup = 0;
 
@@ -126,6 +137,7 @@
 	
 	server *srv = calloc(1, sizeof(*srv));
 	assert(srv);
+    srv->max_fds = 1024;
 #define CLEAN(x) \
 	srv->x = buffer_init();
 	
@@ -286,9 +298,7 @@
 }
 
 static void show_features (void) {
-  show_version();
-  printf("\nEvent Handlers:\n\n%s",
-
+  const char *s = ""
 #ifdef USE_SELECT
       "\t+ select (generic)\n"
 #else
@@ -355,11 +365,6 @@
 #else
       "\t- crypt support\n"
 #endif
-#ifdef USE_PAM
-      "\t+ PAM support\n"
-#else
-      "\t- PAM support\n"
-#endif
 #ifdef USE_OPENSSL
       "\t+ SSL Support\n"
 #else
@@ -371,9 +376,9 @@
       "\t- PCRE support\n"
 #endif
 #ifdef HAVE_MYSQL
-      "\t+ mySQL support\n"
+      "\t+ MySQL support\n"
 #else
-      "\t- mySQL support\n"
+      "\t- MySQL support\n"
 #endif
 #if defined(HAVE_LDAP_H) && defined(HAVE_LBER_H) && defined(HAVE_LIBLDAP) && defined(HAVE_LIBLBER)
       "\t+ LDAP support\n"
@@ -410,8 +415,11 @@
 #else
       "\t- GDBM support\n"
 #endif
-      "\n"
-      );
+      "\n";
+
+  show_version();
+
+  printf("\nEvent Handlers:\n\n%s", s);
 }
 
 static void show_help (void) {
@@ -438,7 +446,7 @@
 	write(STDOUT_FILENO, b, strlen(b));
 }
 
-int main (int argc, char **argv) {
+int main (int argc, char **argv, char **envp) {
 	server *srv = NULL;
 	int print_config = 0;
 	int test_config = 0;
@@ -447,6 +455,10 @@
 	int num_childs = 0;
 	int pid_fd = -1, fd;
 	size_t i;
+#ifdef _WIN32
+	char *optarg = NULL;
+#endif
+
 #ifdef HAVE_SIGACTION
 	struct sigaction act;
 #endif
@@ -485,10 +497,15 @@
 	while(-1 != (o = getopt(argc, argv, "f:m:hvVDpt"))) {
 		switch(o) {
 		case 'f': 
+#ifdef _WIN32
+			/* evil HACK for windows, optarg is not set */
+			optarg = argv[optind-1];
+#endif
 			if (config_read(srv, optarg)) { 
 				server_free(srv);
 				return -1;
 			}
+
 			break;
 		case 'm':
 			buffer_copy_string(srv->srvconf.modules_dir, optarg);
@@ -589,6 +606,7 @@
 		return -1;
 	}
 	
+#ifndef _WIN32
 	/* open pid file BEFORE chroot */
 	if (srv->srvconf.pid_file->used) {
 		if (-1 == (pid_fd = open(srv->srvconf.pid_file->ptr, O_WRONLY | O_CREAT | O_EXCL | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH))) {
@@ -617,13 +635,14 @@
 			}
 		}
 	}
-
+#endif
 	if (srv->event_handler == FDEVENT_HANDLER_SELECT) {
 		/* select limits itself
 		 *
 		 * as it is a hard limit and will lead to a segfault we add some safety
 		 * */
-		srv->max_fds = FD_SETSIZE - 200;
+        fprintf(stderr, "%s.%d: max parallel connections: %d\r\n", __FILE__, __LINE__, FD_SETSIZE);
+		srv->max_fds = FD_SETSIZE - 4;
 	} else {
 		srv->max_fds = 4096;
 	}
@@ -761,7 +780,7 @@
 		}
 
 		if (srv->event_handler == FDEVENT_HANDLER_SELECT) {
-			srv->max_fds = rlim.rlim_cur < FD_SETSIZE - 200 ? rlim.rlim_cur : FD_SETSIZE - 200;
+			srv->max_fds = rlim.rlim_cur < FD_SETSIZE - 4 ? rlim.rlim_cur : FD_SETSIZE - 4;
 		} else {
 			srv->max_fds = rlim.rlim_cur;
 		}
@@ -775,9 +794,9 @@
 #endif
 		if (srv->event_handler == FDEVENT_HANDLER_SELECT) {
 			/* don't raise the limit above FD_SET_SIZE */
-			if (srv->max_fds > FD_SETSIZE - 200) {
+			if (srv->max_fds > FD_SETSIZE - 4) {
 				log_error_write(srv, __FILE__, __LINE__, "sd", 
-						"can't raise max filedescriptors above",  FD_SETSIZE - 200,
+						"can't raise max filedescriptors above",  FD_SETSIZE - 4,
 						"if event-handler is 'select'. Use 'poll' or something else or reduce server.max-fds.");
 				return -1;
 			}
@@ -818,8 +837,10 @@
 	if (srv->srvconf.dont_daemonize == 0) daemonize();
 #endif
 
+#ifdef HAVE_PWD_H
 	srv->gid = getgid();
 	srv->uid = getuid();
+#endif
 	
 	/* write pid file */
 	if (pid_fd != -1) {
@@ -883,7 +904,6 @@
 		return -1;
 	}
 	
-	
 #ifdef HAVE_SIGACTION
 	memset(&act, 0, sizeof(act));
 	act.sa_handler = SIG_IGN;
@@ -957,7 +977,7 @@
 	}
 #endif
 
-	if (NULL == (srv->ev = fdevent_init(srv->max_fds + 1, srv->event_handler))) {
+	if (NULL == (srv->ev = fdevent_init(/*srv->max_fds + 1*/ 4096, srv->event_handler))) {
 		log_error_write(srv, __FILE__, __LINE__,
 				"s", "fdevent_init failed");
 		return -1;
@@ -1025,7 +1045,31 @@
 			/* reset notification */
 			handle_sig_hup = 0;
 			
+#if 0
+            			pid_t pid;
 			
+			/* send the old process into a graceful-shutdown and start a
+			 * new process right away
+			 *
+			 * BUGS:
+			 * - if webserver is running on port < 1024 (e.g. 80, 433)
+			 *   we don't have the permissions to bind to that port anymore
+			 *
+			 *
+			 *  */
+			if (0 == (pid = fork())) {
+				execve(argv[0], argv, envp);
+
+				exit(-1);
+			} else if (pid == -1) {
+
+			} else {
+				/* parent */
+
+				graceful_shutdown = 1; /* shutdown without killing running connections */
+				graceful_restart = 1;  /* don't delete pid file */
+			}
+#else
 			/* cycle logfiles */
 			
 			switch(r = plugins_call_handle_sighup(srv)) {
@@ -1041,6 +1085,7 @@
 				
 				return -1;
 			}
+#endif
 		}
 		
 		if (handle_sig_alarm) {
@@ -1312,7 +1357,8 @@
 		srv->joblist->used = 0;
 	}
 	
-	if (srv->srvconf.pid_file->used &&
+	if (0 == graceful_restart &&
+	    srv->srvconf.pid_file->used &&
 	    srv->srvconf.changeroot->used == 0) {
 		if (0 != unlink(srv->srvconf.pid_file->ptr)) {
 			if (errno != EACCES && errno != EPERM) {
--- lighttpd-1.4.11/src/spawn-fcgi.c	2006-03-07 14:18:10.000000000 +0200
+++ lighttpd/src/spawn-fcgi.c	2006-07-11 21:23:40.167860238 +0300
@@ -1,19 +1,16 @@
 #include <sys/types.h>
-#include <sys/time.h>
 #include <sys/stat.h>
 
 #include <stdlib.h>
 #include <string.h>
 #include <errno.h>
 #include <stdio.h>
-#include <unistd.h>
 #include <fcntl.h>
-
+#include <time.h>
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
-
 #ifdef HAVE_PWD_H
 #include <grp.h>
 #include <pwd.h>
@@ -30,6 +27,7 @@
 #endif
 
 #include "sys-socket.h"
+#include "sys-files.h"
 
 #ifdef HAVE_SYS_WAIT_H
 #include <sys/wait.h>
@@ -145,6 +143,9 @@
 			
 			int i = 0;
 			
+			/* loose control terminal */
+			setsid();
+
 			/* is save as we limit to 256 childs */
 			sprintf(cgi_childs, "PHP_FCGI_CHILDREN=%d", child_count);
 			
--- lighttpd-1.4.11/src/stat_cache.c	2005-11-22 15:23:51.000000000 +0200
+++ lighttpd/src/stat_cache.c	2006-07-11 21:23:40.067853974 +0300
@@ -6,7 +6,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <errno.h>
-#include <unistd.h>
 #include <stdio.h>
 #include <fcntl.h>
 #include <assert.h>
@@ -25,19 +24,8 @@
 #endif
 
 #include "sys-mmap.h"
-
-/* NetBSD 1.3.x needs it */
-#ifndef MAP_FAILED
-# define MAP_FAILED -1
-#endif
-
-#ifndef O_LARGEFILE
-# define O_LARGEFILE 0
-#endif
-
-#ifndef HAVE_LSTAT
-#define lstat stat
-#endif
+#include "sys-files.h"
+#include "sys-strings.h"
 
 #if 0
 /* enables debug code for testing if all nodes in the stat-cache as accessable */
--- lighttpd-1.4.11/src/stream.c	2005-09-23 21:50:15.000000000 +0300
+++ lighttpd/src/stream.c	2006-07-11 21:23:40.215863244 +0300
@@ -1,7 +1,6 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
-#include <unistd.h> 
 #include <fcntl.h>
 
 #include "stream.h"
@@ -10,6 +9,7 @@
 #endif
 
 #include "sys-mmap.h"
+#include "sys-files.h"
 
 #ifndef O_BINARY
 # define O_BINARY 0
@@ -19,7 +19,7 @@
 	struct stat st;
 #ifdef HAVE_MMAP
 	int fd;
-#elif defined __WIN32
+#elif defined _WIN32
 	HANDLE *fh, *mh;
 	void *p;
 #endif
@@ -45,7 +45,7 @@
 		return -1;
 	}
 
-#elif defined __WIN32
+#elif defined _WIN32
 	fh = CreateFile(fn->ptr, 
 			GENERIC_READ, 
 			FILE_SHARE_READ, 
--- lighttpd-1.4.11/src/sys-mmap.h	2005-08-11 01:26:34.000000000 +0300
+++ lighttpd/src/sys-mmap.h	2006-07-11 21:23:40.051852972 +0300
@@ -1,7 +1,7 @@
 #ifndef WIN32_MMAP_H
 #define WIN32_MMAP_H
 
-#ifdef __WIN32
+#ifdef _WIN32
 
 #define MAP_FAILED -1
 #define PROT_SHARED 0
--- lighttpd-1.4.11/src/sys-socket.h	2005-08-11 01:26:39.000000000 +0300
+++ lighttpd/src/sys-socket.h	2006-07-11 21:23:40.051852972 +0300
@@ -1,15 +1,26 @@
 #ifndef WIN32_SOCKET_H
 #define WIN32_SOCKET_H
 
-#ifdef __WIN32
+#ifdef _WIN32
 
 #include <winsock2.h>
 
 #define ECONNRESET WSAECONNRESET
 #define EINPROGRESS WSAEINPROGRESS
 #define EALREADY WSAEALREADY
+#define ENOTCONN WSAENOTCONN
+#define EWOULDBLOCK WSAEWOULDBLOCK
 #define ioctl ioctlsocket
 #define hstrerror(x) ""
+#define STDIN_FILENO 0
+#define STDOUT_FILENO 1
+#define STDERR_FILENO 2
+#define ssize_t int
+
+int inet_aton(const char *cp, struct in_addr *inp);
+#define HAVE_INET_ADDR
+#undef HAVE_INET_ATON
+
 #else
 #include <sys/socket.h>
 #include <sys/ioctl.h>
@@ -18,6 +29,11 @@
 #include <sys/un.h>
 #include <arpa/inet.h>
 
+#ifndef SUN_LEN
+#define SUN_LEN(su) \
+        (sizeof(*(su)) - sizeof((su)->sun_path) + strlen((su)->sun_path))
+#endif
+
 #include <netdb.h>
 #endif
 
--- lighttpd-1.4.11/tests/LightyTest.pm	2006-01-14 20:32:31.000000000 +0200
+++ lighttpd/tests/LightyTest.pm	2006-07-11 21:23:42.047977994 +0300
@@ -87,14 +87,14 @@
 	# pre-process configfile if necessary
 	#
 
-	unlink($self->{TESTDIR}."/tmp/cfg.file");
-	system("cat ".$self->{SRCDIR}."/".$self->{CONFIGFILE}.' | perl -pe "s#\@SRCDIR\@#'.$self->{BASEDIR}.'/tests/#" > '.$self->{TESTDIR}.'/tmp/cfg.file');
+	$ENV{'SRCDIR'} = $self->{BASEDIR}.'/tests';
+	$ENV{'PORT'} = $self->{PORT};
 
 	unlink($self->{LIGHTTPD_PIDFILE});
 	if (1) {
-		system($self->{LIGHTTPD_PATH}." -f ".$self->{TESTDIR}."/tmp/cfg.file -m ".$self->{MODULES_PATH});
+		system($self->{LIGHTTPD_PATH}." -f ".$self->{SRCDIR}."/".$self->{CONFIGFILE}." -m ".$self->{MODULES_PATH});
 	} else {
-		system("valgrind --tool=memcheck --show-reachable=yes --leak-check=yes --logfile=foo ".$self->{LIGHTTPD_PATH}." -D -f ".$self->{TESTDIR}."/tmp/cfg.file -m ".$self->{MODULES_PATH}." &");
+		system("valgrind --tool=memcheck --show-reachable=yes --leak-check=yes --logfile=foo ".$self->{LIGHTTPD_PATH}." -D -f ".$self->{SRCDIR}."/".$self->{CONFIGFILE}." -m ".$self->{MODULES_PATH}." &");
 	}
 
 	select(undef, undef, undef, 0.1);
@@ -184,7 +184,7 @@
 					(my $h = $1) =~ tr/[A-Z]/[a-z]/;
 
 					if (defined $resp_hdr{$h}) {
-						diag(sprintf("header %s is duplicated: %s and %s\n",
+						diag(sprintf("header '%s' is duplicated: '%s' and '%s'\n",
 						             $h, $resp_hdr{$h}, $2));
 					} else {
 						$resp_hdr{$h} = $2;
@@ -196,6 +196,9 @@
 			}
 		}
 
+		$t->{etag} = $resp_hdr{'etag'};
+		$t->{date} = $resp_hdr{'date'};
+
 		# check length
 		if (defined $resp_hdr{"content-length"}) {
 			$resp_body = substr($lines, 0, $resp_hdr{"content-length"});
--- lighttpd-1.4.11/tests/Makefile.am	2005-09-16 15:48:40.000000000 +0300
+++ lighttpd/tests/Makefile.am	2006-07-11 21:23:42.039977492 +0300
@@ -39,10 +39,15 @@
       mod-redirect.t \
       mod-userdir.t \
       mod-rewrite.t \
+      mod-proxy.t \
       request.t \
       mod-ssi.t \
       LightyTest.pm \
-      mod-setenv.t 
+      mod-setenv.t \
+      lowercase.t \
+      lowercase.conf \
+      proxy.conf \
+      cachable.t
 
 
 TESTS_ENVIRONMENT=$(srcdir)/wrapper.sh $(srcdir) $(top_builddir) 
--- lighttpd-1.4.11/tests/bug-06.conf	2005-08-27 17:44:19.000000000 +0300
+++ lighttpd/tests/bug-06.conf	2006-07-11 21:23:41.915969726 +0300
@@ -1,5 +1,5 @@
-server.document-root         = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
-server.pid-file              = "@SRCDIR@/tmp/lighttpd/lighttpd.pid"
+server.document-root         = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
+server.pid-file              = env.SRCDIR + "/tmp/lighttpd/lighttpd.pid"
 
 ## bind to port (default: 80)
 server.port                 = 2048
@@ -8,7 +8,7 @@
 
 ## bind to localhost (default: all interfaces)
 server.bind                = "localhost"
-server.errorlog            = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.error.log"
+server.errorlog            = env.SRCDIR + "/tmp/lighttpd/logs/lighttpd.error.log"
 server.name                = "www.example.org"
 server.tag                 = "Apache 1.3.29"
 
@@ -59,7 +59,7 @@
 ######################## MODULE CONFIG ############################
 
 
-accesslog.filename          = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.access.log"
+accesslog.filename          = env.SRCDIR + "/tmp/lighttpd/logs/lighttpd.access.log"
 
 mimetype.assign             = ( ".png"  => "image/png", 
                                 ".jpg"  => "image/jpeg",
@@ -77,7 +77,7 @@
 				".c"    => "text/plain",
 				".conf" => "text/plain" )
 
-compress.cache-dir          = "@SRCDIR@/tmp/lighttpd/cache/compress/"
+compress.cache-dir          = env.SRCDIR + "/tmp/lighttpd/cache/compress/"
 compress.filetype           = ("text/plain", "text/html")
 
 setenv.add-environment      = ( "TRAC_ENV" => "foo")
@@ -90,7 +90,7 @@
 				    "host" => "127.0.0.1",
 				    "port" => 1026,
 #				    "mode" => "authorizer",
-#				    "docroot" => "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/",
+#				    "docroot" => env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/",
 				  )
 				)
 			      )
@@ -106,7 +106,7 @@
 ssl.pemfile                 = "server.pem"
 
 auth.backend                = "plain"
-auth.backend.plain.userfile = "@SRCDIR@/tmp/lighttpd/lighttpd.user"
+auth.backend.plain.userfile = env.SRCDIR + "/tmp/lighttpd/lighttpd.user"
 auth.backend.plain.groupfile = "lighttpd.group"
 
 auth.backend.ldap.hostname  = "localhost"
@@ -149,15 +149,15 @@
 status.config-url           = "/server-config"
 
 simple-vhost.document-root  = "pages"
-simple-vhost.server-root    = "@SRCDIR@/tmp/lighttpd/servers/"
+simple-vhost.server-root    = env.SRCDIR + "/tmp/lighttpd/servers/"
 simple-vhost.default-host   = "www.example.org"
 
 $HTTP["host"] == "vvv.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
 }
 
 $HTTP["host"] == "zzz.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
   server.name = "zzz.example.org"
 }
 
--- lighttpd-1.4.11/tests/bug-12.conf	2005-08-27 17:44:19.000000000 +0300
+++ lighttpd/tests/bug-12.conf	2006-07-11 21:23:41.907969224 +0300
@@ -1,5 +1,5 @@
-server.document-root         = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
-server.pid-file              = "@SRCDIR@/tmp/lighttpd/lighttpd.pid"
+server.document-root         = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
+server.pid-file              = env.SRCDIR + "/tmp/lighttpd/lighttpd.pid"
 
 ## bind to port (default: 80)
 server.port                 = 2048
@@ -8,7 +8,7 @@
 
 ## bind to localhost (default: all interfaces)
 server.bind                = "localhost"
-server.errorlog            = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.error.log"
+server.errorlog            = env.SRCDIR + "/tmp/lighttpd/logs/lighttpd.error.log"
 server.name                = "www.example.org"
 server.tag                 = "Apache 1.3.29"
 
@@ -61,7 +61,7 @@
 ######################## MODULE CONFIG ############################
 
 
-accesslog.filename          = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.access.log"
+accesslog.filename          = env.SRCDIR + "/tmp/lighttpd/logs/lighttpd.access.log"
 
 mimetype.assign             = ( ".png"  => "image/png", 
                                 ".jpg"  => "image/jpeg",
@@ -79,7 +79,7 @@
 				".c"    => "text/plain",
 				".conf" => "text/plain" )
 
-compress.cache-dir          = "@SRCDIR@/tmp/lighttpd/cache/compress/"
+compress.cache-dir          = env.SRCDIR + "/tmp/lighttpd/cache/compress/"
 compress.filetype           = ("text/plain", "text/html")
 
 setenv.add-environment      = ( "TRAC_ENV" => "foo")
@@ -92,7 +92,7 @@
 				    "host" => "127.0.0.1",
 				    "port" => 1026,
 #				    "mode" => "authorizer",
-#				    "docroot" => "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/",
+#				    "docroot" => env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/",
 				  )
 				)
 			      )
@@ -108,7 +108,7 @@
 ssl.pemfile                 = "server.pem"
 
 auth.backend                = "plain"
-auth.backend.plain.userfile = "@SRCDIR@/tmp/lighttpd/lighttpd.user"
+auth.backend.plain.userfile = env.SRCDIR + "/tmp/lighttpd/lighttpd.user"
 auth.backend.plain.groupfile = "lighttpd.group"
 
 auth.backend.ldap.hostname  = "localhost"
@@ -151,15 +151,15 @@
 status.config-url           = "/server-config"
 
 simple-vhost.document-root  = "pages"
-simple-vhost.server-root    = "@SRCDIR@/tmp/lighttpd/servers/"
+simple-vhost.server-root    = env.SRCDIR + "/tmp/lighttpd/servers/"
 simple-vhost.default-host   = "www.example.org"
 
 $HTTP["host"] == "vvv.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
 }
 
 $HTTP["host"] == "zzz.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
   server.name = "zzz.example.org"
 }
 
--- lighttpd-1.4.11/tests/condition.conf	2005-08-27 17:44:19.000000000 +0300
+++ lighttpd/tests/condition.conf	2006-07-11 21:23:41.951971980 +0300
@@ -2,15 +2,15 @@
 debug.log-request-handling = "enable"
 debug.log-condition-handling = "enable"
 
-server.document-root         = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
-server.pid-file              = "@SRCDIR@/tmp/lighttpd/lighttpd.pid"
+server.document-root         = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
+server.pid-file              = env.SRCDIR + "/tmp/lighttpd/lighttpd.pid"
 
 ## bind to port (default: 80)
 server.port                 = 2048
 
 ## bind to localhost (default: all interfaces)
 server.bind                = "localhost"
-server.errorlog            = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.error.log"
+server.errorlog            = env.SRCDIR + "/tmp/lighttpd/logs/lighttpd.error.log"
 server.name                = "www.example.org"
 server.tag                 = "Apache 1.3.29"
 
@@ -22,25 +22,25 @@
 ######################## MODULE CONFIG ############################
 
 
-accesslog.filename          = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.access.log"
+accesslog.filename          = env.SRCDIR + "/tmp/lighttpd/logs/lighttpd.access.log"
 
 mimetype.assign             = ( ".html" => "text/html" )
 
 url.redirect = ("^" => "/default")
 
 $HTTP["host"] == "www.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
   server.name = "www.example.org"
   url.redirect = ("^" => "/match_1")
 }
 else $HTTP["host"] == "test1.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
   server.name = "test1.example.org"
   url.redirect = ("^" => "/match_2")
 }
 # comments
 else $HTTP["host"] == "test2.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
   server.name = "test2.example.org"
   url.redirect = ("^" => "/match_3")
 }
@@ -48,7 +48,7 @@
 	 # comments
 
 else $HTTP["host"] == "test3.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
   server.name = "test3.example.org"
   url.redirect = ("^" => "/match_4")
 
--- lighttpd-1.4.11/tests/core-keepalive.t	2005-11-17 15:54:19.000000000 +0200
+++ lighttpd/tests/core-keepalive.t	2006-07-11 21:23:41.939971229 +0300
@@ -40,7 +40,7 @@
 
 GET /12345.txt HTTP/1.0
 Host: 123.example.org
-Connection: keep-alive
+Connection: close
 EOF
  );
 $t->{RESPONSE} = [ { 'HTTP-Protocol' => 'HTTP/1.0', 'HTTP-Status' => 200 } , { 'HTTP-Protocol' => 'HTTP/1.0', 'HTTP-Status' => 200 } ];
--- lighttpd-1.4.11/tests/docroot/www/dummydir/.svn/entries	2006-03-09 19:21:49.000000000 +0200
+++ lighttpd/tests/docroot/www/dummydir/.svn/entries	2006-07-11 21:23:41.575948429 +0300
@@ -9,5 +9,6 @@
    last-author="jan"
    kind="dir"
    uuid="152afb58-edef-0310-8abb-c4023f1b3aa9"
-   revision="1040"/>
+   repos="svn://svn.lighttpd.net/lighttpd"
+   revision="1159"/>
 </wc-entries>
--- lighttpd-1.4.11/tests/fastcgi-10.conf	2005-08-31 23:36:34.000000000 +0300
+++ lighttpd/tests/fastcgi-10.conf	2006-07-11 21:23:41.911969475 +0300
@@ -1,12 +1,12 @@
-server.document-root         = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
-server.pid-file              = "@SRCDIR@/tmp/lighttpd/lighttpd.pid"
+server.document-root         = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
+server.pid-file              = env.SRCDIR + "/tmp/lighttpd/lighttpd.pid"
 
 ## bind to port (default: 80)
 server.port                 = 2048
 
 ## bind to localhost (default: all interfaces)
 server.bind                = "localhost"
-server.errorlog            = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.error.log"
+server.errorlog            = env.SRCDIR + "/tmp/lighttpd/logs/lighttpd.error.log"
 server.name                = "www.example.org"
 server.tag                 = "Apache 1.3.29"
 
@@ -44,7 +44,7 @@
 ######################## MODULE CONFIG ############################
 
 
-accesslog.filename          = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.access.log"
+accesslog.filename          = env.SRCDIR + "/tmp/lighttpd/logs/lighttpd.access.log"
 
 mimetype.assign             = ( ".png"  => "image/png", 
                                 ".jpg"  => "image/jpeg",
@@ -62,7 +62,7 @@
 				".c"    => "text/plain",
 				".conf" => "text/plain" )
 
-compress.cache-dir          = "@SRCDIR@/tmp/lighttpd/cache/compress/"
+compress.cache-dir          = env.SRCDIR + "/tmp/lighttpd/cache/compress/"
 compress.filetype           = ("text/plain", "text/html")
 
 fastcgi.debug               = 0
@@ -85,7 +85,7 @@
 ssl.pemfile                 = "server.pem"
 
 auth.backend                = "plain"
-auth.backend.plain.userfile = "@SRCDIR@/tmp/lighttpd/lighttpd.user"
+auth.backend.plain.userfile = env.SRCDIR + "/tmp/lighttpd/lighttpd.user"
 auth.backend.plain.groupfile = "lighttpd.group"
 
 auth.backend.ldap.hostname  = "localhost"
@@ -128,11 +128,11 @@
 status.config-url           = "/server-config"
 
 $HTTP["host"] == "vvv.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
 }
 
 $HTTP["host"] == "zzz.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
   server.name = "zzz.example.org"
 }
 
--- lighttpd-1.4.11/tests/fastcgi-13.conf	2006-01-03 12:38:17.000000000 +0200
+++ lighttpd/tests/fastcgi-13.conf	2006-07-11 21:23:41.971973233 +0300
@@ -1,5 +1,5 @@
-server.document-root         = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
-server.pid-file              = "@SRCDIR@/tmp/lighttpd/lighttpd.pid"
+server.document-root         = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
+server.pid-file              = env.SRCDIR + "/tmp/lighttpd/lighttpd.pid"
 
 debug.log-request-header   = "enable"
 debug.log-response-header  = "enable"
@@ -10,7 +10,7 @@
 
 ## bind to localhost (default: all interfaces)
 server.bind                = "localhost"
-server.errorlog            = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.error.log"
+server.errorlog            = env.SRCDIR + "/tmp/lighttpd/logs/lighttpd.error.log"
 server.name                = "www.example.org"
 server.tag                 = "Apache 1.3.29"
 
@@ -59,7 +59,7 @@
 ######################## MODULE CONFIG ############################
 
 
-accesslog.filename          = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.access.log"
+accesslog.filename          = env.SRCDIR + "/tmp/lighttpd/logs/lighttpd.access.log"
 
 mimetype.assign             = ( ".png"  => "image/png", 
                                 ".jpg"  => "image/jpeg",
@@ -77,7 +77,7 @@
 				".c"    => "text/plain",
 				".conf" => "text/plain" )
 
-compress.cache-dir          = "@SRCDIR@/tmp/lighttpd/cache/compress/"
+compress.cache-dir          = env.SRCDIR + "/tmp/lighttpd/cache/compress/"
 compress.filetype           = ("text/plain", "text/html")
 
 fastcgi.debug               = 0
@@ -102,7 +102,7 @@
 ssl.pemfile                 = "server.pem"
 
 auth.backend                = "plain"
-auth.backend.plain.userfile = "@SRCDIR@/tmp/lighttpd/lighttpd.user"
+auth.backend.plain.userfile = env.SRCDIR + "/tmp/lighttpd/lighttpd.user"
 auth.backend.plain.groupfile = "lighttpd.group"
 
 auth.backend.ldap.hostname  = "localhost"
@@ -145,11 +145,11 @@
 status.config-url           = "/server-config"
 
 $HTTP["host"] == "vvv.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
 }
 
 $HTTP["host"] == "zzz.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
   server.name = "zzz.example.org"
 }
 
--- lighttpd-1.4.11/tests/fastcgi-auth.conf	2005-08-27 17:44:19.000000000 +0300
+++ lighttpd/tests/fastcgi-auth.conf	2006-07-11 21:23:42.003975238 +0300
@@ -1,5 +1,5 @@
-server.document-root         = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
-server.pid-file              = "@SRCDIR@/tmp/lighttpd/lighttpd.pid"
+server.document-root         = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
+server.pid-file              = env.SRCDIR + "/tmp/lighttpd/lighttpd.pid"
 
 debug.log-request-header   = "enable"
 debug.log-response-header  = "enable"
@@ -12,7 +12,7 @@
 
 ## bind to localhost (default: all interfaces)
 server.bind                = "localhost"
-server.errorlog            = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.error.log"
+server.errorlog            = env.SRCDIR + "/tmp/lighttpd/logs/lighttpd.error.log"
 server.name                = "www.example.org"
 server.tag                 = "Apache 1.3.29"
 
@@ -61,7 +61,7 @@
 ######################## MODULE CONFIG ############################
 
 
-accesslog.filename          = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.access.log"
+accesslog.filename          = env.SRCDIR + "/tmp/lighttpd/logs/lighttpd.access.log"
 
 mimetype.assign             = ( ".png"  => "image/png", 
                                 ".jpg"  => "image/jpeg",
@@ -79,7 +79,7 @@
 				".c"    => "text/plain",
 				".conf" => "text/plain" )
 
-compress.cache-dir          = "@SRCDIR@/tmp/lighttpd/cache/compress/"
+compress.cache-dir          = env.SRCDIR + "/tmp/lighttpd/cache/compress/"
 compress.filetype           = ("text/plain", "text/html")
 
 fastcgi.debug               = 0
@@ -87,9 +87,9 @@
                                   "grisu" => ( 
 				    "host" => "127.0.0.1",
 				    "port" => 20000,
-				    "bin-path" => "@SRCDIR@/fcgi-auth",
+				    "bin-path" => env.SRCDIR + "/fcgi-auth",
                                     "mode" => "authorizer",
-                                    "docroot" => "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/",
+                                    "docroot" => env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/",
 				    
 				  )
 				)
@@ -106,7 +106,7 @@
 ssl.pemfile                 = "server.pem"
 
 auth.backend                = "plain"
-auth.backend.plain.userfile = "@SRCDIR@/tmp/lighttpd/lighttpd.user"
+auth.backend.plain.userfile = env.SRCDIR + "/tmp/lighttpd/lighttpd.user"
 auth.backend.plain.groupfile = "lighttpd.group"
 
 auth.backend.ldap.hostname  = "localhost"
@@ -149,11 +149,11 @@
 status.config-url           = "/server-config"
 
 $HTTP["host"] == "vvv.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
 }
 
 $HTTP["host"] == "zzz.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
   server.name = "zzz.example.org"
 }
 
--- lighttpd-1.4.11/tests/fastcgi-responder.conf	2005-08-27 17:44:19.000000000 +0300
+++ lighttpd/tests/fastcgi-responder.conf	2006-07-11 21:23:41.999974987 +0300
@@ -1,5 +1,5 @@
-server.document-root         = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
-server.pid-file              = "@SRCDIR@/tmp/lighttpd/lighttpd.pid"
+server.document-root         = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
+server.pid-file              = env.SRCDIR + "/tmp/lighttpd/lighttpd.pid"
 
 #debug.log-request-header   = "enable"
 #debug.log-response-header  = "enable"
@@ -15,7 +15,7 @@
 
 ## bind to localhost (default: all interfaces)
 server.bind                = "localhost"
-server.errorlog            = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.error.log"
+server.errorlog            = env.SRCDIR + "/tmp/lighttpd/logs/lighttpd.error.log"
 server.name                = "www.example.org"
 server.tag                 = "Apache 1.3.29"
 
@@ -64,7 +64,7 @@
 ######################## MODULE CONFIG ############################
 
 
-accesslog.filename          = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.access.log"
+accesslog.filename          = env.SRCDIR + "/tmp/lighttpd/logs/lighttpd.access.log"
 
 mimetype.assign             = ( ".png"  => "image/png", 
                                 ".jpg"  => "image/jpeg",
@@ -82,7 +82,7 @@
 				".c"    => "text/plain",
 				".conf" => "text/plain" )
 
-compress.cache-dir          = "@SRCDIR@/tmp/lighttpd/cache/compress/"
+compress.cache-dir          = env.SRCDIR + "/tmp/lighttpd/cache/compress/"
 compress.filetype           = ("text/plain", "text/html")
 
 fastcgi.debug               = 0
@@ -90,10 +90,11 @@
                                   "grisu" => ( 
 				    "host" => "127.0.0.1",
 				    "port" => 10000,
-				    "bin-path" => "@SRCDIR@/fcgi-responder",
+				    "bin-path" => env.SRCDIR + "/fcgi-responder",
 				    "check-local" => "disable",
 				    "max-procs" => 1,
-				    "min-procs" => 1
+				    "min-procs" => 1,
+				    "allow-x-send-file" => "enable",
 				  )
 				)
 			      )
@@ -109,7 +110,7 @@
 ssl.pemfile                 = "server.pem"
 
 auth.backend                = "plain"
-auth.backend.plain.userfile = "@SRCDIR@/tmp/lighttpd/lighttpd.user"
+auth.backend.plain.userfile = env.SRCDIR + "/tmp/lighttpd/lighttpd.user"
 auth.backend.plain.groupfile = "lighttpd.group"
 
 auth.backend.ldap.hostname  = "localhost"
@@ -152,11 +153,11 @@
 status.config-url           = "/server-config"
 
 $HTTP["host"] == "vvv.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
 }
 
 $HTTP["host"] == "zzz.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
   server.name = "zzz.example.org"
 }
 
--- lighttpd-1.4.11/tests/fcgi-responder.c	2005-08-11 01:26:55.000000000 +0300
+++ lighttpd/tests/fcgi-responder.c	2006-07-11 21:23:41.979973734 +0300
@@ -6,11 +6,17 @@
 int main () {
 	int num_requests = 2;
 	
-	while (num_requests > 0 &&
-	       FCGI_Accept() >= 0) {
-		char* p;
+	while (num_requests > 0 && FCGI_Accept() >= 0) {
+		char* p = NULL;
+		char* doc_root = NULL;
+		char fname[4096];
+		char* pfname = (char *)fname;
 		
-		if (NULL != (p = getenv("QUERY_STRING"))) {
+		doc_root = getenv("DOCUMENT_ROOT");
+		p = getenv("QUERY_STRING");
+
+		if (NULL != p && NULL != doc_root) {
+			snprintf(pfname, sizeof(fname), "%s/phpinfo.php", doc_root);
 			if (0 == strcmp(p, "lf")) {
 				printf("Status: 200 OK\n\n");
 			} else if (0 == strcmp(p, "crlf")) {
@@ -23,6 +29,18 @@
 				printf("Status: 200 OK\r\n");
 				fflush(stdout);
 				printf("\r\n");
+			} else if (0 == strcmp(p,"x-lighttpd-send-file")) {
+				printf("Status: 200 OK\r\n");
+				printf("X-LIGHTTPD-send-file: %s\r\n", pfname);
+				printf("\r\n");
+			} else if (0 == strcmp(p,"xsendfile")) {
+				printf("Status: 200 OK\r\n");
+				printf("X-Sendfile: %s\r\n", pfname);
+				printf("\r\n");
+			} else if (0 == strcmp(p,"xsendfile-mixed-case")) {
+				printf("Status: 200 OK\r\n");
+				printf("X-SeNdFiLe: %s\r\n", pfname);
+				printf("\r\n");
 			} else if (0 == strcmp(p, "die-at-end")) {
 				printf("Status: 200 OK\r\n\r\n");
 				num_requests--;
--- lighttpd-1.4.11/tests/lighttpd.conf	2006-03-09 15:26:58.000000000 +0200
+++ lighttpd/tests/lighttpd.conf	2006-07-11 21:23:41.999974987 +0300
@@ -1,80 +1,18 @@
-debug.log-request-handling = "enable"
-debug.log-condition-handling = "enable"
-server.document-root         = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
-server.pid-file              = "@SRCDIR@/tmp/lighttpd/lighttpd.pid"
+server.document-root         = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
+server.pid-file              = env.SRCDIR + "/tmp/lighttpd/lighttpd.pid"
+server.tag = "Apache 1.3.29"
 
 ## 64 Mbyte ... nice limit
 server.max-request-size = 65000
 
-## bind to port (default: 80)
-server.port                 = 2048
-
-## bind to localhost (default: all interfaces)
-server.bind                = "localhost"
-server.errorlog            = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.error.log"
-server.name                = "www.example.org"
-server.tag                 = "Apache 1.3.29"
-
-server.dir-listing          = "enable"
+include "default.conf"
 
-#server.event-handler        = "linux-sysepoll"
-#server.event-handler        = "linux-rtsig"
-
-#server.modules.path         = ""
-server.modules              = ( 
-				"mod_rewrite",
-				"mod_setenv",
-				"mod_secdownload",
-			        "mod_access", 
-				"mod_auth",
-#				"mod_httptls",
-				"mod_status", 
-				"mod_expire",
-				"mod_simple_vhost",
-				"mod_redirect", 
-#				"mod_evhost",
-#				"mod_localizer",
-				"mod_fastcgi",
-				"mod_cgi",
-				"mod_compress",
-				"mod_userdir",
-				"mod_ssi",
-				"mod_accesslog" ) 
-
-server.indexfiles           = ( "index.php", "index.html", 
-                                "index.htm", "default.htm" )
-
-
-######################## MODULE CONFIG ############################
-
-ssi.extension = ( ".shtml" )
-
-accesslog.filename          = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.access.log"
-
-mimetype.assign             = ( ".png"  => "image/png", 
-                                ".jpg"  => "image/jpeg",
-                                ".jpeg" => "image/jpeg",
-                                ".gif"  => "image/gif",
-                                ".html" => "text/html",
-                                ".htm"  => "text/html",
-                                ".pdf"  => "application/pdf",
-                                ".swf"  => "application/x-shockwave-flash",
-                                ".spl"  => "application/futuresplash",
-                                ".txt"  => "text/plain",
-                                ".tar.gz" =>   "application/x-tgz",
-                                ".tgz"  => "application/x-tgz",
-                                ".gz"   => "application/x-gzip",
-				".c"    => "text/plain",
-				".conf" => "text/plain" )
+setenv.add-request-header   = ( "FOO" => "foo")
+setenv.add-response-header  = ( "BAR" => "foo")
 
 $HTTP["host"] == "cache.example.org" {
-  compress.cache-dir          = "@SRCDIR@/tmp/lighttpd/cache/compress/"
+  compress.cache-dir          = env.SRCDIR + "/tmp/lighttpd/cache/compress/"
 }
-compress.filetype           = ("text/plain", "text/html")
-
-setenv.add-environment      = ( "TRAC_ENV" => "tracenv", "SETENV" => "setenv")
-setenv.add-request-header   = ( "FOO" => "foo")
-setenv.add-response-header  = ( "BAR" => "foo")
 
 $HTTP["url"] =~ "\.pdf$" {
   server.range-requests = "disable"
@@ -85,76 +23,31 @@
 			        "/prefix.fcgi" => ( ( "host" => "127.0.0.1", "port" => 1026, "check-local" => "disable", "broken-scriptfilename" => "enable" ) )
 			      )
 		
-
-cgi.assign                  = ( ".pl"  => "/usr/bin/perl",
-                                ".cgi" => "/usr/bin/perl",
-				".py"  => "/usr/bin/python" )
-			
-userdir.include-user = ( "jan" )
-userdir.path = "/"
-
-ssl.engine                  = "disable"
-ssl.pemfile                 = "server.pem"
-
 $HTTP["host"] == "auth-htpasswd.example.org" {
 	auth.backend                = "htpasswd"
 }
 
-auth.backend                = "plain"
-auth.backend.plain.userfile = "@SRCDIR@/tmp/lighttpd/lighttpd.user"
-
-auth.backend.htpasswd.userfile = "@SRCDIR@/tmp/lighttpd/lighttpd.htpasswd"
-
-
-auth.require                = ( "/server-status" => 
-                                ( 
-				  "method"  => "digest",
-				  "realm"   => "download archiv",
-				  "require" => "group=www|user=jan|host=192.168.2.10"
-				),
-				"/server-config" => 
-                                ( 
-				  "method"  => "basic",
-				  "realm"   => "download archiv",
-				  "require" => "valid-user"
-				)
-                              )
-
-url.access-deny             = ( "~", ".inc")
-
-url.rewrite		    = ( "^/rewrite/foo($|\?.+)" => "/indexfile/rewrite.php$1",
-				"^/rewrite/bar(?:$|\?(.+))" => "/indexfile/rewrite.php?bar&$1" )
-
-expire.url                  = ( "/expire/access" => "access 2 hours", 
-				"/expire/modification" => "access plus 1 seconds 2 minutes")
-
-#cache.cache-dir             = "/home/weigon/wwwroot/cache/"
-
-#### status module
-status.status-url           = "/server-status"
-status.config-url           = "/server-config"
-
 $HTTP["host"] == "vvv.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
   secdownload.secret          = "verysecret"
-  secdownload.document-root   = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  secdownload.document-root   = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
   secdownload.uri-prefix      = "/sec/"
   secdownload.timeout         = 120
 }
 
 $HTTP["host"] == "zzz.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
   server.name = "zzz.example.org"
 }
 
 $HTTP["host"] == "no-simple.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/123.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/123.example.org/pages/"
   server.name = "zzz.example.org"
 }
 
 $HTTP["host"] !~ "(no-simple\.example\.org)" {
   simple-vhost.document-root  = "pages"
-  simple-vhost.server-root    = "@SRCDIR@/tmp/lighttpd/servers/"
+  simple-vhost.server-root    = env.SRCDIR + "/tmp/lighttpd/servers/"
   simple-vhost.default-host   = "www.example.org"
 }
 
--- lighttpd-1.4.11/tests/mod-fastcgi.t	2006-03-09 15:30:45.000000000 +0200
+++ lighttpd/tests/mod-fastcgi.t	2006-07-11 21:23:41.995974736 +0300
@@ -7,7 +7,7 @@
 }
 
 use strict;
-use Test::More tests => 47;
+use Test::More tests => 49;
 use LightyTest;
 
 my $tf = LightyTest->new();
@@ -15,7 +15,7 @@
 my $t;
 
 SKIP: {
-	skip "no PHP running on port 1026", 30 unless $tf->listening_on(1026);
+	skip "no PHP running on port 1026", 29 unless $tf->listening_on(1026);
 
 	ok($tf->start_proc == 0, "Starting lighttpd") or die();
 
@@ -285,6 +285,34 @@
 	$t->{RESPONSE} = [ { 'HTTP-Protocol' => 'HTTP/1.0', 'HTTP-Status' => 200, 'HTTP-Content' => 'test123' } ];
 	ok($tf->handle_http($t) == 0, 'line-ending \r\n + \r\n');
 
+    # X-LIGHTTPD-send-file
+	$t->{REQUEST}  = ( <<EOF
+GET /index.fcgi?x-lighttpd-send-file HTTP/1.0
+Host: www.example.org
+EOF
+ );
+	$t->{RESPONSE} = [ { 'HTTP-Protocol' => 'HTTP/1.0', 'HTTP-Status' => 200, 'HTTP-Content' => '<?php phpinfo(); ?>
+' } ];
+	ok($tf->handle_http($t) == 0, 'X-LIGHTTPD-send-file');
+    # X-Sendfile
+	$t->{REQUEST}  = ( <<EOF
+GET /index.fcgi?xsendfile HTTP/1.0
+Host: www.example.org
+EOF
+ );
+	$t->{RESPONSE} = [ { 'HTTP-Protocol' => 'HTTP/1.0', 'HTTP-Status' => 200, 'HTTP-Content' => '<?php phpinfo(); ?>
+' } ];
+	ok($tf->handle_http($t) == 0, 'X-Sendfile');
+
+	$t->{REQUEST}  = ( <<EOF
+GET /index.fcgi?xsendfile-mixed-case HTTP/1.0
+Host: www.example.org
+EOF
+ );
+	$t->{RESPONSE} = [ { 'HTTP-Protocol' => 'HTTP/1.0', 'HTTP-Status' => 200, 'HTTP-Content' => '<?php phpinfo(); ?>
+' } ];
+	ok($tf->handle_http($t) == 0, 'X-SeNdFiLe in mixed case');
+
 	$t->{REQUEST}  = ( <<EOF
 GET /index.fcgi?die-at-end HTTP/1.0
 Host: www.example.org
--- lighttpd-1.4.11/tests/var-include.conf	2005-08-27 17:44:19.000000000 +0300
+++ lighttpd/tests/var-include.conf	2006-07-11 21:23:41.943971479 +0300
@@ -2,15 +2,15 @@
 debug.log-request-handling = "enable"
 debug.log-condition-handling = "enable"
 
-server.document-root         = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
-server.pid-file              = "@SRCDIR@/tmp/lighttpd/lighttpd.pid"
+server.document-root         = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
+server.pid-file              = env.SRCDIR + "/tmp/lighttpd/lighttpd.pid"
 
 ## bind to port (default: 80)
 server.port                 = 2048
 
 ## bind to localhost (default: all interfaces)
 server.bind                = "localhost"
-server.errorlog            = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.error.log"
+server.errorlog            = env.SRCDIR + "/tmp/lighttpd/logs/lighttpd.error.log"
 server.name                = "www.example.org"
 server.tag                 = "Apache 1.3.29"
 
@@ -21,19 +21,19 @@
 ######################## MODULE CONFIG ############################
 
 
-accesslog.filename          = "@SRCDIR@/tmp/lighttpd/logs/lighttpd.access.log"
+accesslog.filename          = env.SRCDIR + "/tmp/lighttpd/logs/lighttpd.access.log"
 
 mimetype.assign             = ( ".html" => "text/html" )
 
 url.redirect = ("^" => "/default")
 
 $HTTP["host"] == "www.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
   server.name = "www.example.org"
   url.redirect = ("^" => "/redirect")
 }
 $HTTP["host"] == "test.example.org" {
-  server.document-root = "@SRCDIR@/tmp/lighttpd/servers/www.example.org/pages/"
+  server.document-root = env.SRCDIR + "/tmp/lighttpd/servers/www.example.org/pages/"
   server.name = "test.example.org"
   var.myvar = "good"
   var.one = 1
